'''
https://codeforces.com/contest/2144/problem/C
'''

MOD = 998244353

def solve():
    """
    Решение задачи C: Make It Permutation
    
    Задача:
    Даны два целочисленных массива a и b одинаковой длины n.
    Можно выбрать любое подмножество индексов и поменять местами элементы
    в этих позициях (выполнить операцию swap(a_i, b_i) для каждого i в подмножестве).
    Подмножество индексов считается хорошим, если после всех обменов оба массива
    будут отсортированы по неубыванию.
    Требуется вычислить количество хороших подмножеств по модулю 998244353.
    
    Входные данные:
    - Первая строка: количество тестовых случаев t
    - Для каждого теста:
        * Первая строка: целое число n (длина массивов)
        * Вторая строка: n целых чисел (массив a)
        * Третья строка: n целых чисел (массив b)
    
    Выходные данные:
    - Для каждого теста выводит одно целое число - количество хороших подмножеств
      по модулю 998244353.
    
    Пример:
    Ввод: 
        3
        3
        2 1 4
        1 3 2
        1
        4
        4
        5
        2 3 3 4 4
        1 1 3 5 6
    
    Вывод:
        2
        2
        8
    """
    n = int(input().strip())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    # dp[i][0] - количество способов для первых i элементов, не меняя i-ый элемент
    # dp[i][1] - количество способов для первых i элементов, меняя i-ый элемент
    dp = [[0, 0] for _ in range(n)]
    
    # Базовые случаи для первого элемента
    dp[0][0] = 1  # Не меняем первый элемент
    dp[0][1] = 1  # Меняем первый элемент
    
    for i in range(1, n):
        # Если не меняем текущий элемент
        if a[i] >= a[i-1] and b[i] >= b[i-1]:
            dp[i][0] = (dp[i][0] + dp[i-1][0]) % MOD
        if a[i] >= b[i-1] and b[i] >= a[i-1]:
            dp[i][0] = (dp[i][0] + dp[i-1][1]) % MOD
        
        # Если меняем текущий элемент
        if b[i] >= a[i-1] and a[i] >= b[i-1]:
            dp[i][1] = (dp[i][1] + dp[i-1][0]) % MOD
        if b[i] >= b[i-1] and a[i] >= a[i-1]:
            dp[i][1] = (dp[i][1] + dp[i-1][1]) % MOD
    
    result = (dp[n-1][0] + dp[n-1][1]) % MOD
    print(result)

t = int(input().strip())
for _ in range(t):
    solve()

''' Полезные ссылки: '''
# 1. Telegram ❃ Хижина программиста Æ: https://t.me/hut_programmer_07
# 2. Telegram №1 @quadd4rv1n7
# 3. Telegram №2 @dupley_maxim_1999
# 4. Rutube канал: https://rutube.ru/channel/4218729/
# 5. Plvideo канал: https://plvideo.ru/channel/AUPv_p1r5AQJ
# 6. YouTube канал: https://www.youtube.com/@it-coders
# 7. ВК группа: https://vk.com/science_geeks