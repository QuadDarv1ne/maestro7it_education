# ü§ñ –ü–æ–ª–Ω—ã–π –º–∞–Ω—É–∞–ª –ø–æ —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–µ: –û—Ç –æ—Å–Ω–æ–≤ –¥–æ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤

## üìã –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–í–≤–µ–¥–µ–Ω–∏–µ –≤ —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫—É](#–≤–≤–µ–¥–µ–Ω–∏–µ-–≤-—Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫—É)
2. [–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Ä–æ–±–æ—Ç–æ–≤](#–æ—Å–Ω–æ–≤–Ω—ã–µ-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã-—Ä–æ–±–æ—Ç–æ–≤)
3. [–ü–ª–∞—Ç—Ñ–æ—Ä–º—ã –∏ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã](#–ø–ª–∞—Ç—Ñ–æ—Ä–º—ã-–∏-–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã)
4. [–î–∞—Ç—á–∏–∫–∏ –∏ –≤–æ—Å–ø—Ä–∏—è—Ç–∏–µ](#–¥–∞—Ç—á–∏–∫–∏-–∏-–≤–æ—Å–ø—Ä–∏—è—Ç–∏–µ)
5. [–ê–∫—Ç—É–∞—Ç–æ—Ä—ã –∏ –ø—Ä–∏–≤–æ–¥—ã](#–∞–∫—Ç—É–∞—Ç–æ—Ä—ã-–∏-–ø—Ä–∏–≤–æ–¥—ã)
6. [–ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–æ–±–æ—Ç–æ–≤](#–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ-—Ä–æ–±–æ—Ç–æ–≤)
7. [–ö–∏–Ω–µ–º–∞—Ç–∏–∫–∞ –∏ –¥–≤–∏–∂–µ–Ω–∏–µ](#–∫–∏–Ω–µ–º–∞—Ç–∏–∫–∞-–∏-–¥–≤–∏–∂–µ–Ω–∏–µ)
8. [–ö–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–µ –∑—Ä–µ–Ω–∏–µ](#–∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–µ-–∑—Ä–µ–Ω–∏–µ)
9. [–ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç –≤ —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–µ](#–∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π-–∏–Ω—Ç–µ–ª–ª–µ–∫—Ç-–≤-—Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–µ)
10. [–°–∏—Å—Ç–µ–º—ã –Ω–∞–≤–∏–≥–∞—Ü–∏–∏](#—Å–∏—Å—Ç–µ–º—ã-–Ω–∞–≤–∏–≥–∞—Ü–∏–∏)
11. [–ë–µ—Å–ø–∏–ª–æ—Ç–Ω—ã–µ –∞–≤—Ç–æ–º–æ–±–∏–ª–∏](#–±–µ—Å–ø–∏–ª–æ—Ç–Ω—ã–µ-–∞–≤—Ç–æ–º–æ–±–∏–ª–∏)
12. [–ü—Ä–æ–º—ã—à–ª–µ–Ω–Ω–∞—è —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞](#–ø—Ä–æ–º—ã—à–ª–µ–Ω–Ω–∞—è-—Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞)
13. [–†–æ–±–æ—Ç—ã-–º–∞–Ω–∏–ø—É–ª—è—Ç–æ—Ä—ã](#—Ä–æ–±–æ—Ç—ã-–º–∞–Ω–∏–ø—É–ª—è—Ç–æ—Ä—ã)
14. [–ú–æ–±–∏–ª—å–Ω—ã–µ —Ä–æ–±–æ—Ç—ã](#–º–æ–±–∏–ª—å–Ω—ã–µ-—Ä–æ–±–æ—Ç—ã)
15. [–ü—Ä–æ–µ–∫—Ç—ã –∏ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã](#–ø—Ä–æ–µ–∫—Ç—ã-–∏-–ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ-–ø—Ä–∏–º–µ—Ä—ã)
16. [–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ —ç—Ç–∏–∫–∞](#–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å-–∏-—ç—Ç–∏–∫–∞)
17. [–ë—É–¥—É—â–µ–µ —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∏](#–±—É–¥—É—â–µ–µ-—Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∏)

## –í–≤–µ–¥–µ–Ω–∏–µ –≤ —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫—É

**–†–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞** ‚Äî —ç—Ç–æ –º–µ–∂–¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞—Ä–Ω–∞—è –æ–±–ª–∞—Å—Ç—å –∏–Ω–∂–µ–Ω–µ—Ä–∏–∏ –∏ –Ω–∞—É–∫–∏, –∫–æ—Ç–æ—Ä–∞—è –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç –º–µ—Ö–∞–Ω–∏–∫—É, —ç–ª–µ–∫—Ç—Ä–æ–Ω–∏–∫—É, –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫—É –∏ –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∞–≤—Ç–æ–Ω–æ–º–Ω—ã—Ö —Å–∏—Å—Ç–µ–º, —Å–ø–æ—Å–æ–±–Ω—ã—Ö –≤—ã–ø–æ–ª–Ω—è—Ç—å –∑–∞–¥–∞—á–∏ –≤ —Ñ–∏–∑–∏—á–µ—Å–∫–æ–º –º–∏—Ä–µ.

### –ß—Ç–æ —Ç–∞–∫–æ–µ —Ä–æ–±–æ—Ç?

–†–æ–±–æ—Ç ‚Äî —ç—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä—É–µ–º–∞—è –º–∞—à–∏–Ω–∞, —Å–ø–æ—Å–æ–±–Ω–∞—è –≤—ã–ø–æ–ª–Ω—è—Ç—å –∞–≤—Ç–æ–Ω–æ–º–Ω—ã–µ –∏–ª–∏ –ø–æ–ª—É–∞–≤—Ç–æ–Ω–æ–º–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π —Ü–µ–ª–∏. –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–æ–±–æ—Ç—ã —Å–æ—á–µ—Ç–∞—é—Ç –≤ —Å–µ–±–µ:

- **–ú–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã** ‚Äî —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏ –¥–≤–∏–∂–µ–Ω–∏–µ
- **–≠–ª–µ–∫—Ç—Ä–æ–Ω–Ω—ã–µ —Å–∏—Å—Ç–µ–º—ã** ‚Äî —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Å–µ–Ω—Å–æ—Ä–∏–∫–∞
- **–ü—Ä–æ–≥—Ä–∞–º–º–Ω–æ–µ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ** ‚Äî –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç –∏ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
- **–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã** ‚Äî –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –æ–∫—Ä—É–∂–∞—é—â–µ–π —Å—Ä–µ–¥–æ–π

### –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Ä–æ–±–æ—Ç–æ–≤:

#### –ü–æ —Å—Ç–µ–ø–µ–Ω–∏ –∞–≤—Ç–æ–Ω–æ–º–∏–∏:
- **–¢–µ–ª–µ–æ–ø–µ—Ä–∏—Ä—É–µ–º—ã–µ** ‚Äî –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–ø—Ä–∞–≤–ª—è—é—Ç—Å—è —á–µ–ª–æ–≤–µ–∫–æ–º
- **–ü–æ–ª—É–∞–≤—Ç–æ–Ω–æ–º–Ω—ã–µ** ‚Äî —á–µ–ª–æ–≤–µ–∫ –∑–∞–¥–∞–µ—Ç –∑–∞–¥–∞—á–∏, —Ä–æ–±–æ—Ç –≤—ã–ø–æ–ª–Ω—è–µ—Ç
- **–ê–≤—Ç–æ–Ω–æ–º–Ω—ã–µ** ‚Äî —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –ø—Ä–∏–Ω–∏–º–∞—é—Ç —Ä–µ—à–µ–Ω–∏—è

#### –ü–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—é:
- **–ü—Ä–æ–º—ã—à–ª–µ–Ω–Ω—ã–µ** ‚Äî —Å–±–æ—Ä–æ—á–Ω—ã–µ –ª–∏–Ω–∏–∏, —Å–≤–∞—Ä–∫–∞, –ø–æ–∫—Ä–∞—Å–∫–∞
- **–°–µ—Ä–≤–∏—Å–Ω—ã–µ** ‚Äî —É–±–æ—Ä–∫–∞, –¥–æ—Å—Ç–∞–≤–∫–∞, –º–µ–¥–∏—Ü–∏–Ω–∞
- **–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ** ‚Äî –∫–æ—Å–º–æ—Å, –≥–ª—É–±–∏–Ω—ã –æ–∫–µ–∞–Ω–∞, –æ–ø–∞—Å–Ω—ã–µ –∑–æ–Ω—ã
- **–†–∞–∑–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω—ã–µ** ‚Äî –∏–≥—Ä—É—à–∫–∏, –∞–Ω–∏–º–∞—Ç—Ä–æ–Ω–∏–∫–∞

#### –ü–æ —Ç–∏–ø—É –¥–≤–∏–∂–µ–Ω–∏—è:
- **–°—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω—ã–µ** ‚Äî –º–∞–Ω–∏–ø—É–ª—è—Ç–æ—Ä—ã, —Å—Ç–∞–Ω–∫–∏
- **–ú–æ–±–∏–ª—å–Ω—ã–µ** ‚Äî –∫–æ–ª–µ—Å–Ω—ã–µ, –≥—É—Å–µ–Ω–∏—á–Ω—ã–µ, –ª–µ—Ç–∞—é—â–∏–µ
- **–ì–∏–±—Ä–∏–¥–Ω—ã–µ** ‚Äî –Ω–æ–≥–∏ + –∫–æ–ª–µ—Å–∞

### –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∞–∑–≤–∏—Ç–∏—è:

1. **–ò–Ω–¥—É—Å—Ç—Ä–∏—è 4.0** ‚Äî —É–º–Ω—ã–µ —Ñ–∞–±—Ä–∏–∫–∏ –∏ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è
2. **–°–µ—Ä–≤–∏—Å–Ω–∞—è —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞** ‚Äî –ø–æ–º–æ—â—å –ª—é–¥—è–º –≤ –ø–æ–≤—Å–µ–¥–Ω–µ–≤–Ω–æ–π –∂–∏–∑–Ω–∏
3. **–ú–µ–¥–∏—Ü–∏–Ω—Å–∫–∞—è —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞** ‚Äî —Ö–∏—Ä—É—Ä–≥–∏—è, —Ä–µ–∞–±–∏–ª–∏—Ç–∞—Ü–∏—è
4. **–¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∞—è —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞** ‚Äî –±–µ—Å–ø–∏–ª–æ—Ç–Ω—ã–µ –∞–≤—Ç–æ–º–æ–±–∏–ª–∏
5. **–ö–æ—Å–º–∏—á–µ—Å–∫–∞—è —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞** ‚Äî –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –ø–ª–∞–Ω–µ—Ç

## –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Ä–æ–±–æ—Ç–æ–≤

### 1. –ú–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∞—è —á–∞—Å—Ç—å

#### –°—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã:
- **–ö–æ—Ä–ø—É—Å** ‚Äî –∑–∞—â–∏—Ç–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
- **–®–∞—Å—Å–∏** ‚Äî –æ—Å–Ω–æ–≤–∞–Ω–∏–µ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —Ä–æ–±–æ—Ç–æ–≤
- **–°–æ–µ–¥–∏–Ω–µ–Ω–∏—è** ‚Äî —à–∞—Ä–Ω–∏—Ä—ã, –ø–æ–¥—à–∏–ø–Ω–∏–∫–∏, –∫—Ä–µ–ø–ª–µ–Ω–∏—è

#### –ü—Ä–∏–º–µ—Ä —Ä–∞—Å—á–µ—Ç–∞ –ø—Ä–æ—á–Ω–æ—Å—Ç–∏:
```python
# –†–∞—Å—á–µ—Ç –º–æ–º–µ–Ω—Ç–∞ —Å–∏–ª—ã –¥–ª—è —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–∞
def calculate_torque(mass, arm_length, gravity=9.81):
    """
    –†–∞—Å—á–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–≥–æ –∫—Ä—É—Ç—è—â–µ–≥–æ –º–æ–º–µ–Ω—Ç–∞
    mass: –º–∞—Å—Å–∞ –≤ –∫–≥
    arm_length: –¥–ª–∏–Ω–∞ —Ä—ã—á–∞–≥–∞ –≤ –º–µ—Ç—Ä–∞—Ö
    """
    return mass * gravity * arm_length

# –ü—Ä–∏–º–µ—Ä: —Ä–æ–±–æ—Ç-–º–∞–Ω–∏–ø—É–ª—è—Ç–æ—Ä —Å –≥—Ä—É–∑–æ–º 0.5 –∫–≥ –Ω–∞ –ø–ª–µ—á–µ 0.3 –º
torque = calculate_torque(0.5, 0.3)
print(f"–ù–µ–æ–±—Ö–æ–¥–∏–º—ã–π –º–æ–º–µ–Ω—Ç: {torque:.2f} –ù¬∑–º")
```

### 2. –≠–ª–µ–∫—Ç—Ä–æ–Ω–Ω–∞—è —á–∞—Å—Ç—å

#### –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:
- **–ú–∏–∫—Ä–æ–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã** ‚Äî "–º–æ–∑–≥" —Ä–æ–±–æ—Ç–∞
- **–î—Ä–∞–π–≤–µ—Ä—ã –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π** ‚Äî —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ—â–Ω—ã–º–∏ –º–æ—Ç–æ—Ä–∞–º–∏
- **–°–µ–Ω—Å–æ—Ä–Ω—ã–µ –º–æ–¥—É–ª–∏** ‚Äî –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –æ—Ç –¥–∞—Ç—á–∏–∫–æ–≤
- **–°–∏—Å—Ç–µ–º—ã –ø–∏—Ç–∞–Ω–∏—è** ‚Äî –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä—ã, —Ä–µ–≥—É–ª—è—Ç–æ—Ä—ã –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è

#### –¢–∏–ø–∏—á–Ω–∞—è —Å—Ö–µ–º–∞ –ø–∏—Ç–∞–Ω–∏—è:
```
–ê–∫–∫—É–º—É–ª—è—Ç–æ—Ä (7.4V) ‚Üí –†–µ–≥—É–ª—è—Ç–æ—Ä –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è ‚Üí 
‚Üí 5V –¥–ª—è –ª–æ–≥–∏–∫–∏ ‚Üí 3.3V –¥–ª—è –º–∏–∫—Ä–æ–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞
```

### 3. –ü—Ä–æ–≥—Ä–∞–º–º–Ω–∞—è —á–∞—Å—Ç—å

#### –£—Ä–æ–≤–Ω–∏ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è:
- **–ù–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ** ‚Äî —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–≥–∞—Ç–µ–ª—è–º–∏, —á—Ç–µ–Ω–∏–µ –¥–∞—Ç—á–∏–∫–æ–≤
- **–°—Ä–µ–¥–Ω–µ—É—Ä–æ–≤–Ω–µ–≤–æ–µ** ‚Äî –Ω–∞–≤–∏–≥–∞—Ü–∏—è, –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É—Ç–∏
- **–í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ** ‚Äî –ø—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏–π, –ò–ò

## –ü–ª–∞—Ç—Ñ–æ—Ä–º—ã –∏ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã

### –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –º–∏–∫—Ä–æ–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã:

#### Arduino (–Ω–∞—á–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å):
```cpp
// –ü—Ä–æ—Å—Ç–æ–π –ø—Ä–∏–º–µ—Ä —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–º
#include <Servo.h>

Servo myservo;
int pos = 0;

void setup() {
  myservo.attach(9);  // –°–µ—Ä–≤–æ –Ω–∞ –ø–∏–Ω–µ 9
}

void loop() {
  // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –æ—Ç 0 –¥–æ 180 –≥—Ä–∞–¥—É—Å–æ–≤
  for (pos = 0; pos <= 180; pos += 1) {
    myservo.write(pos);
    delay(15);
  }
  
  // –û–±—Ä–∞—Ç–Ω–æ –æ—Ç 180 –¥–æ 0
  for (pos = 180; pos >= 0; pos -= 1) {
    myservo.write(pos);
    delay(15);
  }
}
```

#### Raspberry Pi (–ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π —É—Ä–æ–≤–µ–Ω—å):
```python
# –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ GPIO –Ω–∞ Raspberry Pi
import RPi.GPIO as GPIO
import time

GPIO.setmode(GPIO.BCM)
GPIO.setup(18, GPIO.OUT)

try:
    while True:
        GPIO.output(18, GPIO.HIGH)  # –í–∫–ª—é—á–∏—Ç—å
        time.sleep(1)
        GPIO.output(18, GPIO.LOW)   # –í—ã–∫–ª—é—á–∏—Ç—å
        time.sleep(1)
except KeyboardInterrupt:
    GPIO.cleanup()
```

### –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã:

#### 1. ESP32:
- Wi-Fi –∏ Bluetooth –≤—Å—Ç—Ä–æ–µ–Ω—ã
- –î–≤–∞ —è–¥—Ä–∞ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∫–∞–º–µ—Ä—ã

```cpp
// ESP32 —Å Wi-Fi
#include <WiFi.h>

const char* ssid = "your_network";
const char* password = "your_password";

void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  
  Serial.println("Connected to WiFi");
  Serial.println(WiFi.localIP());
}
```

#### 2. NVIDIA Jetson Nano:
- GPU –¥–ª—è –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–≥–æ –∑—Ä–µ–Ω–∏—è
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ CUDA
- Linux –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π

```python
# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è OpenCV –Ω–∞ Jetson Nano
import cv2
import numpy as np

# –ó–∞—Ö–≤–∞—Ç –≤–∏–¥–µ–æ —Å –∫–∞–º–µ—Ä—ã
cap = cv2.VideoCapture(0)

while True:
    ret, frame = cap.read()
    
    # –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    edges = cv2.Canny(gray, 50, 150)
    
    cv2.imshow('Edges', edges)
    
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
```

## –î–∞—Ç—á–∏–∫–∏ –∏ –≤–æ—Å–ø—Ä–∏—è—Ç–∏–µ

### –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–∏–ø—ã –¥–∞—Ç—á–∏–∫–æ–≤:

#### 1. –î–∞—Ç—á–∏–∫–∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è:

##### –£–ª—å—Ç—Ä–∞–∑–≤—É–∫–æ–≤—ã–µ (HC-SR04):
```cpp
#define TRIG_PIN 9
#define ECHO_PIN 10

void setup() {
  Serial.begin(9600);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
}

void loop() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  
  long duration = pulseIn(ECHO_PIN, HIGH);
  float distance = duration * 0.034 / 2;
  
  Serial.print("Distance: ");
  Serial.print(distance);
  Serial.println(" cm");
  
  delay(100);
}
```

##### –ò–ö-–¥–∞—Ç—á–∏–∫–∏ (Sharp GP2Y0A21YK):
```python
# –ß—Ç–µ–Ω–∏–µ –∞–Ω–∞–ª–æ–≥–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —Å –ò–ö-–¥–∞—Ç—á–∏–∫–∞
import machine
import time

adc = machine.ADC(0)  # –ê–Ω–∞–ª–æ–≥–æ–≤—ã–π –ø–∏–Ω 0

def read_distance():
    raw_value = adc.read()
    # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ (–∫–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è)
    voltage = raw_value * 3.3 / 1024
    distance = 27.86 * pow(voltage, -1.15)  # –≠–º–ø–∏—Ä–∏—á–µ—Å–∫–∞—è —Ñ–æ—Ä–º—É–ª–∞
    return distance

while True:
    dist = read_distance()
    print(f"Distance: {dist:.2f} cm")
    time.sleep(0.5)
```

#### 2. –î–∞—Ç—á–∏–∫–∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏:

##### MPU6050 (–≥–∏—Ä–æ—Å–∫–æ–ø + –∞–∫—Å–µ–ª–µ—Ä–æ–º–µ—Ç—Ä):
```python
import smbus
import math
import time

# I2C –∞–¥—Ä–µ—Å MPU6050
MPU_ADDR = 0x68

bus = smbus.SMBus(1)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
bus.write_byte_data(MPU_ADDR, 0x6B, 0)

def read_word(reg):
    h = bus.read_byte_data(MPU_ADDR, reg)
    l = bus.read_byte_data(MPU_ADDR, reg+1)
    value = (h << 8) + l
    return value

def read_word_2c(reg):
    val = read_word(reg)
    if val >= 0x8000:
        return -((65535 - val) + 1)
    else:
        return val

def get_accel_data():
    accel_x = read_word_2c(0x3B) / 16384.0
    accel_y = read_word_2c(0x3D) / 16384.0
    accel_z = read_word_2c(0x3F) / 16384.0
    return accel_x, accel_y, accel_z

# –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
while True:
    ax, ay, az = get_accel_data()
    print(f"Accel: X={ax:.2f}, Y={ay:.2f}, Z={az:.2f}")
    time.sleep(0.1)
```

#### 3. –ö–∞–º–µ—Ä—ã:

##### Raspberry Pi Camera Module:
```python
from picamera import PiCamera
import time

camera = PiCamera()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞–º–µ—Ä—ã
camera.resolution = (640, 480)
camera.framerate = 30

# –ó–∞—Ö–≤–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
camera.start_preview()
time.sleep(2)
camera.capture('/home/pi/image.jpg')
camera.stop_preview()

# –í–∏–¥–µ–æ–∑–∞–ø–∏—Å—å
camera.start_recording('/home/pi/video.h264')
time.sleep(10)
camera.stop_recording()
```

### –°–µ–Ω—Å–æ—Ä–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã:

```python
# –ü—Ä–∏–º–µ—Ä –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö —Å –º–∞—Ç—Ä–∏—Ü—ã –¥–∞—Ç—á–∏–∫–æ–≤
class SensorArray:
    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols
        self.data = [[0 for _ in range(cols)] for _ in range(rows)]
    
    def update_sensor(self, row, col, value):
        self.data[row][col] = value
    
    def get_center_of_mass(self):
        """–ù–∞–π—Ç–∏ —Ü–µ–Ω—Ç—Ä –º–∞—Å—Å –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–ª–æ–∂–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞"""
        total_x, total_y, total_weight = 0, 0, 0
        
        for i in range(self.rows):
            for j in range(self.cols):
                weight = self.data[i][j]
                total_x += j * weight
                total_y += i * weight
                total_weight += weight
        
        if total_weight > 0:
            center_x = total_x / total_weight
            center_y = total_y / total_weight
            return center_x, center_y
        return None, None

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
sensor_array = SensorArray(8, 8)
# –°–∏–º—É–ª—è—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö —Å –¥–∞—Ç—á–∏–∫–æ–≤
for i in range(8):
    for j in range(8):
        sensor_array.update_sensor(i, j, i + j)

cx, cy = sensor_array.get_center_of_mass()
print(f"Center of mass: ({cx}, {cy})")
```

## –ê–∫—Ç—É–∞—Ç–æ—Ä—ã –∏ –ø—Ä–∏–≤–æ–¥—ã

### –¢–∏–ø—ã –ø—Ä–∏–≤–æ–¥–æ–≤:

#### 1. –°–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥—ã:

```cpp
#include <Servo.h>

Servo servo1, servo2;
int pos1 = 0, pos2 = 90;

void setup() {
  servo1.attach(9);
  servo2.attach(10);
  servo1.write(pos1);
  servo2.write(pos2);
}

void loop() {
  // –ö–æ–æ—Ä–¥–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –¥–≤—É—Ö —Å–µ—Ä–≤
  for (int i = 0; i <= 180; i++) {
    servo1.write(i);
    servo2.write(180 - i);
    delay(15);
  }
  
  delay(1000);
  
  for (int i = 180; i >= 0; i--) {
    servo1.write(i);
    servo2.write(180 - i);
    delay(15);
  }
  
  delay(1000);
}
```

#### 2. –®–∞–≥–æ–≤—ã–µ –¥–≤–∏–≥–∞—Ç–µ–ª–∏:

```python
# –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —à–∞–≥–æ–≤—ã–º –¥–≤–∏–≥–∞—Ç–µ–ª–µ–º —á–µ—Ä–µ–∑ A4988
import RPi.GPIO as GPIO
import time

# –ü–∏–Ω—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
STEP_PIN = 18
DIR_PIN = 23
ENABLE_PIN = 24

GPIO.setmode(GPIO.BCM)
GPIO.setup([STEP_PIN, DIR_PIN, ENABLE_PIN], GPIO.OUT)

def move_steps(steps, direction, delay=0.001):
    """–î–≤–∏–∂–µ–Ω–∏–µ –Ω–∞ –∑–∞–¥–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤"""
    GPIO.output(DIR_PIN, direction)  # 0 - –ø–æ —á–∞—Å–æ–≤–æ–π, 1 - –ø—Ä–æ—Ç–∏–≤
    GPIO.output(ENABLE_PIN, GPIO.LOW)  # –í–∫–ª—é—á–∏—Ç—å –¥–≤–∏–≥–∞—Ç–µ–ª—å
    
    for _ in range(steps):
        GPIO.output(STEP_PIN, GPIO.HIGH)
        time.sleep(delay)
        GPIO.output(STEP_PIN, GPIO.LOW)
        time.sleep(delay)
    
    GPIO.output(ENABLE_PIN, GPIO.HIGH)  # –í—ã–∫–ª—é—á–∏—Ç—å –¥–≤–∏–≥–∞—Ç–µ–ª—å

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
try:
    # 200 —à–∞–≥–æ–≤ –ø–æ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–µ
    move_steps(200, 0, 0.002)
    time.sleep(1)
    
    # 200 —à–∞–≥–æ–≤ –ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π
    move_steps(200, 1, 0.002)
    
finally:
    GPIO.cleanup()
```

#### 3. DC –¥–≤–∏–≥–∞—Ç–µ–ª–∏ —Å —ç–Ω–∫–æ–¥–µ—Ä–∞–º–∏:

```cpp
// PID —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–≥–∞—Ç–µ–ª–µ–º —Å —ç–Ω–∫–æ–¥–µ—Ä–æ–º
class MotorController {
private:
  int pwm_pin, dir_pin1, dir_pin2;
  volatile long encoder_count = 0;
  long target_position = 0;
  
  // PID –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã
  float Kp = 2.0, Ki = 0.5, Kd = 1.0;
  float integral = 0, last_error = 0;
  
public:
  MotorController(int pwm, int dir1, int dir2, int enc_a, int enc_b) 
    : pwm_pin(pwm), dir_pin1(dir1), dir_pin2(dir2) {
    
    pinMode(pwm_pin, OUTPUT);
    pinMode(dir_pin1, OUTPUT);
    pinMode(dir_pin2, OUTPUT);
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π –¥–ª—è —ç–Ω–∫–æ–¥–µ—Ä–∞
    attachInterrupt(digitalPinToInterrupt(enc_a), encoderISR, CHANGE);
    attachInterrupt(digitalPinToInterrupt(enc_b), encoderISR, CHANGE);
  }
  
  void setTarget(long position) {
    target_position = position;
  }
  
  void update() {
    long current_position = encoder_count;
    long error = target_position - current_position;
    
    // PID —Ä–∞—Å—á–µ—Ç
    integral += error * 0.01;
    float derivative = (error - last_error) / 0.01;
    
    float output = Kp * error + Ki * integral + Kd * derivative;
    last_error = error;
    
    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤—ã—Ö–æ–¥–∞
    output = constrain(output, -255, 255);
    
    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–≥–∞—Ç–µ–ª–µ–º
    if (output >= 0) {
      digitalWrite(dir_pin1, HIGH);
      digitalWrite(dir_pin2, LOW);
    } else {
      digitalWrite(dir_pin1, LOW);
      digitalWrite(dir_pin2, HIGH);
      output = -output;
    }
    
    analogWrite(pwm_pin, (int)output);
  }
  
  static void encoderISR() {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —ç–Ω–∫–æ–¥–µ—Ä–∞
    // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–∏–ø–∞ —ç–Ω–∫–æ–¥–µ—Ä–∞
  }
};
```

## –ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–æ–±–æ—Ç–æ–≤

### –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:

#### 1. –†–µ–∞–∫—Ç–∏–≤–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞:

```python
# –ü—Ä–æ—Å—Ç–æ–π —Ä–µ–∞–∫—Ç–∏–≤–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä
class ReactiveController:
    def __init__(self):
        self.rules = []
    
    def add_rule(self, condition, action):
        """–î–æ–±–∞–≤–∏—Ç—å –ø—Ä–∞–≤–∏–ª–æ: –µ—Å–ª–∏ —É—Å–ª–æ–≤–∏–µ, —Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ"""
        self.rules.append((condition, action))
    
    def update(self, sensors):
        """–û–±–Ω–æ–≤–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–µ–Ω—Å–æ—Ä–æ–≤"""
        for condition, action in self.rules:
            if condition(sensors):
                action()
                break

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–ª—è —Ä–æ–±–æ—Ç–∞-–ø—ã–ª–µ—Å–æ—Å–∞
controller = ReactiveController()

# –ü—Ä–∞–≤–∏–ª–∞ –ø–æ–≤–µ–¥–µ–Ω–∏—è
controller.add_rule(
    lambda sensors: sensors['obstacle_front'],  # –ï—Å–ª–∏ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ —Å–ø–µ—Ä–µ–¥–∏
    lambda: print("–ü–æ–≤–æ—Ä–æ—Ç –≤–ø—Ä–∞–≤–æ")  # –ü–æ–≤–µ—Ä–Ω—É—Ç—å –≤–ø—Ä–∞–≤–æ
)

controller.add_rule(
    lambda sensors: sensors['battery_low'],  # –ï—Å–ª–∏ –±–∞—Ç–∞—Ä–µ—è —Ä–∞–∑—Ä—è–∂–µ–Ω–∞
    lambda: print("–í–æ–∑–≤—Ä–∞—Ç –Ω–∞ –±–∞–∑—É")  # –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –∑–∞—Ä—è–¥–∫—É
)

# –°–∏–º—É–ª—è—Ü–∏—è —Å–µ–Ω—Å–æ—Ä–æ–≤
sensors_data = {
    'obstacle_front': True,
    'battery_low': False,
    'dirt_detected': False
}

controller.update(sensors_data)
```

#### 2. FSM (Finite State Machine):

```python
# –ö–æ–Ω–µ—á–Ω—ã–π –∞–≤—Ç–æ–º–∞—Ç –¥–ª—è —Ä–æ–±–æ—Ç–∞
class RobotFSM:
    def __init__(self):
        self.state = 'IDLE'
        self.states = {
            'IDLE': self.idle_state,
            'MOVING': self.moving_state,
            'AVOIDING': self.avoiding_state,
            'CHARGING': self.charging_state
        }
    
    def idle_state(self, sensors):
        if sensors['start_button']:
            return 'MOVING'
        elif sensors['low_battery']:
            return 'CHARGING'
        return 'IDLE'
    
    def moving_state(self, sensors):
        if sensors['obstacle_detected']:
            return 'AVOIDING'
        elif sensors['task_completed']:
            return 'IDLE'
        elif sensors['low_battery']:
            return 'CHARGING'
        return 'MOVING'
    
    def avoiding_state(self, sensors):
        if not sensors['obstacle_detected']:
            return 'MOVING'
        return 'AVOIDING'
    
    def charging_state(self, sensors):
        if sensors['battery_full']:
            return 'IDLE'
        return 'CHARGING'
    
    def update(self, sensors):
        next_state = self.states[self.state](sensors)
        if next_state != self.state:
            print(f"State transition: {self.state} -> {next_state}")
            self.state = next_state

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
robot = RobotFSM()
sensor_data = {
    'start_button': True,
    'obstacle_detected': False,
    'low_battery': False,
    'task_completed': False,
    'battery_full': False
}

robot.update(sensor_data)  # IDLE -> MOVING
```

#### 3. Behavior Trees:

```python
# –î–µ—Ä–µ–≤–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è
class BehaviorNode:
    def execute(self, blackboard):
        raise NotImplementedError

class Sequence(BehaviorNode):
    def __init__(self, children):
        self.children = children
    
    def execute(self, blackboard):
        for child in self.children:
            if not child.execute(blackboard):
                return False
        return True

class Selector(BehaviorNode):
    def __init__(self, children):
        self.children = children
    
    def execute(self, blackboard):
        for child in self.children:
            if child.execute(blackboard):
                return True
        return False

class Condition(BehaviorNode):
    def __init__(self, condition_func):
        self.condition_func = condition_func
    
    def execute(self, blackboard):
        return self.condition_func(blackboard)

class Action(BehaviorNode):
    def __init__(self, action_func):
        self.action_func = action_func
    
    def execute(self, blackboard):
        return self.action_func(blackboard)

# –ü—Ä–∏–º–µ—Ä –¥–µ—Ä–µ–≤–∞ –¥–ª—è —Ä–æ–±–æ—Ç–∞-–∫—É—Ä—å–µ—Ä–∞
def battery_ok(blackboard):
    return blackboard['battery'] > 20

def has_package(blackboard):
    return blackboard['package_delivered'] == False

def navigate_to_customer(blackboard):
    print("–ù–∞–≤–∏–≥–∞—Ü–∏—è –∫ –∫–ª–∏–µ–Ω—Ç—É...")
    blackboard['navigation_complete'] = True
    return True

def deliver_package(blackboard):
    print("–î–æ—Å—Ç–∞–≤–∫–∞ –ø–æ—Å—ã–ª–∫–∏...")
    blackboard['package_delivered'] = True
    return True

def return_to_base(blackboard):
    print("–í–æ–∑–≤—Ä–∞—Ç –Ω–∞ –±–∞–∑—É...")
    blackboard['at_base'] = True
    return True

# –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞
behavior_tree = Selector([
    Sequence([
        Condition(battery_ok),
        Condition(has_package),
        Action(navigate_to_customer),
        Action(deliver_package)
    ]),
    Action(return_to_base)
])

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
blackboard = {
    'battery': 85,
    'package_delivered': False,
    'navigation_complete': False,
    'at_base': False
}

success = behavior_tree.execute(blackboard)
print(f"Behavior tree result: {success}")
```

## –ö–∏–Ω–µ–º–∞—Ç–∏–∫–∞ –∏ –¥–≤–∏–∂–µ–Ω–∏–µ

### –ü—Ä—è–º–∞—è –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∞:

```python
import numpy as np
import math

class RobotArmKinematics:
    def __init__(self, link_lengths):
        """
        link_lengths: —Å–ø–∏—Å–æ–∫ –¥–ª–∏–Ω –∑–≤–µ–Ω—å–µ–≤ [l1, l2, l3, ...]
        """
        self.link_lengths = link_lengths
        self.num_joints = len(link_lengths)
    
    def forward_kinematics(self, joint_angles):
        """
        –ü—Ä—è–º–∞—è –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∞: —É–≥–ª—ã -> –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        joint_angles: —Å–ø–∏—Å–æ–∫ —É–≥–ª–æ–≤ –≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö
        """
        x, y = 0, 0
        
        for i in range(len(joint_angles)):
            # –ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
            angle_sum = sum(joint_angles[:i+1])
            x += self.link_lengths[i] * math.cos(angle_sum)
            y += self.link_lengths[i] * math.sin(angle_sum)
        
        return x, y
    
    def jacobian(self, joint_angles):
        """
        –Ø–∫–æ–±–∏–∞–Ω –¥–ª—è –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∏
        """
        n = len(joint_angles)
        J = np.zeros((2, n))
        
        for i in range(n):
            # –í—ã—á–∏—Å–ª—è–µ–º –≤–ª–∏—è–Ω–∏–µ i-–≥–æ —Å—É—Å—Ç–∞–≤–∞
            angle_sum = sum(joint_angles[:i+1])
            
            for j in range(i, n):
                J[0, j] -= self.link_lengths[j] * math.sin(angle_sum)
                J[1, j] += self.link_lengths[j] * math.cos(angle_sum)
        
        return J

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
arm = RobotArmKinematics([100, 80, 60])  # –º–º

# –ü—Ä—è–º–∞—è –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∞
angles = [math.pi/4, math.pi/6, -math.pi/8]  # —Ä–∞–¥–∏–∞–Ω—ã
x, y = arm.forward_kinematics(angles)
print(f"–ö–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞: ({x:.2f}, {y:.2f}) –º–º")

# –Ø–∫–æ–±–∏–∞–Ω
J = arm.jacobian(angles)
print("–Ø–∫–æ–±–∏–∞–Ω:")
print(J)
```

### –û–±—Ä–∞—Ç–Ω–∞—è –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∞:

```python
class InverseKinematics:
    def __init__(self, link_lengths):
        self.link_lengths = link_lengths
    
    def inverse_kinematics_2dof(self, target_x, target_y):
        """
        –û–±—Ä–∞—Ç–Ω–∞—è –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∞ –¥–ª—è 2-DOF –º–∞–Ω–∏–ø—É–ª—è—Ç–æ—Ä–∞
        """
        l1, l2 = self.link_lengths[0], self.link_lengths[1]
        
        # –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–ª–∏
        d = math.sqrt(target_x**2 + target_y**2)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–∏–º–æ—Å—Ç–∏
        if d > l1 + l2:
            print("–¶–µ–ª—å –Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º–∞")
            return None
        
        if d < abs(l1 - l2):
            print("–¶–µ–ª—å —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ")
            return None
        
        # –£–≥–æ–ª –≤—Ç–æ—Ä–æ–≥–æ —Å—É—Å—Ç–∞–≤–∞ (–ª–æ–∫–æ—Ç—å)
        cos_theta2 = (target_x**2 + target_y**2 - l1**2 - l2**2) / (2 * l1 * l2)
        theta2 = math.acos(max(-1, min(1, cos_theta2)))  # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ [-1, 1]
        
        # –£–≥–æ–ª –ø–µ—Ä–≤–æ–≥–æ —Å—É—Å—Ç–∞–≤–∞
        k1 = l1 + l2 * math.cos(theta2)
        k2 = l2 * math.sin(theta2)
        theta1 = math.atan2(target_y, target_x) - math.atan2(k2, k1)
        
        return [theta1, theta2]
    
    def iterative_ik(self, target_pos, initial_guess, max_iterations=100, tolerance=0.1):
        """
        –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–π –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∏
        """
        angles = initial_guess.copy()
        kinematics = RobotArmKinematics(self.link_lengths)
        
        for i in range(max_iterations):
            # –ü—Ä—è–º–∞—è –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∞
            current_pos = kinematics.forward_kinematics(angles)
            
            # –û—à–∏–±–∫–∞ –ø–æ–∑–∏—Ü–∏–∏
            error_x = target_pos[0] - current_pos[0]
            error_y = target_pos[1] - current_pos[1]
            error = math.sqrt(error_x**2 + error_y**2)
            
            if error < tolerance:
                return angles
            
            # –Ø–∫–æ–±–∏–∞–Ω
            J = kinematics.jacobian(angles)
            
            # –ü—Å–µ–≤–¥–æ–æ–±—Ä–∞—Ç–Ω—ã–π —è–∫–æ–±–∏–∞–Ω
            try:
                J_pseudo = np.linalg.pinv(J)
                delta_angles = J_pseudo.dot([error_x, error_y])
                
                # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É–≥–ª–æ–≤
                for j in range(len(angles)):
                    angles[j] += delta_angles[j] * 0.1  # –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –æ–±—É—á–µ–Ω–∏—è
                    
            except np.linalg.LinAlgError:
                print("–°–∏–Ω–≥—É–ª—è—Ä–Ω–æ—Å—Ç—å —è–∫–æ–±–∏–∞–Ω–∞")
                break
        
        return angles

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
ik_solver = InverseKinematics([100, 80])

# –ê–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è 2-DOF
target = [120, 60]
angles = ik_solver.inverse_kinematics_2dof(target[0], target[1])
if angles:
    print(f"–£–≥–ª—ã: {[math.degrees(a) for a in angles]}¬∞")

# –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è 3-DOF
ik_solver_3dof = InverseKinematics([100, 80, 60])
initial_guess = [0.1, 0.1, 0.1]
result_angles = ik_solver_3dof.iterative_ik([120, 60], initial_guess)
print(f"–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ: {[math.degrees(a) for a in result_angles]}¬∞")
```

### –¢—Ä–∞–µ–∫—Ç–æ—Ä–Ω–æ–µ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ:

```python
class TrajectoryPlanner:
    def __init__(self):
        pass
    
    def linear_interpolation(self, start_pos, end_pos, steps):
        """–õ–∏–Ω–µ–π–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è"""
        trajectory = []
        for i in range(steps + 1):
            t = i / steps
            x = start_pos[0] + t * (end_pos[0] - start_pos[0])
            y = start_pos[1] + t * (end_pos[1] - start_pos[1])
            trajectory.append([x, y])
        return trajectory
    
    def cubic_spline(self, waypoints, num_points=100):
        """–ö—É–±–∏—á–µ—Å–∫–∏–π —Å–ø–ª–∞–π–Ω —á–µ—Ä–µ–∑ waypoints"""
        import scipy.interpolate as spi
        
        x_coords = [wp[0] for wp in waypoints]
        y_coords = [wp[1] for wp in waypoints]
        
        # –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–∞—Ü–∏—è
        t = np.linspace(0, 1, len(waypoints))
        
        # –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è
        fx = spi.interp1d(t, x_coords, kind='cubic')
        fy = spi.interp1d(t, y_coords, kind='cubic')
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–æ—á–µ–∫
        t_new = np.linspace(0, 1, num_points)
        x_new = fx(t_new)
        y_new = fy(t_new)
        
        return list(zip(x_new, y_new))
    
    def trapezoidal_velocity(self, start_pos, end_pos, max_vel, accel, dt=0.01):
        """–¢—Ä–∞–ø–µ—Ü–µ–∏–¥–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å —Å–∫–æ—Ä–æ—Å—Ç–∏"""
        distance = math.sqrt((end_pos[0]-start_pos[0])**2 + (end_pos[1]-start_pos[1])**2)
        
        # –í—Ä–µ–º—è —Ä–∞–∑–≥–æ–Ω–∞/—Ç–æ—Ä–º–æ–∂–µ–Ω–∏—è
        t_accel = max_vel / accel
        distance_accel = 0.5 * accel * t_accel**2
        
        if 2 * distance_accel > distance:
            # –¢—Ä–µ—É–≥–æ–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å (–±–µ–∑ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏)
            t_accel = math.sqrt(distance / accel)
            max_vel = accel * t_accel
            t_const = 0
        else:
            # –¢—Ä–∞–ø–µ—Ü–µ–∏–¥–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å
            distance_const = distance - 2 * distance_accel
            t_const = distance_const / max_vel
        
        total_time = 2 * t_accel + t_const
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
        trajectory = []
        current_time = 0
        current_pos = list(start_pos)
        
        direction = [(end_pos[i] - start_pos[i])/distance for i in range(2)]
        
        while current_time <= total_time:
            if current_time <= t_accel:
                # –†–∞–∑–≥–æ–Ω
                vel = accel * current_time
            elif current_time <= t_accel + t_const:
                # –ü–æ—Å—Ç–æ—è–Ω–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                vel = max_vel
            else:
                # –¢–æ—Ä–º–æ–∂–µ–Ω–∏–µ
                t_decel = current_time - (t_accel + t_const)
                vel = max_vel - accel * t_decel
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
            for i in range(2):
                current_pos[i] += vel * direction[i] * dt
            
            trajectory.append(current_pos.copy())
            current_time += dt
        
        return trajectory

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
planner = TrajectoryPlanner()

# –õ–∏–Ω–µ–π–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è
linear_path = planner.linear_interpolation([0, 0], [100, 50], 10)
print("–õ–∏–Ω–µ–π–Ω–∞—è —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—è:", linear_path)

# –¢—Ä–∞–ø–µ—Ü–µ–∏–¥–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
traj = planner.trapezoidal_velocity([0, 0], [200, 100], 50, 10)
print(f"–¢–æ—á–µ–∫ –≤ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏: {len(traj)}")
```

## –ö–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–µ –∑—Ä–µ–Ω–∏–µ

### –û—Å–Ω–æ–≤—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π:

```python
import cv2
import numpy as np

class VisionProcessor:
    def __init__(self):
        self.camera = cv2.VideoCapture(0)
    
    def capture_frame(self):
        """–ó–∞—Ö–≤–∞—Ç –∫–∞–¥—Ä–∞ —Å –∫–∞–º–µ—Ä—ã"""
        ret, frame = self.camera.read()
        return frame if ret else None
    
    def color_filter(self, frame, lower_color, upper_color):
        """–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ü–≤–µ—Ç—É –≤ HSV"""
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        mask = cv2.inRange(hsv, lower_color, upper_color)
        return cv2.bitwise_and(frame, frame, mask=mask)
    
    def find_contours(self, binary_image):
        """–ü–æ–∏—Å–∫ –∫–æ–Ω—Ç—É—Ä–æ–≤"""
        contours, _ = cv2.findContours(binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        return contours
    
    def detect_objects(self, frame):
        """–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –ø–æ —Ü–≤–µ—Ç—É"""
        # –î–∏–∞–ø–∞–∑–æ–Ω—ã —Ü–≤–µ—Ç–æ–≤ –≤ HSV
        color_ranges = {
            'red': ([0, 100, 100], [10, 255, 255]),
            'green': ([40, 100, 100], [80, 255, 255]),
            'blue': ([100, 100, 100], [130, 255, 255])
        }
        
        objects = []
        
        for color_name, (lower, upper) in color_ranges.items():
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ü–≤–µ—Ç—É
            filtered = self.color_filter(frame, np.array(lower), np.array(upper))
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ –±–∏–Ω–∞—Ä–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            gray = cv2.cvtColor(filtered, cv2.COLOR_BGR2GRAY)
            _, binary = cv2.threshold(gray, 1, 255, cv2.THRESH_BINARY)
            
            # –ü–æ–∏—Å–∫ –∫–æ–Ω—Ç—É—Ä–æ–≤
            contours = self.find_contours(binary)
            
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –ø–ª–æ—â–∞–¥–∏
            for contour in contours:
                area = cv2.contourArea(contour)
                if area > 500:  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø–ª–æ—â–∞–¥—å
                    x, y, w, h = cv2.boundingRect(contour)
                    objects.append({
                        'color': color_name,
                        'position': (x + w//2, y + h//2),
                        'size': (w, h),
                        'area': area
                    })
        
        return objects

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
vision = VisionProcessor()

# –ó–∞—Ö–≤–∞—Ç –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–¥—Ä–∞
frame = vision.capture_frame()
if frame is not None:
    objects = vision.detect_objects(frame)
    print(f"–ù–∞–π–¥–µ–Ω–æ –æ–±—ä–µ–∫—Ç–æ–≤: {len(objects)}")
    
    for obj in objects:
        print(f"{obj['color']} –æ–±—ä–µ–∫—Ç –≤ –ø–æ–∑–∏—Ü–∏–∏ {obj['position']}")
```

### SLAM (Simultaneous Localization and Mapping):

```python
class SimpleSLAM:
    def __init__(self):
        self.map_features = []  # –ö–∞—Ä—Ç–∞ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π
        self.robot_pose = [0, 0, 0]  # x, y, —É–≥–æ–ª
        self.feature_detector = cv2.SIFT_create()
    
    def extract_features(self, image):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Ç–æ—á–µ–∫"""
        keypoints, descriptors = self.feature_detector.detectAndCompute(image, None)
        return keypoints, descriptors
    
    def match_features(self, desc1, desc2):
        """–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π"""
        if desc1 is None or desc2 is None:
            return []
        
        bf = cv2.BFMatcher()
        matches = bf.knnMatch(desc1, desc2, k=2)
        
        # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Ö–æ—Ä–æ—à–∏—Ö —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
        good_matches = []
        for m, n in matches:
            if m.distance < 0.75 * n.distance:
                good_matches.append(m)
        
        return good_matches
    
    def triangulate_position(self, matches, kp1, kp2, camera_matrix):
        """–¢—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏—è –ø–æ–ª–æ–∂–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π"""
        if len(matches) < 8:
            return None
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö —Ç–æ—á–µ–∫
        pts1 = np.float32([kp1[m.queryIdx].pt for m in matches])
        pts2 = np.float32([kp2[m.trainIdx].pt for m in matches])
        
        # –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ–∑—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º PnP
        success, rvec, tvec = cv2.solvePnP(
            self.map_features, pts2, camera_matrix, None
        )
        
        if success:
            return tvec.flatten(), rvec.flatten()
        return None
    
    def update_map(self, image, camera_matrix):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã –∏ –ø–æ–∑–∏—Ü–∏–∏ —Ä–æ–±–æ—Ç–∞"""
        keypoints, descriptors = self.extract_features(image)
        
        if not self.map_features:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã
            self.map_features = np.float32([kp.pt for kp in keypoints[:50]])
            return self.robot_pose
        
        # –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∫–∞—Ä—Ç–æ–π
        map_descriptors = self.get_map_descriptors()  # –ü—Å–µ–≤–¥–æ-–º–µ—Ç–æ–¥
        matches = self.match_features(map_descriptors, descriptors)
        
        # –¢—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏—è –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
        position = self.triangulate_position(
            matches, self.map_features, keypoints, camera_matrix
        )
        
        if position is not None:
            self.robot_pose = [position[0][0], position[0][1], position[1][2]]
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã –Ω–æ–≤—ã–º–∏ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—è–º–∏
        new_features = [kp for i, kp in enumerate(keypoints) 
                       if i not in [m.trainIdx for m in matches]]
        
        if len(new_features) > 10:
            self.map_features = np.vstack([
                self.map_features,
                np.float32([kp.pt for kp in new_features[:20]])
            ])
        
        return self.robot_pose

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
slam = SimpleSLAM()
camera_matrix = np.array([[500, 0, 320], [0, 500, 240], [0, 0, 1]])

# –°–∏–º—É–ª—è—Ü–∏—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
for i in range(10):
    # –ó–∞—Ö–≤–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (—Å–∏–º—É–ª—è—Ü–∏—è)
    image = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
    
    pose = slam.update_map(image, camera_matrix)
    print(f"–®–∞–≥ {i}: –ü–æ–∑–∏—Ü–∏—è —Ä–æ–±–æ—Ç–∞ {pose}")
```

## –ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç –≤ —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–µ

### –ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –¥–ª—è —Ä–æ–±–æ—Ç–æ–≤:

```python
import tensorflow as tf
from tensorflow import keras
import numpy as np

class RobotLearning:
    def __init__(self):
        self.model = None
    
    def create_navigation_model(self, input_size=10, hidden_size=64):
        """–ù–µ–π—Ä–æ–Ω–Ω–∞—è —Å–µ—Ç—å –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏"""
        model = keras.Sequential([
            keras.layers.Dense(hidden_size, activation='relu', input_shape=(input_size,)),
            keras.layers.Dense(hidden_size, activation='relu'),
            keras.layers.Dense(3, activation='softmax')  # left, straight, right
        ])
        
        model.compile(
            optimizer='adam',
            loss='categorical_crossentropy',
            metrics=['accuracy']
        )
        
        self.model = model
        return model
    
    def simulate_training_data(self, samples=1000):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è"""
        # –°–µ–Ω—Å–æ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: [front_dist, left_dist, right_dist, 
        #                   front_left, front_right, speed, ...]
        X = np.random.rand(samples, 10) * 100  # 10 —Å–µ–Ω—Å–æ—Ä–æ–≤
        
        # –ú–µ—Ç–∫–∏: 0-left, 1-straight, 2-right
        y = []
        for sample in X:
            front = sample[0]
            left = sample[1]
            right = sample[2]
            
            if front < 20:  # –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ —Å–ø–µ—Ä–µ–¥–∏
                if left > right:
                    action = 0  # –ü–æ–≤–æ—Ä–æ—Ç –≤–ª–µ–≤–æ
                else:
                    action = 2  # –ü–æ–≤–æ—Ä–æ—Ç –≤–ø—Ä–∞–≤–æ
            else:
                action = 1  # –ü—Ä—è–º–æ
        
            y.append(action)
        
        y = keras.utils.to_categorical(y, 3)
        return X, y
    
    def train_navigation_model(self, epochs=50):
        """–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏"""
        if self.model is None:
            self.create_navigation_model()
        
        X_train, y_train = self.simulate_training_data()
        
        history = self.model.fit(
            X_train, y_train,
            epochs=epochs,
            validation_split=0.2,
            verbose=1
        )
        
        return history
    
    def predict_action(self, sensor_data):
        """–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–µ–Ω—Å–æ—Ä–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        if self.model is None:
            return 1  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é - –ø—Ä—è–º–æ
        
        prediction = self.model.predict(np.array([sensor_data]), verbose=0)
        action = np.argmax(prediction[0])
        
        actions = ['turn_left', 'go_straight', 'turn_right']
        return actions[action]

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
learning_robot = RobotLearning()
learning_robot.create_navigation_model()

# –û–±—É—á–µ–Ω–∏–µ
print("–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏...")
history = learning_robot.train_navigation_model(epochs=20)

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–±—É—á–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏
test_sensors = [15, 50, 80, 30, 40, 5, 10, 25, 35, 45]
action = learning_robot.predict_action(test_sensors)
print(f"–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ: {action}")
```

### Reinforcement Learning –¥–ª—è —Ä–æ–±–æ—Ç–æ–≤:

```python
import random
import numpy as np

class QLearningRobot:
    def __init__(self, state_size=8, action_size=4):
        self.state_size = state_size
        self.action_size = action_size
        self.q_table = {}
        self.learning_rate = 0.1
        self.discount_factor = 0.95
        self.epsilon = 1.0
        self.epsilon_decay = 0.995
        self.epsilon_min = 0.01
    
    def discretize_state(self, continuous_state):
        """–î–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏—è –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        # –ü—Ä–∏–º–µ—Ä: –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π —Å–µ–Ω—Å–æ—Ä–æ–≤
        discrete = tuple([round(s, 1) for s in continuous_state])
        return discrete
    
    def get_q_value(self, state, action):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ Q-–∑–Ω–∞—á–µ–Ω–∏—è"""
        state_key = str(state)
        if state_key not in self.q_table:
            self.q_table[state_key] = np.zeros(self.action_size)
        return self.q_table[state_key][action]
    
    def update_q_value(self, state, action, reward, next_state, done):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Q-–∑–Ω–∞—á–µ–Ω–∏—è"""
        state_key = str(state)
        next_state_key = str(next_state)
        
        if state_key not in self.q_table:
            self.q_table[state_key] = np.zeros(self.action_size)
        
        if next_state_key not in self.q_table:
            self.q_table[next_state_key] = np.zeros(self.action_size)
        
        current_q = self.q_table[state_key][action]
        
        if done:
            target = reward
        else:
            max_next_q = np.max(self.q_table[next_state_key])
            target = reward + self.discount_factor * max_next_q
        
        # Q-learning –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
        self.q_table[state_key][action] = current_q + self.learning_rate * (target - current_q)
    
    def choose_action(self, state):
        """–í—ã–±–æ—Ä –¥–µ–π—Å—Ç–≤–∏—è –ø–æ Œµ-–∂–∞–¥–Ω–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏"""
        if random.random() < self.epsilon:
            return random.randint(0, self.action_size - 1)
        else:
            state_key = str(state)
            if state_key not in self.q_table:
                self.q_table[state_key] = np.zeros(self.action_size)
            return np.argmax(self.q_table[state_key])
    
    def decay_epsilon(self):
        """–£–º–µ–Ω—å—à–µ–Ω–∏–µ Œµ"""
        if self.epsilon > self.epsilon_min:
            self.epsilon *= self.epsilon_decay

# –°–∏–º—É–ª—è—Ü–∏—è –æ–±—É—á–µ–Ω–∏—è —Ä–æ–±–æ—Ç–∞-–ø—ã–ª–µ—Å–æ—Å–∞
class VacuumEnvironment:
    def __init__(self):
        self.grid_size = 5
        self.dirty_spots = set()
        self.robot_pos = [0, 0]
        self.steps = 0
        self.max_steps = 100
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä—è–∑–∏
        for _ in range(5):
            x, y = random.randint(0, 4), random.randint(0, 4)
            self.dirty_spots.add((x, y))
    
    def get_state(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å—Ä–µ–¥—ã"""
        # –°–æ—Å—Ç–æ—è–Ω–∏–µ: [x, y, dirty_left, dirty_right, dirty_front, dirty_back, battery, dirt_count]
        x, y = self.robot_pos
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –≥—Ä—è–∑–∏ –≤ —Å–æ—Å–µ–¥–Ω–∏—Ö –∫–ª–µ—Ç–∫–∞—Ö
        left_dirty = 1 if (x-1, y) in self.dirty_spots else 0
        right_dirty = 1 if (x+1, y) in self.dirty_spots else 0
        front_dirty = 1 if (x, y+1) in self.dirty_spots else 0
        back_dirty = 1 if (x, y-1) in self.dirty_spots else 0
        
        battery = max(0, 100 - self.steps)  # –ü—Ä–æ—Å—Ç–∞—è –º–æ–¥–µ–ª—å –±–∞—Ç–∞—Ä–µ–∏
        dirt_count = len(self.dirty_spots)
        
        return [x/4, y/4, left_dirty, right_dirty, front_dirty, back_dirty, battery/100, dirt_count/5]
    
    def step(self, action):
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è"""
        self.steps += 1
        
        # –î–µ–π—Å—Ç–≤–∏—è: 0-–≤–ª–µ–≤–æ, 1-–≤–ø—Ä–∞–≤–æ, 2-–≤–ø–µ—Ä–µ–¥, 3-—É–±–æ—Ä–∫–∞
        x, y = self.robot_pos
        
        if action == 0 and x > 0:
            self.robot_pos[0] -= 1
        elif action == 1 and x < 4:
            self.robot_pos[0] += 1
        elif action == 2 and y < 4:
            self.robot_pos[1] += 1
        elif action == 3:
            # –£–±–æ—Ä–∫–∞ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏
            pos_tuple = tuple(self.robot_pos)
            if pos_tuple in self.dirty_spots:
                self.dirty_spots.remove(pos_tuple)
        
        # –ù–∞–≥—Ä–∞–¥–∞
        reward = 0
        if action == 3:
            pos_tuple = tuple(self.robot_pos)
            if pos_tuple not in self.dirty_spots:  # –£–±—Ä–∞–ª –≥—Ä—è–∑—å
                reward = 10
            else:
                reward = -1  # –ü–æ—Ç—Ä–∞—Ç–∏–ª —ç–Ω–µ—Ä–≥–∏—é –∑—Ä—è
        
        # –®—Ç—Ä–∞—Ñ –∑–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å–æ —Å—Ç–µ–Ω–æ–π
        if (action in [0,1,2] and 
            (self.robot_pos[0] < 0 or self.robot_pos[0] > 4 or 
             self.robot_pos[1] < 0 or self.robot_pos[1] > 4)):
            reward = -5
            # –í–µ—Ä–Ω—É—Ç—å —Ä–æ–±–æ—Ç–∞ –æ–±—Ä–∞—Ç–Ω–æ
            self.robot_pos = [x, y]
        
        # –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —ç–ø–∏–∑–æ–¥–∞
        done = len(self.dirty_spots) == 0 or self.steps >= self.max_steps
        
        return self.get_state(), reward, done

# –û–±—É—á–µ–Ω–∏–µ
robot = QLearningRobot(state_size=8, action_size=4)
environment = VacuumEnvironment()

episodes = 500
scores = []

for episode in range(episodes):
    environment = VacuumEnvironment()
    state = environment.get_state()
    total_reward = 0
    
    while True:
        action = robot.choose_action(state)
        next_state, reward, done = environment.step(action)
        
        robot.update_q_value(state, action, reward, next_state, done)
        total_reward += reward
        
        state = next_state
        
        if done:
            break
    
    robot.decay_epsilon()
    scores.append(total_reward)
    
    if episode % 50 == 0:
        avg_score = np.mean(scores[-50:])
        print(f"–≠–ø–∏–∑–æ–¥ {episode}, –°—Ä–µ–¥–Ω–∏–π —Å—á–µ—Ç: {avg_score:.2f}, Œµ: {robot.epsilon:.3f}")

print("–û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!")
```

## –°–∏—Å—Ç–µ–º—ã –Ω–∞–≤–∏–≥–∞—Ü–∏–∏

### –ê–ª–≥–æ—Ä–∏—Ç–º—ã –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø—É—Ç–∏:

```python
import heapq
import math

class PathPlanner:
    def __init__(self, grid_size=20):
        self.grid_size = grid_size
        self.obstacles = set()
    
    def add_obstacle(self, x, y):
        """–î–æ–±–∞–≤–∏—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ"""
        self.obstacles.add((x, y))
    
    def heuristic(self, a, b):
        """–≠–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∞—è —Ñ—É–Ω–∫—Ü–∏—è (–º–∞–Ω—Ö—ç—Ç—Ç–µ–Ω—Å–∫–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ)"""
        return abs(a[0] - b[0]) + abs(a[1] - b[1])
    
    def get_neighbors(self, node):
        """–ü–æ–ª—É—á–∏—Ç—å —Å–æ—Å–µ–¥–Ω–∏–µ —É–∑–ª—ã"""
        x, y = node
        neighbors = []
        
        # 8 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π –¥–≤–∏–∂–µ–Ω–∏—è
        for dx, dy in [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]:
            nx, ny = x + dx, y + dy
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü
            if 0 <= nx < self.grid_size and 0 <= ny < self.grid_size:
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
                if (nx, ny) not in self.obstacles:
                    neighbors.append((nx, ny))
        
        return neighbors
    
    def a_star(self, start, goal):
        """–ê–ª–≥–æ—Ä–∏—Ç–º A*"""
        open_set = [(0, start)]
        came_from = {}
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, goal)}
        
        while open_set:
            current = heapq.heappop(open_set)[1]
            
            if current == goal:
                # –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É—Ç–∏
                path = []
                while current in came_from:
                    path.append(current)
                    current = came_from[current]
                path.append(start)
                return path[::-1]
            
            for neighbor in self.get_neighbors(current):
                tentative_g = g_score[current] + self.distance(current, neighbor)
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + self.heuristic(neighbor, goal)
                    
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
        
        return None  # –ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω
    
    def distance(self, a, b):
        """–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏"""
        dx = abs(a[0] - b[0])
        dy = abs(a[1] - b[1])
        
        # –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
        if dx == dy:
            return dx * math.sqrt(2)
        else:
            return dx + dy
    
    def dynamic_window_approach(self, current_pos, goal, obstacles, max_speed=1.0):
        """
        Dynamic Window Approach –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
        """
        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
        max_accel = 0.5
        robot_radius = 0.3
        
        # –í–æ–∑–º–æ–∂–Ω—ã–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
        v_samples = []
        for v in np.linspace(-max_speed, max_speed, 20):
            for w in np.linspace(-1.0, 1.0, 20):  # –£–≥–ª–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                v_samples.append((v, w))
        
        best_traj = None
        best_score = -float('inf')
        
        for v, w in v_samples:
            # –°–∏–º—É–ª—è—Ü–∏—è —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —à–∞–≥–æ–≤ –≤–ø–µ—Ä–µ–¥
            traj = self.simulate_trajectory(current_pos, v, w, dt=0.1, steps=10)
            
            # –û—Ü–µ–Ω–∫–∞ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
            heading_score = self.heading_evaluation(traj[-1], goal)
            distance_score = self.distance_evaluation(traj[-1], goal)
            obstacle_score = self.obstacle_evaluation(traj, obstacles, robot_radius)
            
            # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
            total_score = 0.3 * heading_score + 0.4 * distance_score + 0.3 * obstacle_score
            
            if total_score > best_score:
                best_score = total_score
                best_traj = traj
        
        return best_traj
    
    def simulate_trajectory(self, start_pos, v, w, dt, steps):
        """–°–∏–º—É–ª—è—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è —Ä–æ–±–æ—Ç–∞"""
        x, y, theta = start_pos
        trajectory = [(x, y, theta)]
        
        for _ in range(steps):
            x += v * math.cos(theta) * dt
            y += v * math.sin(theta) * dt
            theta += w * dt
            
            trajectory.append((x, y, theta))
        
        return trajectory
    
    def heading_evaluation(self, final_pose, goal):
        """–û—Ü–µ–Ω–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è"""
        dx = goal[0] - final_pose[0]
        dy = goal[1] - final_pose[1]
        target_angle = math.atan2(dy, dx)
        
        angle_diff = abs(target_angle - final_pose[2])
        return 1.0 - angle_diff / math.pi
    
    def distance_evaluation(self, final_pose, goal):
        """–û—Ü–µ–Ω–∫–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ —Ü–µ–ª–∏"""
        dist = math.sqrt((goal[0] - final_pose[0])**2 + (goal[1] - final_pose[1])**2)
        return 1.0 / (1.0 + dist)
    
    def obstacle_evaluation(self, trajectory, obstacles, robot_radius):
        """–û—Ü–µ–Ω–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π"""
        min_distance = float('inf')
        
        for point in trajectory:
            x, y = point[0], point[1]
            for obs_x, obs_y in obstacles:
                dist = math.sqrt((x - obs_x)**2 + (y - obs_y)**2)
                min_distance = min(min_distance, dist)
        
        if min_distance < robot_radius:
            return 0.0
        else:
            return min(1.0, min_distance / (2 * robot_radius))

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
planner = PathPlanner(grid_size=15)

# –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
for i in range(3, 8):
    planner.add_obstacle(5, i)
    planner.add_obstacle(i, 5)

# –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É—Ç–∏
start = (1, 1)
goal = (12, 12)
path = planner.a_star(start, goal)

if path:
    print("–ù–∞–π–¥–µ–Ω –ø—É—Ç—å:")
    for point in path:
        print(f"  {point}")
else:
    print("–ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω")

# –õ–æ–∫–∞–ª—å–Ω–æ–µ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ (DWA)
current_pose = (1.0, 1.0, 0.0)  # x, y, —É–≥–æ–ª
obstacles = [(5.0, i) for i in range(3, 8)] + [(i, 5.0) for i in range(3, 8)]
best_trajectory = planner.dynamic_window_approach(current_pose, goal, obstacles)

if best_trajectory:
    print(f"–õ—É—á—à–∞—è —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—è –∏–∑ {len(best_trajectory)} —Ç–æ—á–µ–∫")
    print(f"–ö–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞: {best_trajectory[-1][:2]}")
```

## –ë–µ—Å–ø–∏–ª–æ—Ç–Ω—ã–µ –∞–≤—Ç–æ–º–æ–±–∏–ª–∏

### –°–∏—Å—Ç–µ–º—ã perception –¥–ª—è –∞–≤—Ç–æ–ø–∏–ª–æ—Ç–∞:

```python
import cv2
import numpy as np

class AutonomousVehiclePerception:
    def __init__(self):
        self.lane_detector = LaneDetector()
        self.object_detector = ObjectDetector()
        self.traffic_sign_detector = TrafficSignDetector()
    
    def process_camera_feed(self, frame):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∏–¥–µ–æ–ø–æ—Ç–æ–∫–∞ —Å –∫–∞–º–µ—Ä—ã"""
        results = {}
        
        # –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –ø–æ–ª–æ—Å
        lanes = self.lane_detector.detect_lanes(frame)
        results['lanes'] = lanes
        
        # –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
        objects = self.object_detector.detect_objects(frame)
        results['objects'] = objects
        
        # –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –¥–æ—Ä–æ–∂–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤
        signs = self.traffic_sign_detector.detect_signs(frame)
        results['signs'] = signs
        
        return results

class LaneDetector:
    def __init__(self):
        self.left_line = None
        self.right_line = None
    
    def detect_lanes(self, frame):
        """–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –¥–æ—Ä–æ–∂–Ω—ã—Ö –ø–æ–ª–æ—Å"""
        # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ –≥—Ä–∞–¥–∞—Ü–∏–∏ —Å–µ—Ä–æ–≥–æ
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        
        # –ì–∞—É—Å—Å–æ–≤–æ —Ä–∞–∑–º—ã—Ç–∏–µ
        blur = cv2.GaussianBlur(gray, (5, 5), 0)
        
        # –í—ã–¥–µ–ª–µ–Ω–∏–µ –∫—Ä–∞–µ–≤ –º–µ—Ç–æ–¥–æ–º Canny
        edges = cv2.Canny(blur, 50, 150)
        
        # –û–±–ª–∞—Å—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å–∞ (–Ω–∏–∂–Ω—è—è –ø–æ–ª–æ–≤–∏–Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è)
        height, width = frame.shape[:2]
        roi_vertices = np.array([[
            (0, height),
            (width/2, height/2),
            (width, height)
        ]], dtype=np.int32)
        
        mask = np.zeros_like(edges)
        cv2.fillPoly(mask, roi_vertices, 255)
        masked_edges = cv2.bitwise_and(edges, mask)
        
        # –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –ª–∏–Ω–∏–π –º–µ—Ç–æ–¥–æ–º –•–∞—Ñ–∞
        lines = cv2.HoughLinesP(
            masked_edges, 
            rho=1, 
            theta=np.pi/180, 
            threshold=20, 
            minLineLength=20, 
            maxLineGap=300
        )
        
        # –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –ª–µ–≤—ã–µ –∏ –ø—Ä–∞–≤—ã–µ –ª–∏–Ω–∏–∏
        left_lines = []
        right_lines = []
        
        if lines is not None:
            for line in lines:
                x1, y1, x2, y2 = line[0]
                if x2 != x1:  # –ò–∑–±–µ–∂–∞—Ç—å –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
                    slope = (y2 - y1) / (x2 - x1)
                    if abs(slope) > 0.5:  # –§–∏–ª—å—Ç—Ä –ø–æ –Ω–∞–∫–ª–æ–Ω—É
                        if slope < 0:
                            left_lines.append(line[0])
                        else:
                            right_lines.append(line[0])
        
        # –ê–ø–ø—Ä–æ–∫—Å–∏–º–∞—Ü–∏—è –ª–∏–Ω–∏–π
        left_lane = self.average_lines(left_lines, height)
        right_lane = self.average_lines(right_lines, height)
        
        return {
            'left_lane': left_lane,
            'right_lane': right_lane,
            'center_offset': self.calculate_center_offset(left_lane, right_lane, width)
        }
    
    def average_lines(self, lines, img_height):
        """–£—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ –ª–∏–Ω–∏–π"""
        if not lines:
            return None
        
        x_coords = []
        y_coords = []
        
        for line in lines:
            x1, y1, x2, y2 = line
            x_coords.extend([x1, x2])
            y_coords.extend([y1, y2])
        
        # –ü–æ–ª–∏–Ω–æ–º–∏–∞–ª—å–Ω–∞—è –∞–ø–ø—Ä–æ–∫—Å–∏–º–∞—Ü–∏—è
        poly = np.polyfit(y_coords, x_coords, 1)
        
        # –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
        y1 = img_height
        y2 = int(img_height * 0.6)
        x1 = int(np.polyval(poly, y1))
        x2 = int(np.polyval(poly, y2))
        
        return [(x1, y1), (x2, y2)]
    
    def calculate_center_offset(self, left_lane, right_lane, img_width):
        """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –¥–æ—Ä–æ–≥–∏"""
        if left_lane is None or right_lane is None:
            return 0
        
        # –¶–µ–Ω—Ç—Ä –¥–æ—Ä–æ–≥–∏
        road_center = (left_lane[0][0] + right_lane[0][0]) / 2
        
        # –¶–µ–Ω—Ç—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        img_center = img_width / 2
        
        # –û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
        offset = road_center - img_center
        
        # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è (-1 –¥–æ 1)
        return offset / (img_width / 2)

class ObjectDetector:
    def __init__(self):
        # –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ YOLO
        self.net = cv2.dnn.readNet("yolov3.weights", "yolov3.cfg")
        with open("coco.names", "r") as f:
            self.classes = [line.strip() for line in f.readlines()]
        
        self.layer_names = self.net.getLayerNames()
        self.output_layers = [self.layer_names[i - 1] for i in self.net.getUnconnectedOutLayers()]
    
    def detect_objects(self, frame):
        """–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏"""
        height, width, channels = frame.shape
        
        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        blob = cv2.dnn.blobFromImage(frame, 0.00392, (416, 416), (0, 0, 0), True, crop=False)
        self.net.setInput(blob)
        outs = self.net.forward(self.output_layers)
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        class_ids = []
        confidences = []
        boxes = []
        
        for out in outs:
            for detection in out:
                scores = detection[5:]
                class_id = np.argmax(scores)
                confidence = scores[class_id]
                
                if confidence > 0.5:
                    # –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ–±—ä–µ–∫—Ç–∞
                    center_x = int(detection[0] * width)
                    center_y = int(detection[1] * height)
                    w = int(detection[2] * width)
                    h = int(detection[3] * height)
                    
                    # –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞
                    x = int(center_x - w / 2)
                    y = int(center_y - h / 2)
                    
                    boxes.append([x, y, w, h])
                    confidences.append(float(confidence))
                    class_ids.append(class_id)
        
        # –ü–æ–¥–∞–≤–ª–µ–Ω–∏–µ –Ω–µ–º–∞–∫—Å–∏–º—É–º–æ–≤
        indexes = cv2.dnn.NMSBoxes(boxes, confidences, 0.5, 0.4)
        
        objects = []
        for i in range(len(boxes)):
            if i in indexes:
                x, y, w, h = boxes[i]
                label = str(self.classes[class_ids[i]])
                confidence = confidences[i]
                
                objects.append({
                    'class': label,
                    'confidence': confidence,
                    'bbox': [x, y, w, h],
                    'distance': self.estimate_distance(w, h)  # –ü—Ä–∏–º–µ—Ä–Ω–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è
                })
        
        return objects
    
    def estimate_distance(self, width_pixels, height_pixels):
        """–û—Ü–µ–Ω–∫–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ –æ–±—ä–µ–∫—Ç–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è)"""
        # –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º –∏–∑–≤–µ—Å—Ç–Ω—ã–µ —Ä–µ–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –æ–±—ä–µ–∫—Ç–∞
        known_width = 1.8  # –º–µ—Ç—Ä–∞ (—Å—Ä–µ–¥–Ω—è—è —à–∏—Ä–∏–Ω–∞ –∞–≤—Ç–æ–º–æ–±–∏–ª—è)
        focal_length = 800  # –ø–∏–∫—Å–µ–ª–µ–π (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–∞–º–µ—Ä—ã)
        
        if width_pixels > 0:
            distance = (known_width * focal_length) / width_pixels
            return distance
        return float('inf')

class TrafficSignDetector:
    def __init__(self):
        # –ü—Ä–æ—Å—Ç–æ–π –¥–µ—Ç–µ–∫—Ç–æ—Ä –∑–Ω–∞–∫–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ü–≤–µ—Ç–æ–≤—ã—Ö –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤
        self.sign_templates = {
            'stop': {
                'color_range': ([0, 100, 100], [10, 255, 255]),  # –ö—Ä–∞—Å–Ω—ã–π
                'shape': 'octagon'
            },
            'yield': {
                'color_range': ([10, 100, 100], [25, 255, 255]),  # –û—Ä–∞–Ω–∂–µ–≤—ã–π
                'shape': 'triangle'
            }
        }
    
    def detect_signs(self, frame):
        """–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –¥–æ—Ä–æ–∂–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤"""
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        signs = []
        
        for sign_type, params in self.sign_templates.items():
            lower = np.array(params['color_range'][0])
            upper = np.array(params['color_range'][1])
            
            mask = cv2.inRange(hsv, lower, upper)
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            
            for contour in contours:
                area = cv2.contourArea(contour)
                if area > 500:  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø–ª–æ—â–∞–¥—å
                    x, y, w, h = cv2.boundingRect(contour)
                    
                    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º—ã
                    if self.check_shape(contour, params['shape']):
                        signs.append({
                            'type': sign_type,
                            'bbox': [x, y, w, h],
                            'confidence': min(1.0, area / 10000)
                        })
        
        return signs
    
    def check_shape(self, contour, expected_shape):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º—ã –∫–æ–Ω—Ç—É—Ä–∞"""
        epsilon = 0.02 * cv2.arcLength(contour, True)
        approx = cv2.approxPolyDP(contour, epsilon, True)
        
        if expected_shape == 'octagon':
            return len(approx) >= 8
        elif expected_shape == 'triangle':
            return len(approx) == 3
        
        return True

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
perception = AutonomousVehiclePerception()

# –°–∏–º—É–ª—è—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ–ø–æ—Ç–æ–∫–∞
frame = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
results = perception.process_camera_feed(frame)

print("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤–æ—Å–ø—Ä–∏—è—Ç–∏—è:")
print(f"–ü–æ–ª–æ—Å—ã: {results['lanes']}")
print(f"–û–±—ä–µ–∫—Ç—ã: {len(results['objects'])}")
print(f"–ó–Ω–∞–∫–∏: {len(results['signs'])}")
```

## –ü—Ä–æ–º—ã—à–ª–µ–Ω–Ω–∞—è —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞

### SCARA —Ä–æ–±–æ—Ç—ã:

```python
import math
import numpy as np

class SCARARobot:
    def __init__(self, l1, l2):
        """
        SCARA —Ä–æ–±–æ—Ç —Å –¥–≤—É–º—è –≤—Ä–∞—â–∞—Ç–µ–ª—å–Ω—ã–º–∏ –∏ –æ–¥–Ω–æ–π –ø–æ—Å—Ç—É–ø–∞—Ç–µ–ª—å–Ω–æ–π —Å—Ç–µ–ø–µ–Ω—è–º–∏ —Å–≤–æ–±–æ–¥—ã
        l1, l2 - –¥–ª–∏–Ω—ã –∑–≤–µ–Ω—å–µ–≤
        """
        self.l1 = l1
        self.l2 = l2
        self.theta1 = 0
        self.theta2 = 0
        self.z = 0
    
    def forward_kinematics(self, theta1, theta2, z):
        """–ü—Ä—è–º–∞—è –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∞ SCARA"""
        x = self.l1 * math.cos(theta1) + self.l2 * math.cos(theta1 + theta2)
        y = self.l1 * math.sin(theta1) + self.l2 * math.sin(theta1 + theta2)
        return x, y, z
    
    def inverse_kinematics(self, x, y, z):
        """–û–±—Ä–∞—Ç–Ω–∞—è –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∞ SCARA"""
        # –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–ª–∏ –≤ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ XY
        r = math.sqrt(x**2 + y**2)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–∏–º–æ—Å—Ç–∏
        if r > self.l1 + self.l2:
            print("–¶–µ–ª—å –≤–Ω–µ —Ä–∞–±–æ—á–µ–π –∑–æ–Ω—ã")
            return None
        
        if r 
if r < abs(self.l1 - self.l2):
    print(\
–¶–µ–ª—å
—Å–ª–∏—à–∫–æ–º
–±–ª–∏–∑–∫–æ\)
    return None

# –£–≥–æ–ª –ø–µ—Ä–≤–æ–≥–æ —Å—É—Å—Ç–∞–≤–∞
cos_theta2 = (r**2 - self.l1**2 - self.l2**2) / (2 * self.l1 * self.l2)
theta2 = math.acos(max(-1, min(1, cos_theta2)))

theta1 = math.atan2(y, x) - math.atan2(self.l2 * math.sin(theta2), 
                                      self.l1 + self.l2 * math.cos(theta2))

return theta1, theta2, z

def jacobian(self, theta1, theta2):
    \\\–Ø–∫–æ–±–∏–∞–Ω
SCARA
—Ä–æ–±–æ—Ç–∞\\\
    J = np.zeros((3, 3))
    
    # ‚àÇx/‚àÇŒ∏1, ‚àÇx/‚àÇŒ∏2, ‚àÇx/‚àÇz
    J[0, 0] = -self.l1 * math.sin(theta1) - self.l2 * math.sin(theta1 + theta2)
    J[0, 1] = -self.l2 * math.sin(theta1 + theta2)
    J[0, 2] = 0
    
    # ‚àÇy/‚àÇŒ∏1, ‚àÇy/‚àÇŒ∏2, ‚àÇy/‚àÇz
    J[1, 0] = self.l1 * math.cos(theta1) + self.l2 * math.cos(theta1 + theta2)
    J[1, 1] = self.l2 * math.cos(theta1 + theta2)
    J[1, 2] = 0
    
    # ‚àÇz/‚àÇŒ∏1, ‚àÇz/‚àÇŒ∏2, ‚àÇz/‚àÇz
    J[2, 0] = 0
    J[2, 1] = 0
    J[2, 2] = 1
    
    return J

def move_to_position(self, target_x, target_y, target_z, speed=0.1):
    \\\–î–≤–∏–∂–µ–Ω–∏–µ
–∫
—Ü–µ–ª–µ–≤–æ–π
–ø–æ–∑–∏—Ü–∏–∏\\\
    ik_result = self.inverse_kinematics(target_x, target_y, target_z)
    
    if ik_result is None:
        return False
    
    target_theta1, target_theta2, target_z = ik_result
    
    # –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
    steps = 50
    for i in range(steps + 1):
        t = i / steps
        
        # –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è —É–≥–ª–æ–≤
        current_theta1 = self.theta1 + t * (target_theta1 - self.theta1)
        current_theta2 = self.theta2 + t * (target_theta2 - self.theta2)
        current_z = self.z + t * (target_z - self.z)
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
        self.theta1 = current_theta1
        self.theta2 = current_theta2
        self.z = current_z
        
        # –°–∏–º—É–ª—è—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏
        import time
        time.sleep(speed / steps)
    
    return True

def get_current_position(self):
    \\\–ü–æ–ª—É—á–µ–Ω–∏–µ
—Ç–µ–∫—É—â–µ–π
–ø–æ–∑–∏—Ü–∏–∏\\\
    return self.forward_kinematics(self.theta1, self.theta2, self.z)

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è SCARA —Ä–æ–±–æ—Ç–∞
scara = SCARARobot(l1=300, l2=250)  # –º–º

# –î–≤–∏–∂–µ–Ω–∏–µ –∫ —Ç–æ—á–∫–µ
success = scara.move_to_position(200, 150, 100)
if success:
    current_pos = scara.get_current_position()
    print(f\–¢–µ–∫—É—â–∞—è
–ø–æ–∑–∏—Ü–∏—è:
current_pos[0]:.2f
current_pos[1]:.2f
current_pos[2]:.2f
–º–º\)

# –Ø–∫–æ–±–∏–∞–Ω –≤ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏
J = scara.jacobian(scara.theta1, scara.theta2)
print(\–Ø–∫–æ–±–∏–∞–Ω:\)
print(J)

