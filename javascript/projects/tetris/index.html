<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>–¢–µ—Ç—Ä–∏—Å ‚Äî —É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è</title>
<style>
  :root{
    --bg:#071126; --panel:#071726; --accent:#10b981; --muted:#94a3b8;
  }
  html,body{height:100%;margin:0;font-family:Inter, Roboto, Arial, sans-serif;background:linear-gradient(180deg,#071126 0%,#081226 60%);color:#e6eef6}
  .container{display:flex;gap:20px;align-items:flex-start;justify-content:center;padding:18px;max-width:1200px;margin:0 auto}
  .board{background:var(--panel);padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,.6);position:relative}
  canvas{display:block;background:#061016;border-radius:6px}
  .controls{width:360px;display:flex;flex-direction:column;gap:12px}
  .panel{background:rgba(255,255,255,.03);padding:12px;border-radius:10px}
  h1{margin:0 0 6px 0;font-size:20px}
  button{cursor:pointer;border:0;padding:8px 10px;border-radius:8px;background:var(--accent);color:#042018;font-weight:600}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,.06);color:var(--muted)}
  .small{font-size:13px;color:var(--muted)}
  #next,#hold{display:grid;grid-template-columns:repeat(5,40px);gap:6px}
  .preview{width:40px;height:80px;background:rgba(255,255,255,.02);display:flex;align-items:center;justify-content:center;border-radius:6px}
  .touch-row{display:flex;gap:8px;flex-wrap:wrap}
  .touch-btn{padding:12px 10px;border-radius:8px;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.04);color:#fff}
  .overlay{position:absolute;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}
  .overlay .box{background:rgba(2,6,23,.92);padding:18px;border-radius:10px;text-align:center}
  footer{color:var(--muted);font-size:12px;text-align:center;margin-top:14px}
  input[type=number]{width:80px}
  .label-button{background:transparent;border:1px solid rgba(255,255,255,.04);padding:6px;border-radius:6px;color:var(--muted);cursor:pointer}
  @media(max-width:900px){ .container{flex-direction:column;align-items:center} .controls{width:94%} }
</style>
</head>
<body>
<header style="text-align:center;padding:14px;">
  <h1>–¢–µ—Ç—Ä–∏—Å ‚Äî —É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è</h1>
  <div class="small">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ‚Üê ‚Üí (–¥–≤–∏–∂–µ–Ω–∏–µ) ‚Ä¢ ‚Üë / X / Z (–≤—Ä–∞—â–µ–Ω–∏–µ) ‚Ä¢ ‚Üì (soft) ‚Ä¢ Space (hard) ‚Ä¢ Shift (hold) ‚Ä¢ P (–ø–∞—É–∑–∞) ‚Ä¢ F (fullscreen)</div>
</header>

<div class="container">
  <div class="board" id="game-area" style="min-width:360px;">
    <canvas id="gameCanvas" aria-label="Tetris game board"></canvas>

    <div id="pauseOverlay" class="overlay" style="display:none;">
      <div class="box"><h2>–ü–∞—É–∑–∞</h2><div class="small">–ù–∞–∂–º–∏—Ç–µ P –∏–ª–∏ –∫–Ω–æ–ø–∫—É ¬´–ü–∞—É–∑–∞¬ª —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å</div></div>
    </div>

    <div id="gameOverOverlay" class="overlay" style="display:none;">
      <div class="box">
        <h2 id="go-title">–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</h2>
        <div class="small" id="go-score"></div>
        <div style="margin-top:10px;">
          <button id="go-restart" class="ghost">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>
      </div>
    </div>
  </div>

  <div class="controls">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div>
          <div style="font-size:18px;font-weight:700" id="score">0</div>
          <div class="small muted">–°—á–µ—Ç</div>
        </div>
        <div style="text-align:right">
          <div style="font-weight:700" id="level">1</div>
          <div class="small muted">–£—Ä–æ–≤–µ–Ω—å</div>
        </div>
      </div>
      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="startBtn">–ù–∞—á–∞—Ç—å</button>
        <button id="pauseBtn" class="ghost">–ü–∞—É–∑–∞</button>
        <button id="resetBtn" class="ghost">–°–±—Ä–æ—Å</button>
        <button id="fullscreenBtn" class="ghost">–ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π</button>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small muted">Hold</div><div id="hold"></div>
      </div>
      <hr style="opacity:.04;margin:10px 0">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small muted">Next</div><div id="next"></div>
      </div>
    </div>

    <div class="panel">
      <div class="small muted">–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤</div>
      <ol id="high-scores-list"></ol>
    </div>

    <div class="panel">
      <div class="small muted">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px;">
        <div>Left: <button id="rebind-left" class="label-button">ArrowLeft</button></div>
        <div>Right: <button id="rebind-right" class="label-button">ArrowRight</button></div>
        <div>Rotate: <button id="rebind-rotate" class="label-button">ArrowUp</button></div>
        <div>Drop: <button id="rebind-drop" class="label-button">Space</button></div>
        <div>Hold: <button id="rebind-hold" class="label-button">Shift</button></div>
        <div>SoftDrop: <button id="rebind-soft" class="label-button">ArrowDown</button></div>
      </div>
      <hr style="opacity:.04;margin:10px 0">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="small muted">DAS (ms)</div><input id="dasInput" type="number" value="150" min="0">
      </div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px;">
        <div class="small muted">ARR (ms)</div><input id="arrInput" type="number" value="40" min="0">
      </div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px;">
        <div class="small muted">–ú—É–∑—ã–∫–∞</div><button id="musicBtn" class="ghost">–í–∫–ª. –º—É–∑—ã–∫—É</button>
      </div>
    </div>

    <div class="panel">
      <div class="small muted">–ú–æ–±–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</div>
      <div class="touch-row" style="margin-top:8px">
        <button class="touch-btn" id="t-left">‚Üê</button>
        <button class="touch-btn" id="t-rotate">‚§æ</button>
        <button class="touch-btn" id="t-right">‚Üí</button>
        <button class="touch-btn" id="t-down">‚Üì</button>
        <button class="touch-btn" id="t-drop">Drop</button>
        <button class="touch-btn" id="t-hold">Hold</button>
      </div>
    </div>
  </div>
</div>

<footer style="text-align:center;padding:14px;">
  <div class="small muted">–ê–≤—Ç–æ—Ä: –î—É–ø–ª–µ–π –ú–∞–∫—Å–∏–º –ò–≥–æ—Ä–µ–≤–∏—á ‚Ä¢ GitHub: <a href="https://github.com/QuadDarv1ne/" target="_blank">QuadDarv1ne</a> ‚Ä¢ ORCID: <a href="https://orcid.org/0009-0007-7605-539X" target="_blank">0009-0007-7605-539X</a> ‚Ä¢ –î–∞—Ç–∞: 22.09.2025</div>
</footer>

<script>
/**
 * üéÆ Tetris ‚Äî —É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è
 *
 * –ê–≤—Ç–æ—Ä: –î—É–ø–ª–µ–π –ú–∞–∫—Å–∏–º –ò–≥–æ—Ä–µ–≤–∏—á
 * GitHub: https://github.com/QuadDarv1ne/
 * ORCID:  https://orcid.org/0009-0007-7605-539X
 * –î–∞—Ç–∞:   22.09.2025
 *
 * –≠—Ç–æ –µ–¥–∏–Ω—ã–π HTML-—Ñ–∞–π–ª —Å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π –∏–≥—Ä—ã:
 * - –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π canvas, –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º
 * - 7-bag randomizer, preview next(5), hold
 * - DAS/ARR –∏ –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –∫–ª–∞–≤–∏—à (key remap)
 * - procedural music (Korobeiniki) + SFX (WebAudio)
 * - touch —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (—Å–≤–∞–π–ø—ã + —É–¥–µ—Ä–∂–∞–Ω–∏–µ)
 *
 * –û—Ç–∫—Ä–æ–π —Ñ–∞–π–ª –≤ –±—Ä–∞—É–∑–µ—Ä–µ. –î–ª—è –∑–≤—É–∫–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∂–µ—Å—Ç (–∫–ª–∏–∫/–Ω–∞–∂–∞—Ç–∏–µ).
 */

/* ===========================
   –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
   =========================== */
const cvs = document.getElementById('gameCanvas');
const ctx = cvs.getContext('2d');

const COLS = 10;
const ROWS = 20;

let BLOCK = 30; // —Ä–∞–∑–º–µ—Ä –∫–ª–µ—Ç–∫–∏, –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –≤ resizeCanvas()

// –ø–∞–ª–∏—Ç—Ä–∞ (I,O,T,L,J,S,Z)
const COLORS = ['#00FFFF','#FFD500','#A000F0','#FF8C00','#0000FF','#00C853','#D50000'];

/* –ò–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ */
let grid = createEmptyGrid();
let bag = [];
let queue = [];
let holdPiece = null;
let holdLocked = false;
let current = null; // {idx, shape, x, y}
let nextCount = 5;

let score = 0;
let level = 1;
let linesCleared = 0;

let dropInterval = 1000; // ms
let lastDrop = 0;

let isPaused = false;
let isGameOver = false;

/* Keymap –∏ DAS/ARR */
const defaultKeymap = { left:'ArrowLeft', right:'ArrowRight', rotate:'ArrowUp', drop:' ', hold:'Shift', soft:'ArrowDown' };
let keymap = JSON.parse(localStorage.getItem('tetris_keymap') || 'null') || defaultKeymap;
let DAS = Number(localStorage.getItem('tetris_das')) || 150;
let ARR = Number(localStorage.getItem('tetris_arr')) || 40;

/* DAS state (separate timers for left/right) */
let dasTimeoutLeft = null, arrIntervalLeft = null;
let dasTimeoutRight = null, arrIntervalRight = null;

/* Shapes */
const SHAPES = [
  [[1,1,1,1]], // I
  [[1,1],[1,1]], // O
  [[1,1,1],[0,1,0]], // T
  [[1,1,1],[1,0,0]], // L
  [[1,1,1],[0,0,1]], // J
  [[0,1,1],[1,1,0]], // S
  [[1,1,0],[0,1,1]]  // Z
];

/* ===========================
   Canvas resize & rendering
   =========================== */

/**
 * resizeCanvas()
 * –ú–µ–Ω—è–µ—Ç —Ä–∞–∑–º–µ—Ä—ã canvas —Ç–∞–∫, —á—Ç–æ–±—ã –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ –∑–∞–Ω–∏–º–∞–ª–æ –¥–æ—Å—Ç—É–ø–Ω—É—é –æ–±–ª–∞—Å—Ç—å
 * –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ #game-area (—Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –≤ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ).
 */
function resizeCanvas(){
  const parent = document.getElementById('game-area');
  const rect = parent.getBoundingClientRect();
  const availW = rect.width || window.innerWidth;
  const availH = rect.height || window.innerHeight;
  const idealBlock = Math.floor(Math.min(availW / COLS, availH / ROWS));
  BLOCK = Math.max(14, Math.min(48, idealBlock));
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  cvs.width = COLS * BLOCK * dpr;
  cvs.height = ROWS * BLOCK * dpr;
  cvs.style.width = (COLS * BLOCK) + 'px';
  cvs.style.height = (ROWS * BLOCK) + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
resizeCanvas();
window.addEventListener('resize', ()=>{ resizeCanvas(); draw(); });

/**
 * draw()
 * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç —Ñ–æ–Ω, —Å–µ—Ç–∫—É, –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –±–ª–æ–∫–∏, ghost –∏ —Ç–µ–∫—É—â—É—é —Ñ–∏–≥—É—Ä—É.
 */
function draw(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  ctx.fillStyle = '#061016';
  ctx.fillRect(0,0,COLS*BLOCK,ROWS*BLOCK);

  // —Ç–æ–Ω–∫–∞—è —Å–µ—Ç–∫–∞
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let x=0;x<=COLS;x++){
    ctx.beginPath(); ctx.moveTo(x*BLOCK,0); ctx.lineTo(x*BLOCK,ROWS*BLOCK); ctx.stroke();
  }
  for(let y=0;y<=ROWS;y++){
    ctx.beginPath(); ctx.moveTo(0,y*BLOCK); ctx.lineTo(COLS*BLOCK,y*BLOCK); ctx.stroke();
  }

  // –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –±–ª–æ–∫–∏
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const v = grid[r][c];
      if(v){
        const color = COLORS[v-1];
        const x = c*BLOCK, y = r*BLOCK;
        const g = ctx.createLinearGradient(x,y,x+BLOCK,y+BLOCK);
        g.addColorStop(0, lighten(color,0.15));
        g.addColorStop(1, color);
        ctx.fillStyle = g;
        ctx.fillRect(x+1,y+1,BLOCK-2,BLOCK-2);
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.strokeRect(x+1,y+1,BLOCK-2,BLOCK-2);
        // –±–ª–∏–∫
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.fillRect(x+3,y+3,BLOCK-6,Math.max(2,BLOCK/6));
      }
    }
  }

  if(current){
    // ghost
    let gy = current.y;
    while(!collision(current.x, gy+1, current.shape)) gy++;
    ctx.globalAlpha = 0.22;
    for(let i=0;i<current.shape.length;i++){
      for(let j=0;j<current.shape[i].length;j++){
        if(current.shape[i][j]){
          const px = (current.x + j)*BLOCK, py = (gy + i)*BLOCK;
          const color = COLORS[current.idx];
          const g = ctx.createLinearGradient(px,py,px+BLOCK,py+BLOCK);
          g.addColorStop(0, lighten(color,0.15));
          g.addColorStop(1, color);
          ctx.fillStyle = g;
          ctx.fillRect(px+1,py+1,BLOCK-2,BLOCK-2);
        }
      }
    }
    ctx.globalAlpha = 1;

    // current piece
    for(let i=0;i<current.shape.length;i++){
      for(let j=0;j<current.shape[i].length;j++){
        if(current.shape[i][j]){
          const px = (current.x + j)*BLOCK, py = (current.y + i)*BLOCK;
          const color = COLORS[current.idx];
          const g2 = ctx.createLinearGradient(px,py,px+BLOCK,py+BLOCK);
          g2.addColorStop(0, lighten(color,0.15));
          g2.addColorStop(1, color);
          ctx.fillStyle = g2;
          ctx.fillRect(px+1,py+1,BLOCK-2,BLOCK-2);
          ctx.strokeStyle='rgba(0,0,0,0.4)';
          ctx.strokeRect(px+1,py+1,BLOCK-2,BLOCK-2);
          ctx.fillStyle='rgba(255,255,255,0.06)';
          ctx.fillRect(px+3,py+3,BLOCK-6,Math.max(2,BLOCK/6));
        }
      }
    }
  }
}

/* ===========================
   –ò–≥—Ä–æ–≤–∞—è –ª–æ–≥–∏–∫–∞
   =========================== */

/** createEmptyGrid() -> Array */
function createEmptyGrid(){ return Array.from({length:ROWS}, ()=>new Array(COLS).fill(0)); }

function shuffle(array){ for(let i=array.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [array[i],array[j]]=[array[j],array[i]]; } }
function refillBag(){ const arr=[0,1,2,3,4,5,6]; shuffle(arr); bag = bag.concat(arr); }
function fillQueue(){ while(queue.length < nextCount){ if(bag.length===0) refillBag(); queue.push(bag.shift()); } }

/**
 * spawnPiece()
 * –ë–µ—Ä—ë—Ç —Å–ª–µ–¥—É—é—â—É—é —Ñ–∏–≥—É—Ä—É –∏–∑ –æ—á–µ—Ä–µ–¥–∏ –∏ —Ä–∞–∑–º–µ—â–∞–µ—Ç –µ—ë —Å–≤–µ—Ä—Ö—É. –ï—Å–ª–∏ —Å—Ä–∞–∑—É –∫–æ–ª–ª–∏–∑–∏—è ‚Äî –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã.
 */
function spawnPiece(){
  fillQueue();
  const idx = queue.shift();
  fillQueue();
  const shape = cloneShape(SHAPES[idx]);
  current = { idx, shape, x: Math.floor((COLS - shape[0].length)/2), y: 0 };
  holdLocked = false;
  if(collision(current.x, current.y, current.shape)){
    endGame();
  }
}
function cloneShape(s){ return s.map(r=>r.slice()); }

function rotateMatrix(m){
  const h = m.length, w = m[0].length;
  const res = Array.from({length:w}, ()=>new Array(h));
  for(let i=0;i<w;i++) for(let j=0;j<h;j++) res[i][j] = m[h-1-j][i];
  return res;
}

/**
 * collision(x,y,shape) -> boolean
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Ñ–∏–≥—É—Ä—ã —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏/—Å–µ—Ç–∫–æ–π.
 */
function collision(x,y,shape){
  for(let i=0;i<shape.length;i++){
    for(let j=0;j<shape[i].length;j++){
      if(shape[i][j]){
        const gx = x + j, gy = y + i;
        if(gx < 0 || gx >= COLS || gy >= ROWS) return true;
        if(gy >= 0 && grid[gy][gx]) return true;
      }
    }
  }
  return false;
}

/**
 * lockPiece()
 * –§–∏–∫—Å–∏—Ä—É–µ—Ç —Ç–µ–∫—É—â—É—é —Ñ–∏–≥—É—Ä—É –≤ —Å–µ—Ç–∫–µ, –∑–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∏ —É–¥–∞–ª—è–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –ª–∏–Ω–∏–∏.
 */
function lockPiece(){
  const s = current.shape, idx = current.idx + 1;
  for(let i=0;i<s.length;i++) for(let j=0;j<s[i].length;j++) if(s[i][j]){
    const gx = current.x + j, gy = current.y + i;
    if(gy >= 0) grid[gy][gx] = idx;
  }
  playBeep(220 + Math.random()*200, 0.06, 'square', 0.03);
  clearLines();
  spawnPiece();
}

/**
 * clearLines()
 * –£–¥–∞–ª—è–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏, —Å–º–µ—â–∞–µ—Ç –≤–µ—Ä—Ö, –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—á—ë—Ç/—É—Ä–æ–≤–µ–Ω—å.
 */
function clearLines(){
  const newGrid = grid.filter(row => row.some(c => c === 0));
  const cleared = ROWS - newGrid.length;
  if(cleared > 0){
    for(let i=0;i<cleared;i++) newGrid.unshift(new Array(COLS).fill(0));
    grid = newGrid;
    const scoring = {1:100,2:300,3:500,4:800};
    score += (scoring[cleared] || 0) * level;
    linesCleared += cleared;
    level = Math.floor(linesCleared / 10) + 1;
    dropInterval = Math.max(80, 1000 - (level - 1) * 80);
    updateUI();
    // jingle
    const base = 330;
    for(let i=0;i<cleared;i++){ setTimeout(()=>playBeep(base + i*60, 0.12, 'square', 0.09), i*120); }
  }
}

/**
 * hardDrop()
 * –ñ—ë—Å—Ç–∫–æ–µ –æ–ø—É—Å–∫–∞–Ω–∏–µ: –æ–ø—É—Å–∫–∞–µ—Ç —Ñ–∏–≥—É—Ä—É –¥–æ —É–ø–æ—Ä–∞, –Ω–∞—á–∏—Å–ª—è–µ—Ç –æ—á–∫–∏ –∏ —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç.
 */
function hardDrop(){
  let drop = 0;
  while(!collision(current.x, current.y+1, current.shape)){
    current.y++; drop++;
  }
  score += drop * 2;
  playBeep(900, 0.04, 'square', 0.06);
  lockPiece();
}

/**
 * softDrop()
 * –ú—è–≥–∫–æ–µ –æ–ø—É—Å–∫–∞–Ω–∏–µ: –¥–≤–∏–∂–µ–Ω–∏–µ –≤–Ω–∏–∑ –Ω–∞ –æ–¥–Ω—É –∫–ª–µ—Ç–∫—É, –¥–∞—ë—Ç 1 –æ—á–∫–æ.
 */
function softDrop(){
  if(!collision(current.x, current.y+1, current.shape)){
    current.y++; score += 1; updateUI();
  } else {
    lockPiece();
  }
}

/**
 * rotateCW()
 * –ü–æ–≤–æ—Ä–æ—Ç –ø–æ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–µ —Å –ø—Ä–æ—Å—Ç—ã–º wall-kick: –ø—Ä–æ–±—É–µ—Ç —Å–¥–≤–∏–≥ –ø–æ X.
 */
function rotateCW(){
  const rotated = rotateMatrix(current.shape);
  const kicks = [0,1,-1,2,-2];
  for(const dx of kicks){
    if(!collision(current.x + dx, current.y, rotated)){
      current.shape = rotated;
      current.x += dx;
      playBeep(880, 0.05, 'sawtooth', 0.06);
      return;
    }
  }
}
function rotateCCW(){ rotateCW(); rotateCW(); rotateCW(); }

/**
 * move(dx)
 * –ü–µ—Ä–µ–¥–≤–∏–Ω—É—Ç—å —Ñ–∏–≥—É—Ä—É –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ, –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ.
 * @param {number} dx
 */
function move(dx){
  if(!collision(current.x + dx, current.y, current.shape)){
    current.x += dx;
    playBeep(300, 0.02, 'square', 0.02);
  }
}

/**
 * hold()
 * –ü–æ–º–µ—Å—Ç–∏—Ç—å —Ç–µ–∫—É—â—É—é —Ñ–∏–≥—É—Ä—É –≤ hold (–∏–ª–∏ –∑–∞–º–µ–Ω–∏—Ç—å –µ—é —Ç–µ–∫—É—â—É—é).
 */
function hold(){
  if(holdLocked) return;
  if(holdPiece === null){
    holdPiece = current.idx;
    spawnPiece();
  } else {
    const tmp = holdPiece;
    holdPiece = current.idx;
    current = { idx: tmp, shape: cloneShape(SHAPES[tmp]), x: Math.floor((COLS - SHAPES[tmp][0].length)/2), y: 0 };
    if(collision(current.x, current.y, current.shape)) endGame();
  }
  holdLocked = true;
  playBeep(440, 0.06, 'triangle', 0.05);
}

/* ===========================
   Game loop
   =========================== */
let lastTime = 0;
function loop(time = 0){
  if(isPaused || isGameOver){
    lastTime = time;
    requestAnimationFrame(loop);
    return;
  }
  const delta = time - lastTime;
  lastTime = time;
  lastDrop += delta;
  if(lastDrop > dropInterval){
    if(!collision(current.x, current.y+1, current.shape)){
      current.y++;
    } else {
      lockPiece();
    }
    lastDrop = 0;
  }
  draw();
  requestAnimationFrame(loop);
}

/* ===========================
   UI & helpers
   =========================== */

/** updateUI() ‚Äî –æ–±–Ω–æ–≤–ª—è–µ—Ç –≤–∏–¥–∏–º—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ */
function updateUI(){
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
  renderPreviews();
  renderHighScores();
}

/** renderPreviews() ‚Äî –º–∏–Ω–∏-–ø—Ä–µ–≤—å—é next –∏ hold */
function renderPreviews(){
  const nextEl = document.getElementById('next'); nextEl.innerHTML = '';
  for(let i=0;i<nextCount;i++){
    const idx = queue[i] ?? null;
    const el = document.createElement('div'); el.className = 'preview';
    if(idx !== null) drawMini(el, SHAPES[idx], COLORS[idx]);
    nextEl.appendChild(el);
  }
  const holdEl = document.getElementById('hold'); holdEl.innerHTML = '';
  const holdBox = document.createElement('div'); holdBox.className = 'preview';
  if(holdPiece !== null) drawMini(holdBox, SHAPES[holdPiece], COLORS[holdPiece]);
  holdEl.appendChild(holdBox);
}

/** drawMini(el, shape, color) ‚Äî —Ä–∏—Å—É–µ—Ç –º–∏–Ω–∏-–ø—Ä–µ–≤—å—é —Ñ–∏–≥—É—Ä—ã */
function drawMini(container, shape, color){
  const mini = document.createElement('canvas'); mini.width = 40; mini.height = 80;
  container.appendChild(mini);
  const mctx = mini.getContext('2d');
  mctx.fillStyle = 'rgba(255,255,255,0.02)'; mctx.fillRect(0,0,mini.width,mini.height);
  const cell = Math.floor(Math.min(14, Math.max(6, 40 / shape[0].length)));
  mctx.translate(6,6);
  for(let i=0;i<shape.length;i++) for(let j=0;j<shape[i].length;j++) if(shape[i][j]){
    const x = j*cell, y = i*cell;
    const g = mctx.createLinearGradient(x,y,x+cell,y+cell);
    g.addColorStop(0, lighten(color,0.18)); g.addColorStop(1, color);
    mctx.fillStyle = g; mctx.fillRect(x,y,cell-2,cell-2);
    mctx.strokeStyle = 'rgba(0,0,0,0.35)'; mctx.strokeRect(x,y,cell-2,cell-2);
  }
}

/** lighten(hex, amt) -> string */
function lighten(hex, amt){
  const c = hex.replace('#','');
  const num = parseInt(c,16);
  let r = (num>>16) + Math.round(255*amt);
  let g = ((num>>8)&0x00FF) + Math.round(255*amt);
  let b = (num & 0x0000FF) + Math.round(255*amt);
  r = Math.min(255, r); g = Math.min(255, g); b = Math.min(255, b);
  return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
}

/* ===========================
   Audio: WebAudio + Korobeiniki
   =========================== */

let audioCtx = null;
let musicPlaying = false;
let korTimeout = null;
const MUSIC_BPM = 140;

/** ensureAudio() ‚Äî —Å–æ–∑–¥–∞—ë—Ç AudioContext –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ */
function ensureAudio(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

/**
 * playBeep(freq, duration=0.1, type='square', gain=0.08)
 * –ü—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç –∫–æ—Ä–æ—Ç–∫–∏–π –∑–≤—É–∫ (SFX).
 */
function playBeep(freq, duration=0.1, type='square', gain=0.08){
  try{
    ensureAudio();
    if(audioCtx.state === 'suspended'){
      audioCtx.resume().catch(()=>{});
    }
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = 0.0001;
    o.connect(g); g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(gain, now + 0.002);
    o.start(now);
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    setTimeout(()=>{ try{ o.stop(); o.disconnect(); g.disconnect(); }catch(e){} }, duration*1000 + 60);
  }catch(e){}
}

/* Note utilities */
const SEMITONE_RATIO = Math.pow(2,1/12);
function noteToFreq(note){
  const noteRegex = /^([A-G])(#|b)?([0-9])$/;
  const m = noteRegex.exec(note);
  if(!m) return 440;
  const names = {C:0,D:2,E:4,F:5,G:7,A:9,B:11};
  let n = names[m[1]];
  if(m[2] === '#') n += 1;
  if(m[2] === 'b') n -= 1;
  const octave = parseInt(m[3],10);
  const keyNumber = n + (octave - 4) * 12;
  const semitonesFromA4 = keyNumber - 9;
  return 440 * Math.pow(SEMITONE_RATIO, semitonesFromA4);
}

/* Simple Korobeiniki melody (simplified) as [note, quarterLength] */
const KOROBEINIKI = [
  ['E5',0.5],['B4',0.5],['C5',0.5],['D5',1],
  ['C5',0.5],['B4',0.5],['A4',1],
  ['A4',0.5],['C5',0.5],['E5',1],
  ['D5',0.5],['C5',0.5],['B4',1],
  ['E5',0.5],['B4',0.5],['C5',0.5],['D5',1],
  ['C5',0.5],['B4',0.5],['A4',1]
];

let korIndex = 0;
function playKorStep(){
  if(!musicPlaying) return;
  const step = KOROBEINIKI[korIndex];
  if(!step){
    korIndex = 0;
    return playKorStep();
  }
  const note = step[0];
  const quarterLen = 60 / MUSIC_BPM;
  const dur = quarterLen * step[1];
  playBeep(noteToFreq(note), dur*0.95, 'square', 0.06);
  korIndex = (korIndex + 1) % KOROBEINIKI.length;
  korTimeout = setTimeout(playKorStep, dur*1000);
}

/**
 * startMusic()
 * –ó–∞–ø—É—Å–∫–∞–µ—Ç –º—É–∑—ã–∫—É (–ø–æ—Å–ª–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∂–µ—Å—Ç–∞).
 */
function startMusic(){
  ensureAudio();
  if(audioCtx.state === 'suspended'){
    audioCtx.resume().then(()=>{
      musicPlaying = true; korIndex = 0; playKorStep();
      document.getElementById('musicBtn').textContent = '–í—ã–∫–ª. –º—É–∑—ã–∫—É';
    }).catch(()=>{
      musicPlaying = true; korIndex = 0; playKorStep();
      document.getElementById('musicBtn').textContent = '–í—ã–∫–ª. –º—É–∑—ã–∫—É';
    });
  } else {
    musicPlaying = true; korIndex = 0; playKorStep();
    document.getElementById('musicBtn').textContent = '–í—ã–∫–ª. –º—É–∑—ã–∫—É';
  }
}
function stopMusic(){
  musicPlaying = false;
  if(korTimeout){ clearTimeout(korTimeout); korTimeout = null; }
  document.getElementById('musicBtn').textContent = '–í–∫–ª. –º—É–∑—ã–∫—É';
}

/* Resume audio on first gesture (best-effort) */
function attachOneTimeAudioResume(){
  function resume(){
    try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
    window.removeEventListener('pointerdown', resume);
    window.removeEventListener('keydown', resume);
  }
  window.addEventListener('pointerdown', resume);
  window.addEventListener('keydown', resume);
}
attachOneTimeAudioResume();

/* ===========================
   Input: keyboard + DAS/ARR + touch + remap
   =========================== */

/**
 * handleKeyDownForDAS(key)
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —É–¥–µ—Ä–∂–∞–Ω–∏–µ –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ —Å DAS/ARR.
 */
function handleKeyDownForDAS(key){
  if(key === keymap.left){
    if(dasTimeoutLeft || arrIntervalLeft) return;
    move(-1);
    dasTimeoutLeft = setTimeout(()=>{
      arrIntervalLeft = setInterval(()=>move(-1), Math.max(1, ARR));
    }, DAS);
  }
  if(key === keymap.right){
    if(dasTimeoutRight || arrIntervalRight) return;
    move(1);
    dasTimeoutRight = setTimeout(()=>{
      arrIntervalRight = setInterval(()=>move(1), Math.max(1, ARR));
    }, DAS);
  }
}
function handleKeyUpForDAS(key){
  if(key === keymap.left){
    if(dasTimeoutLeft){ clearTimeout(dasTimeoutLeft); dasTimeoutLeft = null; }
    if(arrIntervalLeft){ clearInterval(arrIntervalLeft); arrIntervalLeft = null; }
  }
  if(key === keymap.right){
    if(dasTimeoutRight){ clearTimeout(dasTimeoutRight); dasTimeoutRight = null; }
    if(arrIntervalRight){ clearInterval(arrIntervalRight); arrIntervalRight = null; }
  }
}

/* Keyboard events */
window.addEventListener('keydown', (e)=>{
  if(isGameOver) return;
  if(e.key === 'p' || e.key === 'P'){ pauseGame(); return; }
  // DAS/ARR
  handleKeyDownForDAS(e.key);

  if(isPaused) return;

  if(e.key === keymap.rotate || e.key.toLowerCase() === 'x'){ rotateCW(); draw(); }
  else if(e.key.toLowerCase() === 'z'){ rotateCCW(); draw(); }
  else if(e.key === keymap.soft){ softDrop(); draw(); }
  else if(e.key === keymap.drop){ e.preventDefault(); hardDrop(); draw(); }
  else if(e.key === keymap.hold){ hold(); draw(); }
});
window.addEventListener('keyup', (e)=>{ handleKeyUpForDAS(e.key); });

/* Touch controls: buttons already exist; also add swipe on canvas */
['t-left','t-right','t-rotate','t-down','t-drop','t-hold'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('click', ()=>{
    if(isGameOver) return;
    if(id === 't-left') move(-1);
    if(id === 't-right') move(1);
    if(id === 't-rotate') rotateCW();
    if(id === 't-down') softDrop();
    if(id === 't-drop') hardDrop();
    if(id === 't-hold') hold();
    draw();
  });
});

/* Canvas touch swipe & hold for soft drop */
let touchStartX = 0, touchStartY = 0, touchStartT = 0, touchHoldTimer = null;
cvs.addEventListener('touchstart', (e)=>{
  const t = e.touches[0];
  touchStartX = t.clientX; touchStartY = t.clientY; touchStartT = Date.now();
  touchHoldTimer = setTimeout(()=>{ touchHoldTimer = setInterval(()=>softDrop(), 120); }, 350);
});
cvs.addEventListener('touchmove', (e)=>{
  const t = e.touches[0];
  const dx = t.clientX - touchStartX, dy = t.clientY - touchStartY;
  if(Math.abs(dx) > 30 && Math.abs(dx) > Math.abs(dy)){
    if(dx < 0) move(-1); else move(1);
    if(touchHoldTimer){ clearTimeout(touchHoldTimer); clearInterval(touchHoldTimer); touchHoldTimer = null; }
    touchStartX = t.clientX;
  }
});
cvs.addEventListener('touchend', (e)=>{
  const dt = Date.now() - touchStartT;
  if(touchHoldTimer){ clearTimeout(touchHoldTimer); clearInterval(touchHoldTimer); touchHoldTimer = null; }
  if(dt < 200) rotateCW();
});

/* Key remap UI */
function startRebind(buttonId, action){
  const btn = document.getElementById(buttonId);
  btn.textContent = '–ù–∞–∂–º–∏—Ç–µ –∫–ª–∞–≤–∏—à—É...';
  function onKey(e){
    e.preventDefault();
    keymap[action] = e.key;
    localStorage.setItem('tetris_keymap', JSON.stringify(keymap));
    btn.textContent = e.key;
    window.removeEventListener('keydown', onKey);
  }
  window.addEventListener('keydown', onKey);
}
function initKeymapUI(){
  const mapping = { 'rebind-left':'left','rebind-right':'right','rebind-rotate':'rotate','rebind-drop':'drop','rebind-hold':'hold','rebind-soft':'soft' };
  Object.keys(mapping).forEach(id=>{
    const action = mapping[id];
    const btn = document.getElementById(id);
    btn.textContent = keymap[action];
    btn.addEventListener('click', ()=>startRebind(id, action));
  });
  const dasInput = document.getElementById('dasInput'), arrInput = document.getElementById('arrInput');
  dasInput.value = DAS; arrInput.value = ARR;
  dasInput.addEventListener('change', ()=>{ DAS = Number(dasInput.value); localStorage.setItem('tetris_das', DAS); });
  arrInput.addEventListener('change', ()=>{ ARR = Number(arrInput.value); localStorage.setItem('tetris_arr', ARR); });
  const musicBtn = document.getElementById('musicBtn');
  musicBtn.textContent = musicPlaying ? '–í—ã–∫–ª. –º—É–∑—ã–∫—É' : '–í–∫–ª. –º—É–∑—ã–∫—É';
  musicBtn.addEventListener('click', ()=>{ if(musicPlaying) stopMusic(); else startMusic(); });
}

/* ===========================
   Fullscreen support
   =========================== */
function isFullscreen(){
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
}
function toggleFullscreen(){
  const el = document.getElementById('game-area');
  if(!isFullscreen()){
    if(el.requestFullscreen) el.requestFullscreen();
    else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    else if(el.mozRequestFullScreen) el.mozRequestFullScreen();
    else if(el.msRequestFullscreen) el.msRequestFullscreen();
  } else {
    if(document.exitFullscreen) document.exitFullscreen();
    else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
    else if(document.mozCancelFullScreen) document.mozCancelFullScreen();
    else if(document.msExitFullscreen) document.msExitFullscreen();
  }
}
['fullscreenchange','webkitfullscreenchange','mozfullscreenchange','msfullscreenchange'].forEach(evt=>{
  document.addEventListener(evt, ()=>{
    setTimeout(()=>{ resizeCanvas(); draw(); }, 50);
    const btn = document.getElementById('fullscreenBtn'); if(btn) btn.textContent = isFullscreen() ? '–í—ã–π—Ç–∏ –∏–∑ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–∞' : '–ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π';
  });
});
const fsBtn = document.getElementById('fullscreenBtn'); if(fsBtn) fsBtn.addEventListener('click', toggleFullscreen);
window.addEventListener('keydown', (e)=>{ if(e.key && e.key.toLowerCase() === 'f'){ e.preventDefault(); toggleFullscreen(); } });

/* ===========================
   Highscores (localStorage)
   =========================== */
function loadHighScores(){ try{ return JSON.parse(localStorage.getItem('tetris_high_scores') || '[]'); }catch(e){ return []; } }
function storeHighScore(record){ const hs = loadHighScores(); hs.push(record); hs.sort((a,b)=>b.score - a.score); if(hs.length > 10) hs.length = 10; localStorage.setItem('tetris_high_scores', JSON.stringify(hs)); }
function renderHighScores(){ const el = document.getElementById('high-scores-list'); el.innerHTML = ''; const hs = loadHighScores(); if(hs.length === 0){ el.innerHTML = '<li class="muted">–ù–µ—Ç —Ä–µ–∫–æ—Ä–¥–æ–≤</li>'; return; } hs.forEach(r=>{ const li = document.createElement('li'); li.textContent = `${r.name} ‚Äî ${r.score}`; el.appendChild(li); }); }

/* ===========================
   Controls bindings + UI
   =========================== */
document.getElementById('startBtn').addEventListener('click', ()=>{ startGame(); document.getElementById('gameOverOverlay').style.display = 'none'; });
document.getElementById('pauseBtn').addEventListener('click', pauseGame);
document.getElementById('resetBtn').addEventListener('click', resetGame);
const goRestart = document.getElementById('go-restart'); if(goRestart) goRestart.addEventListener('click', ()=>{ document.getElementById('gameOverOverlay').style.display='none'; startGame(); });

/* ===========================
   Game state control (start/pause/reset/end)
   =========================== */

/**
 * startGame()
 * –ù–∞—á–∏–Ω–∞–µ—Ç –Ω–æ–≤—É—é –ø–∞—Ä—Ç–∏—é: —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ —Å—Ç–∞—Ä—Ç—É–µ—Ç —Ü–∏–∫–ª.
 */
function startGame(){
  grid = createEmptyGrid(); bag = []; queue = []; holdPiece = null; holdLocked = false;
  score = 0; level = 1; linesCleared = 0; dropInterval = 1000; lastDrop = 0;
  isPaused = false; isGameOver = false;
  fillQueue(); spawnPiece();
  updateUI();
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

/** pauseGame() */
function pauseGame(){
  isPaused = !isPaused;
  document.getElementById('pauseOverlay').style.display = isPaused ? 'flex' : 'none';
  document.getElementById('pauseBtn').textContent = isPaused ? '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å' : '–ü–∞—É–∑–∞';
}

/** endGame() */
function endGame(){
  isGameOver = true;
  document.getElementById('gameOverOverlay').style.display = 'flex';
  document.getElementById('go-score').textContent = '–í–∞—à —Å—á–µ—Ç: ' + score;
  // prompt name
  setTimeout(()=>{ // small delay so overlay renders
    const name = prompt('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –í–≤–µ–¥–∏—Ç–µ –∏–º—è –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤:', '–ò–≥—Ä–æ–∫');
    if(name) storeHighScore({name, score, date: (new Date()).toISOString()});
    updateUI();
  }, 60);
}

/** resetGame() */
function resetGame(){
  grid = createEmptyGrid();
  score = 0; level = 1; linesCleared = 0;
  dropInterval = 1000; bag = []; queue = []; holdPiece = null; isGameOver = false;
  document.getElementById('gameOverOverlay').style.display='none';
  startGame();
}

/* ===========================
   Init
   =========================== */
function init(){
  initKeymapUI();
  fillQueue();
  spawnPiece();
  updateUI();
  draw();
  renderHighScores();
}
init();

</script>
</body>
</html>
