<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PacmanLearn - Обучающая игра</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: #121212;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            transition: background-color 0.3s, color 0.3s;
        }
        
        body.light-theme {
            background: #f5f5f5;
            color: #333;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }
        
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #888;
            font-size: 1.1rem;
            max-width: 600px;
            line-height: 1.5;
        }
        
        .game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 800px;
        }
        
        .status-panel {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        body.light-theme .status-panel {
            background: rgba(255, 255, 255, 0.9);
        }
        
        .score-info {
            display: flex;
            gap: 15px;
            font-size: 1.2rem;
        }
        
        .score-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .score-item .value {
            font-weight: bold;
            color: #FFD700;
        }
        
        body.light-theme .score-item .value {
            color: #D35400;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(to bottom, #3a3a3a, #222);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        body.light-theme button {
            background: linear-gradient(to bottom, #e0e0e0, #cccccc);
            color: #333;
        }
        
        button:hover {
            background: linear-gradient(to bottom, #4a4a4a, #333);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        body.light-theme button:hover {
            background: linear-gradient(to bottom, #d0d0d0, #b0b0b0);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .mode-toggle {
            background: linear-gradient(to bottom, #444, #2c2c2c);
        }
        
        body.light-theme .mode-toggle {
            background: linear-gradient(to bottom, #a0a0a0, #888888);
        }
        
        .game-area {
            display: flex;
            gap: 20px;
            width: 100%;
        }
        
        #game-canvas {
            background: #000;
            border: 2px solid #333;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
        }
        
        body.light-theme #game-canvas {
            background: #f0f0f0;
            border-color: #ccc;
        }
        
        .mini-map-container {
            width: 100px;
            height: 100px;
        }
        
        #mini-map {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            border-radius: 5px;
        }
        
        body.light-theme #mini-map {
            background: rgba(255, 255, 255, 0.7);
            border-color: #ccc;
        }
        
        .debug-panel {
            width: 100%;
            background: rgba(30, 30, 30, 0.8);
            border-radius: 10px;
            padding: 15px;
            font-family: monospace;
            font-size: 0.9rem;
            display: none;
        }
        
        body.light-theme .debug-panel {
            background: rgba(240, 240, 240, 0.9);
        }
        
        .debug-panel h3 {
            margin-bottom: 10px;
            color: #FFD700;
        }
        
        body.light-theme .debug-panel h3 {
            color: #D35400;
        }
        
        .debug-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .debug-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 5px;
        }
        
        body.light-theme .debug-item {
            background: rgba(200, 200, 200, 0.5);
        }
        
        .debug-item strong {
            color: #FFA500;
        }
        
        body.light-theme .debug-item strong {
            color: #E67E22;
        }
        
        .learning-mode {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            max-width: 300px;
            display: none;
            z-index: 10;
        }
        
        body.light-theme .learning-mode {
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
        
        .learning-mode h3 {
            color: #FFD700;
            margin-bottom: 5px;
        }
        
        body.light-theme .learning-mode h3 {
            color: #D35400;
        }
        
        .learning-mode p {
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 20px 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
            max-width: 80%;
            z-index: 20;
        }
        
        body.light-theme .game-over {
            background: rgba(255, 255, 255, 0.95);
        }
        
        .game-over h2 {
            color: #FF6B6B;
            margin-bottom: 15px;
            font-size: 2rem;
        }
        
        body.light-theme .game-over h2 {
            color: #E74C3C;
        }
        
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: #f00;
            animation: confetti-fall 5s ease-in-out forwards;
        }
        
        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        .level-complete {
            color: #4CAF50;
            font-size: 1.5rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 10px;
            display: none;
            z-index: 15;
            animation: fadeOut 2s forwards;
        }
        
        body.light-theme .level-complete {
            background: rgba(255, 255, 255, 0.9);
            color: #27AE60;
        }
        
        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        .sound-visualization {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 2px;
            height: 20px;
        }
        
        .sound-bar {
            width: 3px;
            background: #4CAF50;
            border-radius: 1px;
        }
        
        .music-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #555;
        }
        
        .music-indicator.active {
            background-color: #4CAF50;
            box-shadow: 0 0 5px #4CAF50;
        }
        
        /* Панель учебного режима */
        .lesson-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: none;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            overflow: auto;
        }
        
        body.light-theme .lesson-panel {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
        }
        
        .lesson-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .lesson-title {
            font-size: 1.8rem;
            color: #FFD700;
        }
        
        body.light-theme .lesson-title {
            color: #D35400;
        }
        
        .lesson-close {
            background: #c0392b;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
        }
        
        .lesson-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .lesson-step {
            margin-bottom: 30px;
            padding: 15px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        body.light-theme .lesson-step {
            background: rgba(200, 200, 200, 0.2);
        }
        
        .lesson-step h4 {
            margin-bottom: 10px;
            color: #3498db;
        }
        
        body.light-theme .lesson-step h4 {
            color: #2980b9;
        }
        
        .code-block {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
            margin: 10px 0;
            overflow-x: auto;
            white-space: pre;
        }
        
        body.light-theme .code-block {
            background: rgba(240, 240, 240, 0.7);
        }
        
        .lesson-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .lesson-nav-btn {
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
        }
        
        .lesson-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Редактор уровней */
        .level-editor {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            z-index: 100;
            display: none;
            flex-direction: column;
        }
        
        body.light-theme .level-editor {
            background: #f0f0f0;
        }
        
        .editor-toolbar {
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        body.light-theme .editor-toolbar {
            background: rgba(240, 240, 240, 0.9);
        }
        
        .tool-button {
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .tool-button.active {
            background: #3498db;
            color: white;
        }
        
        body.light-theme .tool-button.active {
            background: #2980b9;
        }
        
        .editor-canvas-container {
            display: flex;
            justify-content: center;
            padding: 20px;
            flex: 1;
        }
        
        #editor-canvas {
            background: #000;
            border: 2px solid #333;
            border-radius: 5px;
        }
        
        body.light-theme #editor-canvas {
            background: #f0f0f0;
            border-color: #ccc;
        }
        
        /* Панель достижений */
        .achievements-panel {
            position: fixed;
            top: 0;
            right: -320px;
            width: 300px;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 90;
            transition: right 0.3s;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        
        body.light-theme .achievements-panel {
            background: rgba(255, 255, 255, 0.95);
        }
        
        .achievements-panel.open {
            right: 0;
        }
        
        .achievements-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .achievements-title {
            font-size: 1.5rem;
            color: #FFD700;
        }
        
        body.light-theme .achievements-title {
            color: #D35400;
        }
        
        .achievements-close {
            background: #c0392b;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
        }
        
        .achievement-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }
        
        body.light-theme .achievement-item {
            background: rgba(200, 200, 200, 0.3);
        }
        
        .achievement-title {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .achievement-earned {
            color: #27ae60;
        }
        
        .achievement-locked {
            color: #7f8c8d;
        }
        
        .achievement-description {
            font-size: 0.9rem;
            color: #bdc3c7;
        }
        
        body.light-theme .achievement-description {
            color: #7f8c8d;
        }
        
        /* Уведомления */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            background: #27ae60;
            color: white;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 100;
            transform: translateY(100px);
            transition: transform 0.3s;
        }
        
        .notification.show {
            transform: translateY(0);
        }
        
        .notification.error {
            background: #c0392b;
        }
        
        /* Виртуальные кнопки для мобильных */
        .virtual-button {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.3);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            z-index: 100;
            touch-action: manipulation;
            user-select: none;
        }
        
        /* Тестирование знаний */
        .test-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 25px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            z-index: 100;
        }
        
        body.light-theme .test-panel {
            background: rgba(255, 255, 255, 0.95);
        }
        
        .test-question {
            font-size: 1.2rem;
            margin: 15px 0;
            line-height: 1.4;
        }
        
        .test-options {
            display: grid;
            gap: 10px;
            margin-top: 20px;
        }
        
        .test-option {
            padding: 12px;
            border-radius: 5px;
            text-align: left;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        body.light-theme .test-option {
            background: rgba(240, 240, 240, 0.7);
            border-color: #ddd;
        }
        
        .test-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        body.light-theme .test-option:hover {
            background: rgba(230, 230, 230, 0.7);
        }
        
        .feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .feedback.success {
            background: rgba(46, 204, 113, 0.2);
            color: #27ae60;
        }
        
        .feedback.error {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }
        
        .test-results {
            text-align: center;
        }
        
        .test-score {
            font-size: 2rem;
            margin: 20px 0;
            color: #3498db;
        }
        
        /* Визуализация алгоритмов */
        .path-visualization {
            position: absolute;
            pointer-events: none;
            z-index: 4;
        }
    </style>
</head>
<body>
    <header>
        <h1>PacmanLearn</h1>
        <p class="subtitle">Обучающая реализация классической игры с оригинальной музыкой и подробными комментариями</p>
    </header>
    
    <div class="game-container">
        <div class="status-panel">
            <div class="score-info">
                <div class="score-item">
                    <span>Счёт:</span>
                    <span id="score" class="value">0</span>
                </div>
                <div class="score-item">
                    <span>Рекорд:</span>
                    <span id="high-score" class="value">0</span>
                </div>
                <div class="score-item">
                    <span>Уровень:</span>
                    <span id="level" class="value">1</span>
                </div>
            </div>
            <div class="status-indicator">
                <span id="game-status" class="value">Игра активна</span>
            </div>
        </div>
        
        <div class="controls">
            <button id="start-btn"><span>▶️</span> Старт/Пауза</button>
            <button id="reset-btn"><span>🔄</span> Новый уровень</button>
            <button id="clear-record-btn"><span>💥</span> Сброс рекорда</button>
            <button id="mode-toggle" class="mode-toggle"><span>🎓</span> Режим обучения: Выкл</button>
            <button id="sound-toggle"><span>🔊</span> Звук: Вкл</button>
            <button id="theme-toggle"><span>🌙</span> Темная тема</button>
            <button id="achievements-btn"><span>🏆</span> Достижения</button>
        </div>
        
        <div class="game-area">
            <canvas id="game-canvas" width="440" height="520"></canvas>
            <div class="mini-map-container">
                <canvas id="mini-map" width="100" height="100"></canvas>
            </div>
        </div>
        
        <div class="sound-visualization" id="sound-visualizer">
            <!-- Динамически генерируемые бары -->
        </div>
        <div class="music-indicator" id="music-indicator"></div>
        
        <div class="learning-mode" id="learning-mode">
            <h3>Пояснение к коду</h3>
            <p id="learning-content">Нажмите на элемент игры, чтобы увидеть объяснение соответствующей части кода</p>
        </div>
        
        <div class="debug-panel" id="debug-panel">
            <h3>Режим отладки</h3>
            <div class="debug-content">
                <div class="debug-item">
                    <strong>Позиция Пакмана:</strong> <span id="debug-pos">10, 15</span>
                </div>
                <div class="debug-item">
                    <strong>Направление:</strong> <span id="debug-dir">right</span>
                </div>
                <div class="debug-item">
                    <strong>Скорость:</strong> <span id="debug-speed">200 мс</span>
                </div>
                <div class="debug-item">
                    <strong>Супер-еда:</strong> <span id="debug-power">Не активна</span>
                </div>
            </div>
        </div>
        
        <div class="game-over" id="game-over">
            <h2>Игра окончена!</h2>
            <p>Ваш счёт: <span id="final-score" class="value">0</span></p>
            <button id="restart-btn" style="margin-top: 15px;">Начать заново</button>
        </div>
        
        <div class="level-complete" id="level-complete">
            Уровень пройден!
        </div>
    </div>

    <!-- Панель учебного режима -->
    <div class="lesson-panel" id="lesson-panel">
        <div class="lesson-header">
            <h2 class="lesson-title" id="lesson-title">Название урока</h2>
            <button class="lesson-close" id="lesson-close">×</button>
        </div>
        <div class="lesson-content" id="lesson-content">
            <!-- Содержимое урока будет загружено здесь -->
        </div>
        <div class="lesson-controls">
            <button class="lesson-nav-btn" id="lesson-prev">Назад</button>
            <button class="lesson-nav-btn" id="lesson-next">Далее</button>
        </div>
    </div>

    <!-- Редактор уровней -->
    <div class="level-editor" id="level-editor">
        <div class="editor-toolbar">
            <button class="tool-button active" data-tool="wall">Стена</button>
            <button class="tool-button" data-tool="path">Путь</button>
            <button class="tool-button" data-tool="food">Еда</button>
            <button class="tool-button" data-tool="super-food">Супер-еда</button>
            <button class="tool-button" data-tool="pacman">Пакман</button>
            <button class="tool-button" data-tool="ghost">Привидение</button>
            <div style="flex-grow: 1;"></div>
            <button id="save-level" class="tool-button"><span>💾</span> Сохранить</button>
            <button id="cancel-edit" class="tool-button"><span>❌</span> Отмена</button>
            <button id="load-level" class="tool-button"><span>📂</span> Загрузить</button>
            <input type="file" id="level-file-input" style="display: none;" accept=".json">
        </div>
        <div class="editor-canvas-container">
            <canvas id="editor-canvas" width="400" height="400"></canvas>
        </div>
    </div>

    <!-- Панель достижений -->
    <div class="achievements-panel" id="achievements-panel">
        <div class="achievements-header">
            <h2 class="achievements-title">Достижения</h2>
            <button class="achievements-close" id="achievements-close">×</button>
        </div>
        <div id="achievements-list">
            <!-- Достижения будут загружены здесь -->
        </div>
    </div>

    <!-- Уведомления -->
    <div class="notification" id="notification"></div>

    <!-- Тестирование знаний -->
    <div class="test-panel" id="test-panel" style="display: none;">
        <h3 id="test-title">Название теста</h3>
        <p id="test-question-count"></p>
        <p class="test-question" id="test-question">Вопрос</p>
        <div class="test-options" id="test-options">
            <!-- Варианты ответов будут загружены здесь -->
        </div>
        <div class="feedback" id="test-feedback" style="display: none;"></div>
    </div>

    <script>
        /**
         * Основной класс игры PacmanLearn
         * @class PacmanGame
         * @description Обучающая реализация классической игры с подробными комментариями
         *              для изучения основ 2D-геймдева на JavaScript
         */
        class PacmanGame {
            /**
             * Создает экземпляр игры и инициализирует все компоненты
             * @constructor
             */
            constructor() {
                // Инициализация базовых параметров
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.cellSize = 22; // Размер ячейки в пикселях
                this.gameSpeed = 200; // Базовая скорость игры (мс)
                this.gameLoopId = null;
                this.isRunning = false;
                this.isLearningMode = false;
                this.isSoundEnabled = true;
                this.currentLevel = 1;
                this.lastTimestamp = 0;
                this.animationFrameId = null;
                this.soundVisualizer = document.getElementById('sound-visualizer');
                this.musicIndicator = document.getElementById('music-indicator');
                
                // Инициализация игровых объектов
                this.pacman = {
                    x: 10, 
                    y: 15, 
                    direction: 'right', 
                    nextDirection: null,
                    mouthAngle: 0,
                    mouthOpening: 0.1,
                    lastEatTime: 0,
                    eatInterval: 150 // Минимальное время между звуками поедания
                };
                
                this.ghost = {
                    x: 10,
                    y: 8,
                    direction: 'left',
                    mode: 'wandering', // wandering, chasing, fleeing
                    speed: 0.8,
                    color: 'red',
                    fearTimer: null
                };
                
                // Инициализация игрового состояния
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('pacmanHighScore') || '0', 10);
                this.powerMode = false;
                this.powerModeTimer = null;
                this.powerModeStart = 0;
                this.foodCount = 0;
                this.totalFood = 0; // Общее количество еды на уровне
                this.particles = [];
                this.activeSounds = new Set();
                this.musicPlaying = false;
                this.musicTimeout = null;
                
                // Инициализация мини-карты
                this.miniMapCanvas = document.getElementById('mini-map');
                this.miniMapCtx = this.miniMapCanvas.getContext('2d');
                this.miniMapScale = 1;
                
                // Инициализация визуализации звука
                this.setupSoundVisualizer();
                
                // Инициализация дополнительных компонентов
                this.isDarkTheme = true;
                this.currentLesson = null;
                this.currentLessonStep = 0;
                this.currentTest = null;
                this.currentQuestion = 0;
                this.testScore = 0;
                this.codeModified = false;
                
                // Загрузка сохраненного прогресса
                this.loadProgress();
                
                // Настройка обработчиков событий
                this.setupEventListeners();
                
                // Загрузка уровней
                this.levels = this.loadLevels();
                this.currentMap = this.cloneMap(this.levels[0]);
                this.countTotalFood();
                
                // Обновление интерфейса
                this.updateUI();
                
                // Загрузка звуковых эффектов
                this.audioContext = null;
                this.sounds = this.loadSounds();
                
                // Инициализация учебных материалов
                this.lessons = this.loadLessons();
                this.achievements = this.loadAchievements();
                this.tests = this.loadTests();
                
                // Инициализация дополнительных UI-компонентов
                this.initUIComponents();
                
                // Запуск основного игрового цикла
                this.startGameLoop();
            }
            
            /**
             * Настраивает визуализацию звука
             */
            setupSoundVisualizer() {
                // Создаем 8 баров для визуализации
                for (let i = 0; i < 8; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'sound-bar';
                    bar.style.height = '5px';
                    this.soundVisualizer.appendChild(bar);
                }
            }
            
            /**
             * Обновляет визуализацию звука
             */
            updateSoundVisualization() {
                const bars = this.soundVisualizer.querySelectorAll('.sound-bar');
                const activeCount = this.activeSounds.size;
                
                bars.forEach((bar, index) => {
                    const height = index < activeCount ? `${Math.min(20, 5 + activeCount * 2)}px` : '5px';
                    bar.style.height = height;
                    bar.style.backgroundColor = activeCount > 0 ? '#4CAF50' : '#555';
                });
                
                // Обновляем индикатор музыки
                this.musicIndicator.classList.toggle('active', this.musicPlaying);
            }
            
            /**
             * Создает аудио контекст, если он еще не создан
             */
            setupAudioContext() {
                if (!this.audioContext) {
                    try {
                        window.AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.audioContext = new AudioContext();
                    } catch (e) {
                        console.error('Web Audio API не поддерживается в этом браузере', e);
                    }
                }
            }
            
            /**
             * Загружает звуковые эффекты для игры
             * @returns {Object} Объект с аудио-ресурсами
             */
            loadSounds() {
                this.setupAudioContext();
                
                return {
                    // Основная игровая музыка Pacman
                    music: {
                        play: (game) => {
                            // Останавливаем текущую музыку, чтобы избежать наложения
                            game.sounds.music.stop(game);
                            
                            if (!game.isSoundEnabled || !game.audioContext) return;
                            
                            game.musicPlaying = true;
                            game.updateSoundVisualization();
                            
                            // Создаем осциллятор для воспроизведения оригинальной мелодии Pacman
                            const playNote = (frequency, duration, startTime) => {
                                const oscillator = game.audioContext.createOscillator();
                                const gainNode = game.audioContext.createGain();
                                
                                oscillator.connect(gainNode);
                                gainNode.connect(game.audioContext.destination);
                                
                                oscillator.type = 'square';
                                oscillator.frequency.value = frequency;
                                
                                gainNode.gain.setValueAtTime(0.1, startTime);
                                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                                
                                oscillator.start(startTime);
                                oscillator.stop(startTime + duration);
                            };
                            
                            // Воспроизводим мелодию Pacman
                            const startTime = game.audioContext.currentTime;
                            const sequence = [
                                { freq: 440, dur: 0.15 }, { freq: 349, dur: 0.15 }, { freq: 392, dur: 0.15 }, { freq: 440, dur: 0.15 },
                                { freq: 349, dur: 0.15 }, { freq: 392, dur: 0.15 }, { freq: 440, dur: 0.15 }, { freq: 349, dur: 0.45 },
                                { freq: 392, dur: 0.15 }, { freq: 440, dur: 0.15 }, { freq: 494, dur: 0.15 }, { freq: 440, dur: 0.15 },
                                { freq: 392, dur: 0.15 }, { freq: 349, dur: 0.15 }, { freq: 330, dur: 0.15 }, { freq: 349, dur: 0.45 }
                            ];
                            
                            const totalDuration = sequence.reduce((sum, note) => sum + note.dur, 0) * 1000 + 500;
                            
                            sequence.forEach((note, i) => {
                                playNote(note.freq, note.dur, startTime + i * 0.2);
                            });
                            
                            // Планируем следующее воспроизведение через паузу
                            game.musicTimeout = setTimeout(() => {
                                game.musicTimeout = null;
                                if (game.isRunning && game.isSoundEnabled) {
                                    game.sounds.music.play(game);
                                } else {
                                    game.musicPlaying = false;
                                    game.updateSoundVisualization();
                                }
                            }, totalDuration);
                        },
                        stop: (game) => {
                            // Очищаем предыдущий таймаут
                            if (game.musicTimeout) {
                                clearTimeout(game.musicTimeout);
                                game.musicTimeout = null;
                            }
                            
                            game.musicPlaying = false;
                            game.updateSoundVisualization();
                        }
                    },
                    
                    // Звук сбора обычной еды
                    eat: {
                        play: (game) => {
                            if (!game.isSoundEnabled || !game.audioContext || 
                                (Date.now() - game.pacman.lastEatTime) < game.pacman.eatInterval) return;
                            
                            game.activeSounds.add('eat');
                            game.updateSoundVisualization();
                            
                            const startTime = game.audioContext.currentTime;
                            const oscillator = game.audioContext.createOscillator();
                            const gainNode = game.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(game.audioContext.destination);
                            
                            oscillator.type = 'square';
                            oscillator.frequency.value = 440;
                            
                            gainNode.gain.setValueAtTime(0.05, startTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.1);
                            
                            oscillator.start(startTime);
                            oscillator.stop(startTime + 0.1);
                            
                            game.pacman.lastEatTime = Date.now();
                            
                            // Удаляем звук из активных после завершения
                            setTimeout(() => {
                                game.activeSounds.delete('eat');
                                game.updateSoundVisualization();
                            }, 100);
                        }
                    },
                    
                    // Звук сбора супер-еды
                    power: {
                        play: (game) => {
                            if (!game.isSoundEnabled || !game.audioContext) return;
                            
                            game.activeSounds.add('power');
                            game.updateSoundVisualization();
                            
                            const startTime = game.audioContext.currentTime;
                            const oscillator = game.audioContext.createOscillator();
                            const gainNode = game.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(game.audioContext.destination);
                            
                            oscillator.type = 'sine';
                            oscillator.frequency.value = 220;
                            
                            gainNode.gain.setValueAtTime(0.1, startTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);
                            
                            oscillator.start(startTime);
                            oscillator.stop(startTime + 0.5);
                            
                            // Удаляем звук из активных после завершения
                            setTimeout(() => {
                                game.activeSounds.delete('power');
                                game.updateSoundVisualization();
                            }, 500);
                        }
                    },
                    
                    // Звук смерти Пакмана
                    death: {
                        play: (game) => {
                            if (!game.isSoundEnabled || !game.audioContext) return;
                            
                            game.activeSounds.add('death');
                            game.updateSoundVisualization();
                            
                            const startTime = game.audioContext.currentTime;
                            const oscillator = game.audioContext.createOscillator();
                            const gainNode = game.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(game.audioContext.destination);
                            
                            oscillator.type = 'sawtooth';
                            oscillator.frequency.value = 300;
                            
                            gainNode.gain.setValueAtTime(0.1, startTime);
                            gainNode.gain.linearRampToValueAtTime(0, startTime + 1.5);
                            
                            oscillator.start(startTime);
                            oscillator.stop(startTime + 1.5);
                            
                            // Удаляем звук из активных после завершения
                            setTimeout(() => {
                                game.activeSounds.delete('death');
                                game.updateSoundVisualization();
                            }, 1500);
                        }
                    }
                };
            }
            
            /**
             * Проигрывает звуковой эффект, если звук включен
             * @param {string} soundName - Название звука из this.sounds
             */
            playSound(soundName) {
                if (this.isSoundEnabled && this.sounds[soundName]) {
                    this.sounds[soundName].play(this);
                }
            }
            
            /**
             * Загружает конфигурации уровней с подробными комментариями
             * @returns {Array} Массив карт уровней
             */
            loadLevels() {
                return [
                    // Уровень 1: Классическая карта Pacman
                    // Симметричная структура с четкими проходами
                    // Особенности: 
                    // - Центральная зона для тактики с супер-едой
                    // - Угловые зоны для укрытия
                    // - Равномерное распределение обычной и супер-еды
                    [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0],
                        [0,2,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,2,0],
                        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0],
                        [0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0],
                        [0,0,0,0,1,0,0,0,2,0,2,0,0,0,1,0,0,0,0,0],
                        [0,0,0,0,1,0,2,0,0,2,0,0,2,0,1,0,0,0,0,0],
                        [0,0,0,0,1,0,0,0,2,0,2,0,0,0,1,0,0,0,0,0],
                        [0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0],
                        [0,3,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,3,1,0],
                        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ],
                    // Уровень 2: Усложненная структура
                    // Особенности:
                    // - Меньше прямых проходов
                    // - Узкие коридоры для тактических решений
                    // - Асимметричное расположение еды
                    [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0,1,0],
                        [0,1,0,0,1,0,1,1,1,0,0,1,1,1,0,1,0,0,1,0],
                        [0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],
                        [0,1,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0,1,0],
                        [0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0],
                        [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
                        [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
                        [0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0,1,0],
                        [0,1,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0],
                        [0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],
                        [0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,1,1,1,0,0,1,1,1,0,1,0,0,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0,1,0],
                        [0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ],
                    // Уровень 3: Лабиринт с перекрестками
                    // Особенности:
                    // - Сетка с множеством перекрестков
                    // - Четыре зоны с супер-едой
                    // - Сложные маршруты для тактики
                    [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,0,1,0,1,1,0,1,0,0,0,0,0,1,0],
                        [0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,1,0],
                        [0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,1,0],
                        [0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,1,1,1,1,0],
                        [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
                        [0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,0],
                        [0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,0],
                        [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
                        [0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,1,1,1,1,0],
                        [0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,1,0],
                        [0,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,1,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0],
                        [0,1,0,0,1,0,0,1,0,1,1,0,1,0,0,0,0,0,1,0],
                        [0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ],
                    // Уровень 4: Высокая сложность
                    // Особенности:
                    // - Минимум пространства для маневра
                    // - Много тупиков
                    // - Сложные маршруты к супер-еде
                    [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0],
                        [0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,0],
                        [0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0],
                        [0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0],
                        [0,0,1,0,0,1,1,1,0,1,1,0,1,1,1,0,1,0,0,0],
                        [0,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,1,0],
                        [0,1,0,0,0,1,0,1,0,0,0,0,1,0,1,0,0,0,1,0],
                        [0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,0],
                        [0,0,0,1,0,1,0,0,0,2,2,0,0,0,1,0,1,0,0,0],
                        [0,0,0,1,0,1,0,0,2,3,3,2,0,0,1,0,1,0,0,0],
                        [0,0,0,1,0,1,0,0,0,2,2,0,0,0,1,0,1,0,0,0],
                        [0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,0],
                        [0,1,0,0,0,1,0,1,0,0,0,0,1,0,1,0,0,0,1,0],
                        [0,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,1,0],
                        [0,0,1,0,0,1,1,1,0,1,1,0,1,1,1,0,1,0,0,0],
                        [0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0],
                        [0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0],
                        [0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,0],
                        [0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0]
                    ]
                ];
            }
            
            /**
             * Создает глубокую копию карты уровня
             * @param {Array} map - Исходная карта уровня
             * @returns {Array} Копия карты
             */
            cloneMap(map) {
                return map.map(row => [...row]);
            }
            
            /**
             * Подсчитывает общее количество еды на уровне
             */
            countTotalFood() {
                this.totalFood = 0;
                for (let y = 0; y < this.currentMap.length; y++) {
                    for (let x = 0; x < this.currentMap[y].length; x++) {
                        if (this.currentMap[y][x] === 2 || this.currentMap[y][x] === 3) {
                            this.totalFood++;
                        }
                    }
                }
                this.foodCount = this.totalFood;
            }
            
            /**
             * Настраивает обработчики событий для интерфейса и управления
             */
            setupEventListeners() {
                // Кнопки управления
                document.getElementById('start-btn').addEventListener('click', () => this.toggleGame());
                document.getElementById('reset-btn').addEventListener('click', () => this.resetLevel());
                document.getElementById('clear-record-btn').addEventListener('click', () => this.clearHighScore());
                document.getElementById('mode-toggle').addEventListener('click', () => this.toggleLearningMode());
                document.getElementById('sound-toggle').addEventListener('click', () => this.toggleSound());
                document.getElementById('restart-btn').addEventListener('click', () => this.restartGame());
                document.getElementById('theme-toggle').addEventListener('click', () => this.toggleTheme());
                document.getElementById('achievements-btn').addEventListener('click', () => this.toggleAchievementsPanel());
                
                // Управление клавиатурой
                document.addEventListener('keydown', (e) => this.handleKey(e));
                
                // Обучение: клик по элементам
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                
                // Обработка изменения размера окна
                window.addEventListener('resize', () => this.updateMiniMap());
                
                // Настройка учебного режима
                document.getElementById('lesson-close').addEventListener('click', () => this.closeLesson());
                document.getElementById('lesson-prev').addEventListener('click', () => this.previousLessonStep());
                document.getElementById('lesson-next').addEventListener('click', () => this.nextLessonStep());
                
                // Настройка редактора уровней
                document.getElementById('cancel-edit').addEventListener('click', () => this.closeLevelEditor());
                document.getElementById('save-level').addEventListener('click', () => this.saveEditedLevel());
                document.getElementById('load-level').addEventListener('click', () => {
                    document.getElementById('level-file-input').click();
                });
                
                document.getElementById('level-file-input').addEventListener('change', (e) => {
                    this.loadLevelFromFile(e.target.files[0]);
                    e.target.value = ''; // Сбрасываем значение для возможности повторной загрузки того же файла
                });
                
                // Настройка достижений
                document.getElementById('achievements-close').addEventListener('click', () => this.closeAchievementsPanel());
                
                // Настройка тестирования
                document.getElementById('test-panel').addEventListener('click', (e) => {
                    if (e.target.classList.contains('test-option')) {
                        this.checkAnswer(parseInt(e.target.dataset.index));
                    }
                });
                
                // Настройка сенсорного управления для мобильных устройств
                this.setupTouchControls();
                
                // Настройка консоли разработчика
                this.setupDevConsole();
            }
            
            /**
             * Настраивает сенсорное управление
             */
            setupTouchControls() {
                const canvas = this.canvas;
                let touchStartX = 0;
                let touchStartY = 0;
                
                canvas.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    e.preventDefault();
                }, { passive: false });
                
                canvas.addEventListener('touchend', (e) => {
                    if (!this.isRunning) return;
                    
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    
                    const dx = touchEndX - touchStartX;
                    const dy = touchEndY - touchStartY;
                    
                    // Определяем направление по наибольшему смещению
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 30) {
                            this.pacman.nextDirection = 'right';
                        } else if (dx < -30) {
                            this.pacman.nextDirection = 'left';
                        }
                    } else {
                        if (dy > 30) {
                            this.pacman.nextDirection = 'down';
                        } else if (dy < -30) {
                            this.pacman.nextDirection = 'up';
                        }
                    }
                    
                    e.preventDefault();
                }, { passive: false });
                
                // Добавляем виртуальные кнопки для мобильных устройств
                if (/Android|iPhone|iPad/i.test(navigator.userAgent)) {
                    this.addVirtualButtons();
                }
            }
            
            /**
             * Добавляет виртуальные кнопки для мобильных устройств
             */
            addVirtualButtons() {
                const buttonSize = 60;
                const controls = [
                    { id: 'btn-up', x: window.innerWidth/2, y: 20, label: '↑' },
                    { id: 'btn-left', x: 20, y: window.innerHeight/2, label: '←' },
                    { id: 'btn-down', x: window.innerWidth/2, y: window.innerHeight - 20, label: '↓' },
                    { id: 'btn-right', x: window.innerWidth - 20, y: window.innerHeight/2, label: '→' }
                ];
                
                controls.forEach(control => {
                    const btn = document.createElement('div');
                    btn.id = control.id;
                    btn.className = 'virtual-button';
                    btn.textContent = control.label;
                    btn.style.cssText = `
                        position: fixed;
                        width: ${buttonSize}px;
                        height: ${buttonSize}px;
                        border-radius: 50%;
                        background: rgba(255, 215, 0, 0.3);
                        color: white;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 24px;
                        font-weight: bold;
                        bottom: ${window.innerHeight - control.y}px;
                        left: ${control.x}px;
                        transform: translate(-50%, -50%);
                        z-index: 100;
                        touch-action: manipulation;
                    `;
                    
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        switch(control.id) {
                            case 'btn-up': this.pacman.nextDirection = 'up'; break;
                            case 'btn-down': this.pacman.nextDirection = 'down'; break;
                            case 'btn-left': this.pacman.nextDirection = 'left'; break;
                            case 'btn-right': this.pacman.nextDirection = 'right'; break;
                        }
                    });
                    
                    document.body.appendChild(btn);
                });
            }
            
            /**
             * Настраивает консоль разработчика
             */
            setupDevConsole() {
                window.game = {
                    /**
                     * Увеличивает скорость игры
                     * @param {number} [amount=20] - На сколько уменьшить задержку
                     */
                    increaseSpeed: (amount = 20) => {
                        this.gameSpeed = Math.max(50, this.gameSpeed - amount);
                        this.codeModified = true;
                        this.checkAchievements();
                        this.showNotification('Скорость игры увеличена!');
                    },
                    
                    /**
                     * Добавляет новое привидение
                     */
                    addGhost: () => {
                        // Создаем новое привидение
                        this.ghosts = this.ghosts || [this.ghost];
                        this.ghosts.push({
                            x: 10,
                            y: 8,
                            direction: 'left',
                            mode: 'wandering',
                            speed: 0.8,
                            color: this.ghosts.length % 2 === 0 ? 'pink' : 'purple'
                        });
                        
                        this.codeModified = true;
                        this.checkAchievements();
                        this.showNotification('Добавлено новое привидение!');
                    },
                    
                    /**
                     * Телепортирует Пакмана в указанную позицию
                     * @param {number} x - Координата X
                     * @param {number} y - Координата Y
                     */
                    teleport: (x, y) => {
                        this.pacman.x = x;
                        this.pacman.y = y;
                        this.codeModified = true;
                        this.checkAchievements();
                        this.showNotification(`Пакман телепортирован в (${x}, ${y})`);
                    },
                    
                    /**
                     * Включает визуализацию алгоритмов
                     */
                    enablePathVisualization: () => {
                        this.isVisualizingPath = true;
                        this.showNotification('Визуализация алгоритмов включена');
                    },
                    
                    /**
                     * Отключает визуализацию алгоритмов
                     */
                    disablePathVisualization: () => {
                        this.isVisualizingPath = false;
                        this.showNotification('Визуализация алгоритмов выключена');
                    }
                };
            }
            
            /**
             * Переключает тему (темная/светлая)
             */
            toggleTheme() {
                this.isDarkTheme = !this.isDarkTheme;
                document.body.classList.toggle('dark-theme', this.isDarkTheme);
                document.body.classList.toggle('light-theme', !this.isDarkTheme);
                
                // Сохраняем выбор темы
                localStorage.setItem('pacmanTheme', this.isDarkTheme ? 'dark' : 'light');
                
                // Обновляем интерфейс
                const themeButton = document.getElementById('theme-toggle');
                themeButton.innerHTML = `<span>${this.isDarkTheme ? '🌙' : '☀️'}</span> ${this.isDarkTheme ? 'Темная' : 'Светлая'} тема`;
            }
            
            /**
             * Инициализирует дополнительные UI-компоненты
             */
            initUIComponents() {
                // Устанавливаем тему
                this.initTheme();
                
                // Инициализируем редактор уровней
                this.initLevelEditor();
                
                // Инициализируем систему достижений
                this.initAchievements();
                
                // Отображаем достижения
                this.renderAchievements();
            }
            
            /**
             * Инициализирует тему
             */
            initTheme() {
                const savedTheme = localStorage.getItem('pacmanTheme');
                this.isDarkTheme = savedTheme === 'dark' || 
                                  (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches);
                
                document.body.classList.add(this.isDarkTheme ? 'dark-theme' : 'light-theme');
                
                // Обновляем кнопку темы
                const themeButton = document.getElementById('theme-toggle');
                themeButton.innerHTML = `<span>${this.isDarkTheme ? '🌙' : '☀️'}</span> ${this.isDarkTheme ? 'Темная' : 'Светлая'} тема`;
            }
            
            /**
             * Инициализирует редактор уровней
             */
            initLevelEditor() {
                this.editorCanvas = document.getElementById('editor-canvas');
                this.editorCtx = this.editorCanvas.getContext('2d');
                this.currentTool = 'wall';
                
                // Настройка обработчиков для редактора
                this.editorCanvas.addEventListener('mousedown', (e) => this.handleEditorMouseDown(e));
                this.editorCanvas.addEventListener('mousemove', (e) => this.handleEditorMouseMove(e));
                this.editorCanvas.addEventListener('mouseup', () => this.isDrawing = false);
                this.editorCanvas.addEventListener('mouseleave', () => this.isDrawing = false);
                
                // Настройка выбора инструментов
                document.querySelectorAll('.tool-button').forEach(button => {
                    button.addEventListener('click', () => {
                        document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                        button.classList.add('active');
                        this.currentTool = button.dataset.tool;
                    });
                });
                
                // Инициализируем карту редактора
                this.editorMap = this.cloneMap(this.levels[0]);
                this.drawEditorMap();
            }
            
            /**
             * Обрабатывает нажатие мыши в редакторе уровней
             * @param {MouseEvent} e - Событие мыши
             */
            handleEditorMouseDown(e) {
                this.isDrawing = true;
                this.updateEditorCell(e);
            }
            
            /**
             * Обрабатывает движение мыши в редакторе уровней
             * @param {MouseEvent} e - Событие мыши
             */
            handleEditorMouseMove(e) {
                if (this.isDrawing) {
                    this.updateEditorCell(e);
                }
            }
            
            /**
             * Обновляет ячейку в редакторе уровней
             * @param {MouseEvent} e - Событие мыши
             */
            updateEditorCell(e) {
                const rect = this.editorCanvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / this.cellSize);
                const y = Math.floor((e.clientY - rect.top) / this.cellSize);
                
                if (x >= 0 && x < this.editorMap[0].length && y >= 0 && y < this.editorMap.length) {
                    switch(this.currentTool) {
                        case 'wall':
                            this.editorMap[y][x] = 0;
                            break;
                        case 'path':
                            this.editorMap[y][x] = 1;
                            break;
                        case 'food':
                            this.editorMap[y][x] = 2;
                            break;
                        case 'super-food':
                            this.editorMap[y][x] = 3;
                            break;
                        case 'pacman':
                            // Сначала очищаем предыдущую позицию Пакмана
                            for (let i = 0; i < this.editorMap.length; i++) {
                                for (let j = 0; j < this.editorMap[i].length; j++) {
                                    if (this.editorMap[i][j] === 4) {
                                        this.editorMap[i][j] = 1;
                                    }
                                }
                            }
                            this.editorMap[y][x] = 4;
                            break;
                        case 'ghost':
                            // Сначала очищаем предыдущую позицию привидения
                            for (let i = 0; i < this.editorMap.length; i++) {
                                for (let j = 0; j < this.editorMap[i].length; j++) {
                                    if (this.editorMap[i][j] === 5) {
                                        this.editorMap[i][j] = 1;
                                    }
                                }
                            }
                            this.editorMap[y][x] = 5;
                            break;
                    }
                    this.drawEditorMap();
                }
            }
            
            /**
             * Отрисовывает карту в редакторе уровней
             */
            drawEditorMap() {
                const mapHeight = this.editorMap.length;
                const mapWidth = this.editorMap[0].length;
                
                // Очистка холста
                this.editorCtx.fillStyle = 'black';
                this.editorCtx.fillRect(0, 0, this.editorCanvas.width, this.editorCanvas.height);
                
                for (let y = 0; y < mapHeight; y++) {
                    for (let x = 0; x < mapWidth; x++) {
                        const cell = this.editorMap[y][x];
                        
                        // Стены
                        if (cell === 0) {
                            this.editorCtx.fillStyle = 'blue';
                            this.editorCtx.fillRect(
                                x * this.cellSize, 
                                y * this.cellSize, 
                                this.cellSize, 
                                this.cellSize
                            );
                        } 
                        // Путь
                        else if (cell === 1) {
                            this.editorCtx.fillStyle = 'black';
                            this.editorCtx.fillRect(
                                x * this.cellSize, 
                                y * this.cellSize, 
                                this.cellSize, 
                                this.cellSize
                            );
                        } 
                        // Обычная еда
                        else if (cell === 2) {
                            this.editorCtx.fillStyle = 'white';
                            this.editorCtx.beginPath();
                            this.editorCtx.arc(
                                x * this.cellSize + this.cellSize/2,
                                y * this.cellSize + this.cellSize/2,
                                2, 0, Math.PI * 2
                            );
                            this.editorCtx.fill();
                        } 
                        // Супер-еда
                        else if (cell === 3) {
                            this.editorCtx.fillStyle = '#FFD700';
                            this.editorCtx.beginPath();
                            this.editorCtx.arc(
                                x * this.cellSize + this.cellSize/2,
                                y * this.cellSize + this.cellSize/2,
                                5, 0, Math.PI * 2
                            );
                            this.editorCtx.fill();
                        }
                        // Пакман
                        else if (cell === 4) {
                            this.editorCtx.fillStyle = 'yellow';
                            this.editorCtx.beginPath();
                            this.editorCtx.arc(
                                x * this.cellSize + this.cellSize/2,
                                y * this.cellSize + this.cellSize/2,
                                this.cellSize/2 - 2, 0, Math.PI * 1.8
                            );
                            this.editorCtx.lineTo(
                                x * this.cellSize + this.cellSize/2,
                                y * this.cellSize + this.cellSize/2
                            );
                            this.editorCtx.fill();
                        }
                        // Привидение
                        else if (cell === 5) {
                            this.editorCtx.fillStyle = 'red';
                            this.editorCtx.fillRect(
                                x * this.cellSize,
                                y * this.cellSize,
                                this.cellSize, this.cellSize
                            );
                        }
                    }
                }
            }
            
            /**
             * Сохраняет отредактированный уровень
             */
            saveEditedLevel() {
                // Преобразуем карту редактора в формат уровня
                const levelMap = this.editorMap.map(row => {
                    return row.map(cell => {
                        // Преобразуем специальные ячейки в обычный формат
                        if (cell === 4) return 1; // Пакман
                        if (cell === 5) return 1; // Привидение
                        return cell;
                    });
                });
                
                // Добавляем уровень в массив уровней
                this.levels.push(levelMap);
                this.currentLevel = this.levels.length;
                
                // Закрываем редактор и начинаем новый уровень
                this.closeLevelEditor();
                this.resetGameState();
                this.resumeGame();
                
                this.showNotification('Уровень сохранен и загружен!');
            }
            
            /**
             * Загружает уровень из файла
             * @param {File} file - Файл уровня
             */
            loadLevelFromFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const levelData = JSON.parse(e.target.result);
                        
                        // Проверяем формат файла
                        if (levelData.version === '1.0' && Array.isArray(levelData.map)) {
                            this.levels.push(levelData.map);
                            this.currentLevel = this.levels.length;
                            this.closeLevelEditor();
                            this.resetGameState();
                            this.resumeGame();
                            this.showNotification('Уровень успешно загружен!');
                        } else {
                            this.showNotification('Некорректный формат файла уровня', 'error');
                        }
                    } catch (error) {
                        this.showNotification('Ошибка загрузки файла уровня', 'error');
                    }
                };
                reader.readAsText(file);
            }
            
            /**
             * Закрывает редактор уровней
             */
            closeLevelEditor() {
                document.getElementById('level-editor').style.display = 'none';
            }
            
            /**
             * Открывает редактор уровней
             */
            openLevelEditor() {
                // Копируем текущий уровень в редактор
                this.editorMap = this.cloneMap(this.currentMap);
                this.drawEditorMap();
                
                document.getElementById('level-editor').style.display = 'flex';
            }
            
            /**
             * Переключает режим обучения
             */
            toggleLearningMode() {
                this.isLearningMode = !this.isLearningMode;
                const button = document.getElementById('mode-toggle');
                const learningPanel = document.getElementById('learning-mode');
                
                if (this.isLearningMode) {
                    button.innerHTML = '<span>🎓</span> Режим обучения: Вкл';
                    learningPanel.style.display = 'block';
                    document.getElementById('debug-panel').style.display = 'block';
                } else {
                    button.innerHTML = '<span>🎓</span> Режим обучения: Выкл';
                    learningPanel.style.display = 'none';
                    document.getElementById('debug-panel').style.display = 'none';
                }
            }
            
            /**
             * Переключает звук
             */
            toggleSound() {
                this.isSoundEnabled = !this.isSoundEnabled;
                const button = document.getElementById('sound-toggle');
                button.innerHTML = `<span>${this.isSoundEnabled ? '🔊' : '🔇'}</span> Звук: ${this.isSoundEnabled ? 'Вкл' : 'Выкл'}`;
                
                // Останавливаем текущую музыку при отключении
                if (!this.isSoundEnabled) {
                    this.sounds.music.stop(this);
                } 
                // Запускаем музыку при включении, если игра активна
                else if (this.isRunning) {
                    this.sounds.music.play(this);
                }
            }
            
            /**
             * Обрабатывает нажатие клавиш для управления Пакманом
             * @param {KeyboardEvent} e - Событие нажатия клавиши
             */
            handleKey(e) {
                if (!this.isRunning) return;
                
                // Сохраняем направление для последующего применения
                switch(e.key) {
                    case 'ArrowUp':
                        this.pacman.nextDirection = 'up';
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        this.pacman.nextDirection = 'down';
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        this.pacman.nextDirection = 'left';
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        this.pacman.nextDirection = 'right';
                        e.preventDefault();
                        break;
                    case 'l':
                        if (e.ctrlKey) {
                            this.openLesson(1);
                            e.preventDefault();
                        }
                        break;
                }
            }
            
            /**
             * Обрабатывает клик по игровому полю в режиме обучения
             * @param {MouseEvent} e - Событие клика
             */
            handleCanvasClick(e) {
                if (!this.isLearningMode) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / this.cellSize);
                const y = Math.floor((e.clientY - rect.top) / this.cellSize);
                
                let explanation = '';
                
                if (x === this.pacman.x && y === this.pacman.y) {
                    explanation = 'Это Пакман! Управляет игрок. Движется по лабиринту, собирая еду и избегая привидений.';
                } else if (x === this.ghost.x && y === this.ghost.y) {
                    explanation = 'Это привидение! Имеет три режима: блуждание, преследование и бегство (при активации супер-еды).';
                } else if (this.currentMap[y] && this.currentMap[y][x] === 2) {
                    explanation = 'Обычная еда. Дает 10 очков при сборе.';
                } else if (this.currentMap[y] && this.currentMap[y][x] === 3) {
                    explanation = 'Супер-еда. Дает 50 очков и активирует режим охоты на 10 секунд.';
                } else if (this.currentMap[y] && this.currentMap[y][x] === 0) {
                    explanation = 'Стена. Пакман и привидение не могут проходить сквозь стены.';
                }
                
                document.getElementById('learning-content').textContent = explanation || 'Нажмите на игровой объект, чтобы увидеть объяснение';
            }
            
            /**
             * Переключает состояние игры (старт/пауза)
             */
            toggleGame() {
                if (this.isRunning) {
                    this.pauseGame();
                } else {
                    this.resumeGame();
                }
            }
            
            /**
             * Приостанавливает игру
             */
            pauseGame() {
                this.isRunning = false;
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                this.sounds.music.stop(this);
                document.getElementById('game-status').textContent = 'Пауза';
                document.getElementById('start-btn').innerHTML = '<span>▶️</span> Старт/Пауза';
            }
            
            /**
             * Возобновляет игру
             */
            resumeGame() {
                this.isRunning = true;
                document.getElementById('game-status').textContent = 'Игра активна';
                document.getElementById('start-btn').innerHTML = '<span>⏸️</span> Старт/Пауза';
                this.lastTimestamp = performance.now();
                this.startGameLoop();
                
                // Запускаем музыку, если звук включен
                if (this.isSoundEnabled) {
                    this.sounds.music.play(this);
                }
            }
            
            /**
             * Запускает игровой цикл с использованием requestAnimationFrame
             */
            startGameLoop() {
                if (!this.isRunning) return;
                
                const gameLoop = (timestamp) => {
                    // Вычисляем deltaTime для независимости от частоты кадров
                    const deltaTime = timestamp - this.lastTimestamp;
                    
                    // Обновляем игру только если прошло достаточно времени
                    if (deltaTime >= this.gameSpeed) {
                        this.update();
                        this.lastTimestamp = timestamp;
                    }
                    
                    this.draw();
                    this.animateMouth();
                    this.updateParticles();
                    
                    this.animationFrameId = requestAnimationFrame(gameLoop);
                };
                
                this.animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            /**
             * Сбрасывает текущий уровень
             */
            resetLevel() {
                this.pauseGame();
                this.resetGameState();
                this.updateUI();
                this.resumeGame();
            }
            
            /**
             * Сбрасывает рекорд
             */
            clearHighScore() {
                this.highScore = 0;
                localStorage.setItem('pacmanHighScore', '0');
                this.updateUI();
            }
            
            /**
             * Перезапускает игру сначала
             */
            restartGame() {
                this.currentLevel = 1;
                this.resetLevel();
                document.getElementById('game-over').style.display = 'none';
            }
            
            /**
             * Сбрасывает состояние игры к начальному
             */
            resetGameState() {
                this.pacman = { 
                    x: 10, 
                    y: 15, 
                    direction: 'right', 
                    nextDirection: null, 
                    mouthAngle: 0, 
                    mouthOpening: 0.1,
                    lastEatTime: 0,
                    eatInterval: 150
                };
                this.ghost = { 
                    x: 10, 
                    y: 8, 
                    direction: 'left', 
                    mode: 'wandering', 
                    speed: 0.8, 
                    color: 'red',
                    fearTimer: null
                };
                this.ghosts = null; // Сбрасываем дополнительные привидения
                this.score = 0;
                this.powerMode = false;
                this.gameSpeed = 200;
                this.currentMap = this.cloneMap(this.levels[this.currentLevel - 1]);
                this.countTotalFood();
            }
            
            /**
             * Обновляет пользовательский интерфейс
             */
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('high-score').textContent = this.highScore;
                document.getElementById('level').textContent = this.currentLevel;
                
                // Обновление рекорда в localStorage
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('pacmanHighScore', this.highScore.toString());
                }
                document.getElementById('high-score').textContent = this.highScore;
                
                // Обновление отладочной панели
                if (this.isLearningMode) {
                    document.getElementById('debug-pos').textContent = `${this.pacman.x}, ${this.pacman.y}`;
                    document.getElementById('debug-dir').textContent = this.pacman.direction;
                    document.getElementById('debug-speed').textContent = `${this.gameSpeed} мс`;
                    document.getElementById('debug-power').textContent = this.powerMode ? 'Активна' : 'Не активна';
                }
            }
            
            /**
             * Анимирует рот Пакмана для создания эффекта "поедания"
             */
            animateMouth() {
                this.pacman.mouthAngle += this.pacman.mouthOpening;
                if (this.pacman.mouthAngle >= 0.4 || this.pacman.mouthAngle <= 0) {
                    this.pacman.mouthOpening = -this.pacman.mouthOpening;
                }
            }
            
            /**
             * Обновляет состояние игры
             */
            update() {
                this.movePacman();
                this.moveGhost();
                this.checkCollisions();
                this.checkLevelCompletion();
                this.checkAchievements();
            }
            
            /**
             * Двигает Пакмана в соответствии с направлением
             */
            movePacman() {
                // Проверка возможности изменения направления
                if (this.pacman.nextDirection) {
                    const nextPos = this.getFuturePosition(this.pacman.x, this.pacman.y, this.pacman.nextDirection);
                    if (this.isValidMove(nextPos.x, nextPos.y)) {
                        this.pacman.direction = this.pacman.nextDirection;
                        this.pacman.nextDirection = null;
                    }
                }
                
                // Движение в текущем направлении
                const nextPos = this.getFuturePosition(this.pacman.x, this.pacman.y, this.pacman.direction);
                
                // Проверка на порталы (выход за границы карты)
                if (nextPos.x < 0 || nextPos.x >= this.currentMap[0].length) {
                    this.pacman.x = (nextPos.x + this.currentMap[0].length) % this.currentMap[0].length;
                    return;
                }
                
                if (this.isValidMove(nextPos.x, nextPos.y)) {
                    this.pacman.x = nextPos.x;
                    this.pacman.y = nextPos.y;
                }
            }
            
            /**
             * Двигает привидение в соответствии с его текущим режимом
             */
            moveGhost() {
                // Обновление режима привидения
                this.updateGhostMode();
                
                // Вычисление следующего направления
                const nextDirection = this.calculateGhostDirection();
                this.ghost.direction = nextDirection;
                
                // Движение привидения
                const nextPos = this.getFuturePosition(this.ghost.x, this.ghost.y, this.ghost.direction);
                
                // Проверка на порталы
                if (nextPos.x < 0 || nextPos.x >= this.currentMap[0].length) {
                    this.ghost.x = (nextPos.x + this.currentMap[0].length) % this.currentMap[0].length;
                    return;
                }
                
                if (this.isValidMove(nextPos.x, nextPos.y, 'ghost')) {
                    this.ghost.x = nextPos.x;
                    this.ghost.y = nextPos.y;
                }
                
                // Движение дополнительных привидений
                if (this.ghosts) {
                    this.ghosts.forEach(ghost => {
                        // Обновление режима привидения
                        this.updateGhostModeForGhost(ghost);
                        
                        // Вычисление следующего направления
                        const nextDirection = this.calculateGhostDirectionForGhost(ghost);
                        ghost.direction = nextDirection;
                        
                        // Движение привидения
                        const nextPos = this.getFuturePosition(ghost.x, ghost.y, ghost.direction);
                        
                        // Проверка на порталы
                        if (nextPos.x < 0 || nextPos.x >= this.currentMap[0].length) {
                            ghost.x = (nextPos.x + this.currentMap[0].length) % this.currentMap[0].length;
                            return;
                        }
                        
                        if (this.isValidMove(nextPos.x, nextPos.y, 'ghost')) {
                            ghost.x = nextPos.x;
                            ghost.y = nextPos.y;
                        }
                    });
                }
            }
            
            /**
             * Обновляет режим привидения на основе текущего состояния игры
             */
            updateGhostMode() {
                const dx = this.pacman.x - this.ghost.x;
                const dy = this.pacman.y - this.ghost.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Режим супер-еды активен
                if (this.powerMode) {
                    this.ghost.mode = 'fleeing';
                    this.ghost.color = 'blue';
                    
                    // Таймер супер-еды
                    if (Date.now() - this.powerModeStart > 10000) {
                        this.powerMode = false;
                        this.ghost.color = 'red';
                        if (this.ghost.fearTimer) {
                            clearTimeout(this.ghost.fearTimer);
                            this.ghost.fearTimer = null;
                        }
                    }
                } 
                // Близко к Пакману
                else if (distance < 5) {
                    this.ghost.mode = 'chasing';
                    this.ghost.color = 'red';
                } 
                // Далеко от Пакмана
                else {
                    this.ghost.mode = 'wandering';
                    this.ghost.color = 'pink';
                }
            }
            
            /**
             * Обновляет режим для конкретного привидения
             * @param {Object} ghost - Объект привидения
             */
            updateGhostModeForGhost(ghost) {
                const dx = this.pacman.x - ghost.x;
                const dy = this.pacman.y - ghost.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Режим супер-еды активен
                if (this.powerMode) {
                    ghost.mode = 'fleeing';
                    ghost.color = 'blue';
                } 
                // Близко к Пакману
                else if (distance < 5) {
                    ghost.mode = 'chasing';
                } 
                // Далеко от Пакмана
                else {
                    ghost.mode = 'wandering';
                }
            }
            
            /**
             * Рассчитывает направление движения привидения
             * @returns {string} Направление движения (up, down, left, right)
             */
            calculateGhostDirection() {
                // В режиме бегства инвертируем логику
                const targetMode = this.ghost.mode === 'fleeing' ? 'chasing' : this.ghost.mode;
                
                if (targetMode === 'chasing') {
                    return this.findPathToTarget(this.pacman.x, this.pacman.y);
                } else if (targetMode === 'wandering') {
                    // Случайное направление с приоритетом
                    const directions = ['up', 'down', 'left', 'right'];
                    const validDirections = directions.filter(dir => {
                        const nextPos = this.getFuturePosition(this.ghost.x, this.ghost.y, dir);
                        return this.isValidMove(nextPos.x, nextPos.y, 'ghost') && 
                               dir !== this.getOppositeDirection(this.ghost.direction);
                    });
                    
                    return validDirections.length > 0 ? 
                        validDirections[Math.floor(Math.random() * validDirections.length)] : 
                        this.ghost.direction;
                }
                
                return this.ghost.direction;
            }
            
            /**
             * Рассчитывает направление движения для конкретного привидения
             * @param {Object} ghost - Объект привидения
             * @returns {string} Направление движения
             */
            calculateGhostDirectionForGhost(ghost) {
                // В режиме бегства инвертируем логику
                const targetMode = ghost.mode === 'fleeing' ? 'chasing' : ghost.mode;
                
                if (targetMode === 'chasing') {
                    return this.findPathToTarget(this.pacman.x, this.pacman.y);
                } else if (targetMode === 'wandering') {
                    // Случайное направление с приоритетом
                    const directions = ['up', 'down', 'left', 'right'];
                    const validDirections = directions.filter(dir => {
                        const nextPos = this.getFuturePosition(ghost.x, ghost.y, dir);
                        return this.isValidMove(nextPos.x, nextPos.y, 'ghost') && 
                               dir !== this.getOppositeDirection(ghost.direction);
                    });
                    
                    return validDirections.length > 0 ? 
                        validDirections[Math.floor(Math.random() * validDirections.length)] : 
                        ghost.direction;
                }
                
                return ghost.direction;
            }
            
            /**
             * Находит оптимальный путь к цели с использованием простого эвристического алгоритма
             * @param {number} targetX - Целевая координата X
             * @param {number} targetY - Целевая координата Y
             * @returns {string} Направление движения
             */
            findPathToTarget(targetX, targetY) {
                const directions = ['up', 'down', 'left', 'right'];
                let bestDirection = null;
                let minDistance = Infinity;
                
                for (const direction of directions) {
                    const nextPos = this.getFuturePosition(this.ghost.x, this.ghost.y, direction);
                    
                    // Проверка валидности хода
                    if (!this.isValidMove(nextPos.x, nextPos.y, 'ghost') || 
                        direction === this.getOppositeDirection(this.ghost.direction)) {
                        continue;
                    }
                    
                    // Расчет расстояния до цели
                    const dx = targetX - nextPos.x;
                    const dy = targetY - nextPos.y;
                    const distance = dx * dx + dy * dy; // Используем квадрат расстояния для оптимизации
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestDirection = direction;
                    }
                }
                
                // Если нет допустимых направлений, остаемся на месте
                return bestDirection || this.ghost.direction;
            }
            
            /**
             * Возвращает противоположное направление
             * @param {string} direction - Текущее направление
             * @returns {string} Противоположное направление
             */
            getOppositeDirection(direction) {
                switch(direction) {
                    case 'up': return 'down';
                    case 'down': return 'up';
                    case 'left': return 'right';
                    case 'right': return 'left';
                    default: return direction;
                }
            }
            
            /**
             * Проверяет столкновения Пакмана с едой и привидением
             */
            checkCollisions() {
                // Проверка на выход за границы карты
                if (!this.currentMap[this.pacman.y] || !this.currentMap[this.pacman.y][this.pacman.x]) {
                    return;
                }
                
                // Сбор еды
                const cell = this.currentMap[this.pacman.y][this.pacman.x];
                if (cell === 2 || cell === 3) {
                    if (cell === 2) {
                        this.collectFood(10);
                    } else if (cell === 3) {
                        this.activatePowerMode();
                    }
                }
                
                // Столкновение с привидением
                if (this.pacman.x === this.ghost.x && this.pacman.y === this.ghost.y) {
                    if (this.powerMode) {
                        // В режиме супер-еды привидение уничтожается
                        this.playSound('eat');
                        this.resetGhost();
                        this.score += 200;
                        this.updateUI();
                    } else {
                        // Обычное столкновение - конец игры
                        this.gameOver();
                    }
                }
                
                // Столкновение с дополнительными привидениями
                if (this.ghosts) {
                    for (let i = 0; i < this.ghosts.length; i++) {
                        const ghost = this.ghosts[i];
                        if (this.pacman.x === ghost.x && this.pacman.y === ghost.y) {
                            if (this.powerMode) {
                                // В режиме супер-еды привидение уничтожается
                                this.playSound('eat');
                                this.ghosts.splice(i, 1);
                                this.score += 200;
                                this.updateUI();
                            } else {
                                // Обычное столкновение - конец игры
                                this.gameOver();
                                break;
                            }
                        }
                    }
                }
            }
            
            /**
             * Собирает еду и обновляет счёт
             * @param {number} points - Количество очков за сбор
             */
            collectFood(points) {
                // Проверяем, что ячейка содержит еду
                if (this.currentMap[this.pacman.y] && 
                    (this.currentMap[this.pacman.y][this.pacman.x] === 2 || 
                     this.currentMap[this.pacman.y][this.pacman.x] === 3)) {
                    
                    this.currentMap[this.pacman.y][this.pacman.x] = 1;
                    this.score += points;
                    this.foodCount--;
                    this.playSound('eat');
                    this.createParticles(this.pacman.x, this.pacman.y);
                    this.updateUI();
                }
            }
            
            /**
             * Активирует режим супер-еды
             */
            activatePowerMode() {
                this.collectFood(50);
                this.powerMode = true;
                this.powerModeStart = Date.now();
                this.ghost.color = 'blue';
                this.playSound('power');
                
                // Сбрасываем таймер страха, если он уже запущен
                if (this.ghost.fearTimer) {
                    clearTimeout(this.ghost.fearTimer);
                }
                
                // Устанавливаем таймер для завершения режима
                this.ghost.fearTimer = setTimeout(() => {
                    this.powerMode = false;
                    this.ghost.color = 'red';
                    this.ghost.fearTimer = null;
                }, 10000);
            }
            
            /**
             * Сбрасывает позицию привидения после уничтожения
             */
            resetGhost() {
                this.ghost.x = 10;
                this.ghost.y = 8;
                this.ghost.direction = 'left';
                this.ghost.mode = 'wandering';
            }
            
            /**
             * Проверяет завершение уровня
             */
            checkLevelCompletion() {
                // Проверяем, собрана ли вся еда
                if (this.foodCount <= 0) {
                    this.currentLevel++;
                    
                    // Зацикливаем уровни
                    if (this.currentLevel > this.levels.length) {
                        this.currentLevel = 1;
                    }
                    
                    // Увеличение скорости игры
                    this.gameSpeed = Math.max(80, this.gameSpeed - 20);
                    
                    // Сброс состояния
                    this.resetGameState();
                    
                    // Отображение уведомления
                    const levelComplete = document.getElementById('level-complete');
                    levelComplete.style.display = 'block';
                    setTimeout(() => {
                        levelComplete.style.display = 'none';
                    }, 2000);
                    
                    this.updateUI();
                }
            }
            
            /**
             * Обрабатывает окончание игры
             */
            gameOver() {
                this.pauseGame();
                document.getElementById('game-status').textContent = 'Игра окончена';
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('game-over').style.display = 'block';
                this.playSound('death');
                this.createConfetti();
            }
            
            /**
             * Создает конфетти-эффект при завершении уровня
             */
            createConfetti() {
                const colors = ['#FFD700', '#FFA500', '#FF4500', '#90EE90', '#87CEFA'];
                const confettiCount = 100;
                
                for (let i = 0; i < confettiCount; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.width = (Math.random() * 10 + 5) + 'px';
                    confetti.style.height = (Math.random() * 10 + 5) + 'px';
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                    document.body.appendChild(confetti);
                    
                    // Удаляем конфетти после анимации
                    setTimeout(() => {
                        confetti.remove();
                    }, 5000);
                }
            }
            
            /**
             * Создает частицы при сборе еды
             * @param {number} x - Координата X в ячейках
             * @param {number} y - Координата Y в ячейках
             */
            createParticles(x, y) {
                const particleCount = this.powerMode ? 30 : 5;
                const colors = this.powerMode ? ['#00FFFF', '#00BFFF', '#1E90FF'] : ['#FFFFFF'];
                
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: x * this.cellSize + this.cellSize/2,
                        y: y * this.cellSize + this.cellSize/2,
                        size: Math.random() * 3 + 2,
                        speedX: (Math.random() - 0.5) * 3,
                        speedY: (Math.random() - 0.5) * 3,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        alpha: 1,
                        decay: Math.random() * 0.05 + 0.01
                    });
                }
            }
            
            /**
             * Обновляет состояние частиц
             */
            updateParticles() {
                // Оптимизированная обработка частиц
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    particle.alpha -= particle.decay;
                    
                    if (particle.alpha <= 0) {
                        this.particles.splice(i, 1);
                        continue;
                    }
                    
                    this.ctx.globalAlpha = particle.alpha;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.globalAlpha = 1;
            }
            
            /**
             * Проверяет, можно ли переместиться в указанную ячейку
             * @param {number} x - Координата X в ячейках
             * @param {number} y - Координата Y в ячейках
             * @param {string} [entity='pacman'] - Тип сущности (pacman/ghost)
             * @returns {boolean} Допустимо ли перемещение
             */
            isValidMove(x, y, entity = 'pacman') {
                // Проверка границ
                if (y < 0 || y >= this.currentMap.length || 
                    x < 0 || x >= this.currentMap[0].length) {
                    return false;
                }
                
                const cell = this.currentMap[y][x];
                
                // Стены блокируют движение
                if (cell === 0) {
                    return false;
                }
                
                // Привидение проходит через точки
                if (entity === 'ghost' && (cell === 2 || cell === 3)) {
                    return true;
                }
                
                return true;
            }
            
            /**
             * Возвращает позицию после следующего шага в указанном направлении
             * @param {number} x - Текущая координата X
             * @param {number} y - Текущая координата Y
             * @param {string} direction - Направление движения
             * @returns {{x: number, y: number}} Новая позиция
             */
            getFuturePosition(x, y, direction) {
                const pos = { x, y };
                
                switch(direction) {
                    case 'up': pos.y--; break;
                    case 'down': pos.y++; break;
                    case 'left': pos.x--; break;
                    case 'right': pos.x++; break;
                }
                
                return pos;
            }
            
            /**
             * Отрисовывает игровое поле
             */
            draw() {
                // Очистка холста
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Рисуем карту
                this.drawMap();
                
                // Рисуем Пакмана
                this.drawPacman();
                
                // Рисуем привидение
                this.drawGhost();
                
                // Рисуем дополнительные привидения
                if (this.ghosts) {
                    this.ghosts.forEach(ghost => {
                        this.drawGhostFor(ghost);
                    });
                }
                
                // Обновляем мини-карту
                this.updateMiniMap();
            }
            
            /**
             * Отрисовывает карту уровня
             */
            drawMap() {
                const mapHeight = this.currentMap.length;
                const mapWidth = this.currentMap[0].length;
                
                for (let y = 0; y < mapHeight; y++) {
                    for (let x = 0; x < mapWidth; x++) {
                        const cell = this.currentMap[y][x];
                        
                        // Стены
                        if (cell === 0) {
                            this.ctx.fillStyle = 'blue';
                            this.ctx.fillRect(
                                x * this.cellSize, 
                                y * this.cellSize, 
                                this.cellSize, 
                                this.cellSize
                            );
                        } 
                        // Обычная еда
                        else if (cell === 2) {
                            this.ctx.fillStyle = 'white';
                            this.ctx.beginPath();
                            this.ctx.arc(
                                x * this.cellSize + this.cellSize/2,
                                y * this.cellSize + this.cellSize/2,
                                2, 0, Math.PI * 2
                            );
                            this.ctx.fill();
                        } 
                        // Супер-еда
                        else if (cell === 3) {
                            this.ctx.fillStyle = '#FFD700';
                            this.ctx.beginPath();
                            this.ctx.arc(
                                x * this.cellSize + this.cellSize/2,
                                y * this.cellSize + this.cellSize/2,
                                5, 0, Math.PI * 2
                            );
                            this.ctx.fill();
                        }
                    }
                }
            }
            
            /**
             * Отрисовывает Пакмана с анимацией рта
             */
            drawPacman() {
                const centerX = this.pacman.x * this.cellSize + this.cellSize/2;
                const centerY = this.pacman.y * this.cellSize + this.cellSize/2;
                const radius = this.cellSize/2 - 2;
                
                this.ctx.fillStyle = 'yellow';
                this.ctx.beginPath();
                
                // Анимация рта
                let startAngle, endAngle;
                
                switch(this.pacman.direction) {
                    case 'right':
                        startAngle = this.pacman.mouthAngle * Math.PI;
                        endAngle = (2 - this.pacman.mouthAngle) * Math.PI;
                        break;
                    case 'left':
                        startAngle = (1 + this.pacman.mouthAngle) * Math.PI;
                        endAngle = (3 - this.pacman.mouthAngle) * Math.PI;
                        break;
                    case 'up':
                        startAngle = (1.5 + this.pacman.mouthAngle) * Math.PI;
                        endAngle = (1.5 - this.pacman.mouthAngle) * Math.PI + 2 * Math.PI;
                        break;
                    case 'down':
                        startAngle = (0.5 + this.pacman.mouthAngle) * Math.PI;
                        endAngle = (0.5 - this.pacman.mouthAngle) * Math.PI;
                        break;
                    default:
                        startAngle = 0;
                        endAngle = 2 * Math.PI;
                }
                
                this.ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                this.ctx.lineTo(centerX, centerY);
                this.ctx.fill();
            }
            
            /**
             * Отрисовывает привидение с текущим цветом
             */
            drawGhost() {
                this.drawGhostFor(this.ghost);
            }
            
            /**
             * Отрисовывает конкретное привидение
             * @param {Object} ghost - Объект привидения
             */
            drawGhostFor(ghost) {
                const x = ghost.x * this.cellSize;
                const y = ghost.y * this.cellSize;
                
                // Тело привидения
                this.ctx.fillStyle = ghost.color;
                this.ctx.beginPath();
                this.ctx.arc(
                    x + this.cellSize/2, 
                    y + this.cellSize/3, 
                    this.cellSize/2.5, 
                    0, 
                    Math.PI
                );
                this.ctx.lineTo(x + this.cellSize, y + this.cellSize);
                this.ctx.lineTo(x, y + this.cellSize);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Глаза
                this.ctx.fillStyle = 'white';
                
                // Левый глаз
                this.ctx.beginPath();
                this.ctx.arc(
                    x + this.cellSize/3, 
                    y + this.cellSize/3, 
                    this.cellSize/5, 
                    0, 
                    Math.PI * 2
                );
                this.ctx.fill();
                
                // Правый глаз
                this.ctx.beginPath();
                this.ctx.arc(
                    x + 2 * this.cellSize/3, 
                    y + this.cellSize/3, 
                    this.cellSize/5, 
                    0, 
                    Math.PI * 2
                );
                this.ctx.fill();
                
                // Зрачки (направление взгляда)
                this.ctx.fillStyle = 'blue';
                const pupilOffset = this.cellSize/8;
                let pupilX = 0, pupilY = 0;
                
                switch(ghost.direction) {
                    case 'up':
                        pupilY = -pupilOffset;
                        break;
                    case 'down':
                        pupilY = pupilOffset;
                        break;
                    case 'left':
                        pupilX = -pupilOffset;
                        break;
                    case 'right':
                        pupilX = pupilOffset;
                        break;
                }
                
                // Левый зрачок
                this.ctx.beginPath();
                this.ctx.arc(
                    x + this.cellSize/3 + pupilX, 
                    y + this.cellSize/3 + pupilY, 
                    this.cellSize/10, 
                    0, 
                    Math.PI * 2
                );
                this.ctx.fill();
                
                // Правый зрачок
                this.ctx.beginPath();
                this.ctx.arc(
                    x + 2 * this.cellSize/3 + pupilX, 
                    y + this.cellSize/3 + pupilY, 
                    this.cellSize/10, 
                    0, 
                    Math.PI * 2
                );
                this.ctx.fill();
            }
            
            /**
             * Обновляет мини-карту в правом нижнем углу
             */
            updateMiniMap() {
                const mapWidth = this.currentMap[0].length;
                const mapHeight = this.currentMap.length;
                
                // Вычисляем оптимальный размер ячейки для мини-карты
                const cellSize = Math.min(
                    this.miniMapCanvas.width / mapWidth,
                    this.miniMapCanvas.height / mapHeight
                );
                
                // Центрируем мини-карту
                const offsetX = (this.miniMapCanvas.width - mapWidth * cellSize) / 2;
                const offsetY = (this.miniMapCanvas.height - mapHeight * cellSize) / 2;
                
                // Очистка мини-карты
                this.miniMapCtx.fillStyle = 'black';
                this.miniMapCtx.fillRect(0, 0, this.miniMapCanvas.width, this.miniMapCanvas.height);
                
                // Рисуем карту
                for (let y = 0; y < mapHeight; y++) {
                    for (let x = 0; x < mapWidth; x++) {
                        const cell = this.currentMap[y][x];
                        
                        if (cell === 0) {
                            this.miniMapCtx.fillStyle = 'blue';
                        } else if (cell === 2 || cell === 3) {
                            this.miniMapCtx.fillStyle = cell === 2 ? 'white' : '#FFD700';
                        } else {
                            continue; // Пропускаем пустые ячейки
                        }
                        
                        this.miniMapCtx.fillRect(
                            offsetX + x * cellSize, 
                            offsetY + y * cellSize, 
                            cellSize - 0.5, 
                            cellSize - 0.5
                        );
                    }
                }
                
                // Позиция Пакмана
                this.miniMapCtx.fillStyle = 'yellow';
                this.miniMapCtx.beginPath();
                this.miniMapCtx.arc(
                    offsetX + this.pacman.x * cellSize + cellSize/2,
                    offsetY + this.pacman.y * cellSize + cellSize/2,
                    cellSize/2.5,
                    0,
                    Math.PI * 2
                );
                this.miniMapCtx.fill();
                
                // Позиция привидения
                this.miniMapCtx.fillStyle = this.ghost.color;
                this.miniMapCtx.beginPath();
                this.miniMapCtx.arc(
                    offsetX + this.ghost.x * cellSize + cellSize/2,
                    offsetY + this.ghost.y * cellSize + cellSize/2,
                    cellSize/2.5,
                    0,
                    Math.PI * 2
                );
                this.miniMapCtx.fill();
                
                // Позиции дополнительных привидений
                if (this.ghosts) {
                    this.ghosts.forEach(ghost => {
                        this.miniMapCtx.fillStyle = ghost.color;
                        this.miniMapCtx.beginPath();
                        this.miniMapCtx.arc(
                            offsetX + ghost.x * cellSize + cellSize/2,
                            offsetY + ghost.y * cellSize + cellSize/2,
                            cellSize/2.5,
                            0,
                            Math.PI * 2
                        );
                        this.miniMapCtx.fill();
                    });
                }
            }
            
            /**
             * Загружает учебные материалы
             * @returns {Array} Массив уроков
             */
            loadLessons() {
                return [
                    {
                        id: 1,
                        title: "Игровой цикл",
                        description: "Узнайте, как работает основной игровой цикл и почему он важен для 2D-игр.",
                        steps: [
                            {
                                highlight: "gameLoop",
                                explanation: "Метод gameLoop - сердце любой игры. Он вызывается постоянно и обновляет состояние игры.",
                                codeSnippet: `startGameLoop() {
    if (!this.isRunning) return;
    
    const gameLoop = (timestamp) => {
        // Вычисляем deltaTime для независимости от частоты кадров
        const deltaTime = timestamp - this.lastTimestamp;
        
        // Обновляем игру только если прошло достаточно времени
        if (deltaTime >= this.gameSpeed) {
            this.update();
            this.lastTimestamp = timestamp;
        }
        
        this.draw();
        this.animationFrameId = requestAnimationFrame(gameLoop);
    };
    
    this.animationFrameId = requestAnimationFrame(gameLoop);
}`
                            },
                            {
                                highlight: "update()",
                                explanation: "Метод update() обрабатывает логику игры: перемещение объектов, проверку коллизий и т.д.",
                                codeSnippet: `update() {
    this.movePacman();
    this.moveGhost();
    this.checkCollisions();
    this.checkLevelCompletion();
}`
                            },
                            {
                                highlight: "draw()",
                                explanation: "Метод draw() отвечает за отрисовку всех объектов на экране.",
                                codeSnippet: `draw() {
    // Очистка холста
    this.ctx.fillStyle = 'black';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Рисуем карту
    this.drawMap();
    
    // Рисуем Пакмана
    this.drawPacman();
    
    // Рисуем привидение
    this.drawGhost();
    
    // Обновляем мини-карту
    this.updateMiniMap();
}`
                            }
                        ]
                    },
                    {
                        id: 2,
                        title: "Обработка ввода",
                        description: "Изучите, как обрабатывать пользовательский ввод в играх на JavaScript.",
                        steps: [
                            {
                                highlight: "handleKey",
                                explanation: "Метод handleKey обрабатывает нажатия клавиш для управления Пакманом.",
                                codeSnippet: `handleKey(e) {
    if (!this.isRunning) return;
    
    // Сохраняем направление для последующего применения
    switch(e.key) {
        case 'ArrowUp':
            this.pacman.nextDirection = 'up';
            e.preventDefault();
            break;
        case 'ArrowDown':
            this.pacman.nextDirection = 'down';
            e.preventDefault();
            break;
        case 'ArrowLeft':
            this.pacman.nextDirection = 'left';
            e.preventDefault();
            break;
        case 'ArrowRight':
            this.pacman.nextDirection = 'right';
            e.preventDefault();
            break;
    }
}`
                            },
                            {
                                highlight: "movePacman",
                                explanation: "Метод movePacman проверяет возможность движения и перемещает Пакмана.",
                                codeSnippet: `movePacman() {
    // Проверка возможности изменения направления
    if (this.pacman.nextDirection) {
        const nextPos = this.getFuturePosition(this.pacman.x, this.pacman.y, this.pacman.nextDirection);
        if (this.isValidMove(nextPos.x, nextPos.y)) {
            this.pacman.direction = this.pacman.nextDirection;
            this.pacman.nextDirection = null;
        }
    }
    
    // Движение в текущем направлении
    const nextPos = this.getFuturePosition(this.pacman.x, this.pacman.y, this.pacman.direction);
    
    // Проверка на порталы (выход за границы карты)
    if (nextPos.x < 0 || nextPos.x >= this.currentMap[0].length) {
        this.pacman.x = (nextPos.x + this.currentMap[0].length) % this.currentMap[0].length;
        return;
    }
    
    if (this.isValidMove(nextPos.x, nextPos.y)) {
        this.pacman.x = nextPos.x;
        this.pacman.y = nextPos.y;
    }
}`
                            }
                        ]
                    },
                    {
                        id: 3,
                        title: "ИИ привидения",
                        description: "Изучите, как создать простой, но эффективный искусственный интеллект для привидений.",
                        steps: [
                            {
                                highlight: "updateGhostMode",
                                explanation: "Метод updateGhostMode определяет текущий режим привидения на основе расстояния до Пакмана.",
                                codeSnippet: `updateGhostMode() {
    const dx = this.pacman.x - this.ghost.x;
    const dy = this.pacman.y - this.ghost.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Режим супер-еды активен
    if (this.powerMode) {
        this.ghost.mode = 'fleeing';
        this.ghost.color = 'blue';
    } 
    // Близко к Пакману
    else if (distance < 5) {
        this.ghost.mode = 'chasing';
        this.ghost.color = 'red';
    } 
    // Далеко от Пакмана
    else {
        this.ghost.mode = 'wandering';
        this.ghost.color = 'pink';
    }
}`
                            },
                            {
                                highlight: "findPathToTarget",
                                explanation: "Метод findPathToTarget находит оптимальный путь к цели с использованием простого эвристического алгоритма.",
                                codeSnippet: `findPathToTarget(targetX, targetY) {
    const directions = ['up', 'down', 'left', 'right'];
    let bestDirection = null;
    let minDistance = Infinity;
    
    for (const direction of directions) {
        const nextPos = this.getFuturePosition(this.ghost.x, this.ghost.y, direction);
        
        // Проверка валидности хода
        if (!this.isValidMove(nextPos.x, nextPos.y, 'ghost') || 
            direction === this.getOppositeDirection(this.ghost.direction)) {
            continue;
        }
        
        // Расчет расстояния до цели
        const dx = targetX - nextPos.x;
        const dy = targetY - nextPos.y;
        const distance = dx * dx + dy * dy; // Используем квадрат расстояния для оптимизации
        
        if (distance < minDistance) {
            minDistance = distance;
            bestDirection = direction;
        }
    }
    
    // Если нет допустимых направлений, остаемся на месте
    return bestDirection || this.ghost.direction;
}`
                            }
                        ]
                    }
                ];
            }
            
            /**
             * Открывает учебный урок
             * @param {number} lessonId - ID урока
             */
            openLesson(lessonId) {
                this.currentLesson = this.lessons.find(lesson => lesson.id === lessonId);
                this.currentLessonStep = 0;
                this.showLessonStep();
                
                // Приостанавливаем игру во время обучения
                this.wasRunning = this.isRunning;
                this.pauseGame();
                
                document.getElementById('lesson-panel').style.display = 'flex';
            }
            
            /**
             * Закрывает учебный урок
             */
            closeLesson() {
                document.getElementById('lesson-panel').style.display = 'none';
                
                // Возобновляем игру, если она была запущена
                if (this.wasRunning) {
                    this.resumeGame();
                }
            }
            
            /**
             * Отображает текущий шаг урока
             */
            showLessonStep() {
                const lesson = this.currentLesson;
                const step = lesson.steps[this.currentLessonStep];
                
                // Обновляем заголовок
                document.getElementById('lesson-title').textContent = `${lesson.title} (Шаг ${this.currentLessonStep + 1}/${lesson.steps.length})`;
                
                // Очищаем содержимое
                const content = document.getElementById('lesson-content');
                content.innerHTML = '';
                
                // Добавляем шаг
                const stepElement = document.createElement('div');
                stepElement.className = 'lesson-step';
                
                stepElement.innerHTML = `
                    <h4>${step.highlight}</h4>
                    <p>${step.explanation}</p>
                    <div class="code-block">${this.escapeHtml(step.codeSnippet)}</div>
                `;
                
                content.appendChild(stepElement);
                
                // Обновляем состояние кнопок
                document.getElementById('lesson-prev').disabled = this.currentLessonStep === 0;
                document.getElementById('lesson-next').disabled = this.currentLessonStep === lesson.steps.length - 1;
            }
            
            /**
             * Переходит к предыдущему шагу урока
             */
            previousLessonStep() {
                if (this.currentLessonStep > 0) {
                    this.currentLessonStep--;
                    this.showLessonStep();
                }
            }
            
            /**
             * Переходит к следующему шагу урока
             */
            nextLessonStep() {
                if (this.currentLessonStep < this.currentLesson.steps.length - 1) {
                    this.currentLessonStep++;
                    this.showLessonStep();
                } else {
                    this.closeLesson();
                }
            }
            
            /**
             * Экранирует HTML для безопасного отображения в код-блоке
             * @param {string} unsafe - Небезопасная строка
             * @returns {string} Экранированная строка
             */
            escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "<")
                    .replace(/>/g, ">")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }
            
            /**
             * Загружает достижения
             * @returns {Array} Массив достижений
             */
            loadAchievements() {
                return [
                    {
                        id: 'first-food',
                        title: 'Первая еда',
                        description: 'Соберите первую точку еды',
                        condition: () => this.score >= 10,
                        earned: false
                    },
                    {
                        id: 'level-completed',
                        title: 'Мастер лабиринта',
                        description: 'Пройдите первый уровень',
                        condition: () => this.currentLevel > 1,
                        earned: false
                    },
                    {
                        id: 'power-mode',
                        title: 'Супергерой',
                        description: 'Активируйте режим супер-еды',
                        condition: () => this.powerMode,
                        earned: false
                    },
                    {
                        id: 'code-modified',
                        title: 'Разработчик',
                        description: 'Измените игровой код через консоль разработчика',
                        condition: () => this.codeModified,
                        earned: false
                    },
                    {
                        id: 'ghost-destroyed',
                        title: 'Охотник',
                        description: 'Уничтожьте привидение в режиме супер-еды',
                        condition: () => this.score >= 210,
                        earned: false
                    },
                    {
                        id: 'five-levels',
                        title: 'Профессионал',
                        description: 'Пройдите 5 уровней подряд',
                        condition: () => this.currentLevel > 5,
                        earned: false
                    }
                ];
            }
            
            /**
             * Инициализирует систему достижений
             */
            initAchievements() {
                // Загружаем сохраненные достижения
                const savedAchievements = JSON.parse(localStorage.getItem('pacmanAchievements') || '[]');
                
                this.achievements.forEach(achievement => {
                    const saved = savedAchievements.find(a => a.id === achievement.id);
                    if (saved) {
                        achievement.earned = saved.earned;
                    }
                });
            }
            
            /**
             * Проверяет выполнение достижений
             */
            checkAchievements() {
                let newAchievements = 0;
                
                this.achievements.forEach(achievement => {
                    if (!achievement.earned && achievement.condition()) {
                        achievement.earned = true;
                        newAchievements++;
                        this.showAchievement(achievement);
                    }
                });
                
                if (newAchievements > 0) {
                    this.saveAchievements();
                    this.renderAchievements();
                }
            }
            
            /**
             * Отображает достижение
             * @param {Object} achievement - Достижение
             */
            showAchievement(achievement) {
                const notification = document.getElementById('notification');
                notification.textContent = `Новое достижение: ${achievement.title} - ${achievement.description}`;
                notification.className = 'notification';
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
            
            /**
             * Сохраняет достижения в localStorage
             */
            saveAchievements() {
                const earnedAchievements = this.achievements.map(a => ({
                    id: a.id,
                    earned: a.earned
                }));
                
                localStorage.setItem('pacmanAchievements', JSON.stringify(earnedAchievements));
            }
            
            /**
             * Отображает достижения в панели
             */
            renderAchievements() {
                const achievementsList = document.getElementById('achievements-list');
                achievementsList.innerHTML = '';
                
                this.achievements.forEach(achievement => {
                    const item = document.createElement('div');
                    item.className = 'achievement-item';
                    
                    const statusClass = achievement.earned ? 'achievement-earned' : 'achievement-locked';
                    const statusText = achievement.earned ? 'Получено' : 'Не получено';
                    const icon = achievement.earned ? '🏆' : '🔲';
                    
                    item.innerHTML = `
                        <div class="achievement-title ${statusClass}">
                            ${icon} ${achievement.title} <span>(${statusText})</span>
                        </div>
                        <div class="achievement-description">${achievement.description}</div>
                    `;
                    
                    achievementsList.appendChild(item);
                });
            }
            
            /**
             * Переключает панель достижений
             */
            toggleAchievementsPanel() {
                const panel = document.getElementById('achievements-panel');
                panel.classList.toggle('open');
            }
            
            /**
             * Закрывает панель достижений
             */
            closeAchievementsPanel() {
                document.getElementById('achievements-panel').classList.remove('open');
            }
            
            /**
             * Загружает тесты
             * @returns {Array} Массив тестов
             */
            loadTests() {
                return [
                    {
                        id: 'game-loop',
                        title: 'Игровой цикл',
                        questions: [
                            {
                                question: 'Какой метод вызывается постоянно для обновления состояния игры?',
                                options: [
                                    'update()',
                                    'draw()',
                                    'gameLoop()',
                                    'startGameLoop()'
                                ],
                                correctAnswer: 2,
                                explanation: 'Метод gameLoop() вызывается постоянно через requestAnimationFrame и является основой игрового цикла.'
                            },
                            {
                                question: 'Что делает метод update()?',
                                options: [
                                    'Отрисовывает игру',
                                    'Обрабатывает логику игры',
                                    'Управляет звуком',
                                    'Обрабатывает ввод пользователя'
                                ],
                                correctAnswer: 1,
                                explanation: 'Метод update() отвечает за обработку игровой логики: перемещение объектов, проверку коллизий и т.д.'
                            },
                            {
                                question: 'Какой метод используется для отрисовки игры?',
                                options: [
                                    'update()',
                                    'draw()',
                                    'gameLoop()',
                                    'render()'
                                ],
                                correctAnswer: 1,
                                explanation: 'Метод draw() отвечает за отрисовку всех объектов на экране.'
                            }
                        ]
                    },
                    {
                        id: 'input-handling',
                        title: 'Обработка ввода',
                        questions: [
                            {
                                question: 'Какой метод обрабатывает нажатия клавиш?',
                                options: [
                                    'handleInput()',
                                    'handleKey()',
                                    'processInput()',
                                    'processKey()'
                                ],
                                correctAnswer: 1,
                                explanation: 'Метод handleKey() обрабатывает нажатия клавиш для управления Пакманом.'
                            },
                            {
                                question: 'Какое свойство используется для предварительного задания направления Пакмана?',
                                options: [
                                    'direction',
                                    'nextDirection',
                                    'targetDirection',
                                    'moveDirection'
                                ],
                                correctAnswer: 1,
                                explanation: 'Свойство nextDirection используется для предварительного задания направления Пакмана.'
                            }
                        ]
                    }
                ];
            }
            
            /**
             * Запускает тест
             * @param {number} testId - ID теста
             */
            startTest(testId) {
                this.currentTest = this.tests.find(test => test.id === testId);
                this.currentQuestion = 0;
                this.testScore = 0;
                
                const testPanel = document.getElementById('test-panel');
                testPanel.style.display = 'block';
                
                this.showTestQuestion();
            }
            
            /**
             * Отображает текущий вопрос теста
             */
            showTestQuestion() {
                const question = this.currentTest.questions[this.currentQuestion];
                const testPanel = document.getElementById('test-panel');
                
                // Обновляем заголовок
                document.getElementById('test-title').textContent = this.currentTest.title;
                document.getElementById('test-question-count').textContent = 
                    `Вопрос ${this.currentQuestion + 1} из ${this.currentTest.questions.length}`;
                
                // Обновляем вопрос
                document.getElementById('test-question').textContent = question.question;
                
                // Очищаем варианты ответов
                const optionsContainer = document.getElementById('test-options');
                optionsContainer.innerHTML = '';
                
                // Добавляем варианты ответов
                question.options.forEach((option, index) => {
                    const optionElement = document.createElement('button');
                    optionElement.className = 'test-option';
                    optionElement.dataset.index = index;
                    optionElement.textContent = option;
                    optionsContainer.appendChild(optionElement);
                });
                
                // Скрываем обратную связь
                document.getElementById('test-feedback').style.display = 'none';
            }
            
            /**
             * Проверяет ответ на вопрос
             * @param {number} selectedIndex - Индекс выбранного ответа
             */
            checkAnswer(selectedIndex) {
                const question = this.currentTest.questions[this.currentQuestion];
                const isCorrect = selectedIndex === question.correctAnswer;
                const feedback = document.getElementById('test-feedback');
                
                if (isCorrect) {
                    this.testScore++;
                    feedback.className = 'feedback success';
                    feedback.textContent = `Правильно! ${question.explanation}`;
                } else {
                    feedback.className = 'feedback error';
                    feedback.textContent = `Неправильно. ${question.explanation}`;
                }
                
                feedback.style.display = 'block';
                
                // Переход к следующему вопросу или завершение теста
                setTimeout(() => {
                    this.currentQuestion++;
                    if (this.currentQuestion < this.currentTest.questions.length) {
                        this.showTestQuestion();
                    } else {
                        this.showTestResults();
                    }
                }, 2000);
            }
            
            /**
             * Отображает результаты теста
             */
            showTestResults() {
                const testPanel = document.getElementById('test-panel');
                const score = Math.round((this.testScore / this.currentTest.questions.length) * 100);
                
                testPanel.innerHTML = `
                    <h3>${this.currentTest.title}</h3>
                    <div class="test-results">
                        <div class="test-score">${score}%</div>
                        <p>Ваш результат: ${this.testScore} из ${this.currentTest.questions.length}</p>
                        <button id="test-retry" class="lesson-nav-btn" style="margin-top: 20px;">Попробовать снова</button>
                    </div>
                `;
                
                document.getElementById('test-retry').addEventListener('click', () => {
                    this.startTest(this.currentTest.id);
                });
            }
            
            /**
             * Сохраняет прогресс игры
             */
            saveProgress() {
                const progress = {
                    version: '1.1',
                    highScore: this.highScore,
                    currentLevel: this.currentLevel,
                    unlockedLevels: Math.min(this.levels.length, this.currentLevel),
                    achievements: this.achievements.filter(a => a.earned).map(a => a.id),
                    settings: {
                        soundEnabled: this.isSoundEnabled,
                        learningMode: this.isLearningMode,
                        theme: this.isDarkTheme ? 'dark' : 'light'
                    }
                };
                
                localStorage.setItem('pacmanProgress', JSON.stringify(progress));
                this.showNotification('Прогресс сохранен!');
            }
            
            /**
             * Загружает прогресс игры
             * @returns {boolean} Успешно ли загружено
             */
            loadProgress() {
                const saved = localStorage.getItem('pacmanProgress');
                if (saved) {
                    try {
                        const progress = JSON.parse(saved);
                        
                        if (progress.version === '1.1') {
                            this.highScore = progress.highScore;
                            this.currentLevel = Math.min(progress.currentLevel, this.levels.length);
                            
                            // Восстанавливаем достижения
                            progress.achievements.forEach(id => {
                                const achievement = this.achievements.find(a => a.id === id);
                                if (achievement) achievement.earned = true;
                            });
                            
                            // Восстанавливаем настройки
                            if (progress.settings) {
                                this.isSoundEnabled = progress.settings.soundEnabled;
                                this.isLearningMode = progress.settings.learningMode;
                                
                                // Переключаем тему, если нужно
                                if (progress.settings.theme !== (this.isDarkTheme ? 'dark' : 'light')) {
                                    this.toggleTheme();
                                }
                            }
                            
                            this.updateUI();
                            return true;
                        }
                    } catch (e) {
                        console.error('Ошибка загрузки прогресса:', e);
                    }
                }
                return false;
            }
            
            /**
             * Показывает уведомление
             * @param {string} message - Текст уведомления
             * @param {string} [type='success'] - Тип уведомления (success, error)
             */
            showNotification(message, type = 'success') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = 'notification';
                notification.classList.add('show');
                
                if (type === 'error') {
                    notification.classList.add('error');
                }
                
                setTimeout(() => {
                    notification.classList.remove('show');
                    notification.classList.remove('error');
                }, 3000);
            }
        }

        // Запуск игры при загрузке страницы
        window.onload = () => {
            try {
                new PacmanGame();
            } catch (error) {
                console.error("Ошибка инициализации игры:", error);
                alert("Произошла ошибка при запуске игры. Проверьте консоль для подробностей.");
            }
        };
    </script>
</body>
</html>