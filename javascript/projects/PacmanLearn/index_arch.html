<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PacmanLearn - Обучающая игра</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: #121212;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s;
        }

        body.light-theme {
            background: #f5f5f5;
            color: #333;
        }

        .container {
            display: flex;
            height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
            gap: 15px;
        }

        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        body.light-theme .header {
            background: rgba(200, 200, 200, 0.5);
        }

        .header h1 {
            font-size: 1.5rem;
            color: #FFD700;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 15px;
            background: #2c3e50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        body.light-theme .btn {
            background: #3498db;
        }

        .btn:hover {
            background: #3498db;
            transform: translateY(-2px);
        }

        body.light-theme .btn:hover {
            background: #2980b9;
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.secondary {
            background: #7f8c8d;
        }

        body.light-theme .btn.secondary {
            background: #95a5a6;
        }

        .game-area {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-canvas {
            background: #000;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .mini-map-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            padding: 5px;
        }

        body.light-theme .mini-map-container {
            background: rgba(255, 255, 255, 0.7);
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-size: 1.1rem;
        }

        body.light-theme .status-bar {
            background: rgba(200, 200, 200, 0.5);
        }

        .score-info, .level-info {
            display: flex;
            gap: 15px;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .info-value {
            font-weight: bold;
            color: #FFD700;
            font-size: 1.2rem;
        }

        /* Панель достижений */
        .achievements-panel {
            position: fixed;
            top: 0;
            right: -320px;
            width: 300px;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 90;
            transition: right 0.3s;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        body.light-theme .achievements-panel {
            background: rgba(255, 255, 255, 0.95);
        }

        .achievements-panel.open {
            right: 0;
        }

        .achievements-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .achievements-title {
            font-size: 1.5rem;
            color: #FFD700;
        }

        body.light-theme .achievements-title {
            color: #D35400;
        }

        .achievements-close {
            background: #c0392b;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
        }

        .achievement {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.2s;
        }

        body.light-theme .achievement {
            background: rgba(240, 240, 240, 0.7);
            border: 1px solid #ddd;
        }

        .achievement:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.15);
        }

        body.light-theme .achievement:hover {
            background: rgba(230, 230, 230, 0.7);
        }

        .achievement-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #FFD700;
        }

        body.light-theme .achievement-title {
            color: #D35400;
        }

        .achievement-description {
            font-size: 0.9rem;
            color: #bdc3c7;
        }

        body.light-theme .achievement-description {
            color: #7f8c8d;
        }

        .achievement-status {
            display: inline-block;
            margin-top: 5px;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            background: #2ecc71;
            color: white;
        }

        body.light-theme .achievement-status {
            background: #27ae60;
        }

        /* Уведомления */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 8px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
            z-index: 100;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        body.light-theme .notification {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        .notification.achievement {
            background: #2ecc71;
        }

        body.light-theme .notification.achievement {
            background: #27ae60;
        }

        .notification.error {
            background: #e74c3c;
        }

        body.light-theme .notification.error {
            background: #c0372a;
        }

        /* Модальные окна */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #1a1a1a;
            width: 80%;
            max-width: 500px;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        body.light-theme .modal-content {
            background: white;
            color: #333;
        }

        .modal h2 {
            margin-bottom: 20px;
            color: #FFD700;
            text-align: center;
        }

        body.light-theme .modal h2 {
            color: #D35400;
        }

        .modal-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        /* Уроки */
        .lesson-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: none;
            flex-direction: column;
        }

        body.light-theme .lesson-panel {
            background: rgba(255, 255, 255, 0.95);
        }

        .lesson-header {
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        body.light-theme .lesson-header {
            background: rgba(200, 200, 200, 0.7);
        }

        .lesson-title {
            font-size: 1.5rem;
            color: #FFD700;
        }

        body.light-theme .lesson-title {
            color: #D35400;
        }

        .lesson-close {
            background: #c0392b;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
        }

        .lesson-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }

        .lesson-step {
            margin-bottom: 30px;
            padding: 15px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        body.light-theme .lesson-step {
            background: rgba(200, 200, 200, 0.2);
        }

        .lesson-step h4 {
            margin-bottom: 10px;
            color: #3498db;
        }

        body.light-theme .lesson-step h4 {
            color: #2980b9;
        }

        .code-block {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
            margin: 10px 0;
            overflow-x: auto;
            white-space: pre;
        }

        body.light-theme .code-block {
            background: rgba(240, 240, 240, 0.7);
        }

        .lesson-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .lesson-nav-btn {
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
        }

        .lesson-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Редактор уровней */
        .level-editor {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            z-index: 100;
            display: none;
            flex-direction: column;
        }

        body.light-theme .level-editor {
            background: #f0f0f0;
        }

        .editor-toolbar {
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            gap: 10px;
        }

        body.light-theme .editor-toolbar {
            background: rgba(200, 200, 200, 0.7);
        }

        .tool-button {
            padding: 8px 15px;
            background: #2c3e50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        body.light-theme .tool-button {
            background: #3498db;
        }

        .tool-button.active {
            background: #3498db;
            font-weight: bold;
        }

        body.light-theme .tool-button.active {
            background: #2980b9;
        }

        .editor-content {
            display: flex;
            flex: 1;
            padding: 15px;
            gap: 20px;
        }

        .editor-canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #editor-canvas {
            background: #000;
            border-radius: 4px;
        }

        .editor-properties {
            width: 250px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
        }

        body.light-theme .editor-properties {
            background: rgba(200, 200, 200, 0.5);
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-group h4 {
            margin-bottom: 10px;
            color: #3498db;
        }

        body.light-theme .property-group h4 {
            color: #2980b9;
        }

        .property-input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #333;
            color: white;
        }

        body.light-theme .property-input {
            background: white;
            border-color: #ddd;
            color: #333;
        }

        .editor-controls {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
        }

        body.light-theme .editor-controls {
            background: rgba(200, 200, 200, 0.7);
        }

        /* Тесты */
        .test-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: none;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }

        body.light-theme .test-panel {
            background: rgba(255, 255, 255, 0.95);
        }

        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .test-title {
            font-size: 1.5rem;
            color: #FFD700;
        }

        body.light-theme .test-title {
            color: #D35400;
        }

        .test-close {
            background: #c0392b;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
        }

        .test-content {
            flex: 1;
            overflow-y: auto;
            padding: 0 10px;
        }

        .test-question {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        body.light-theme .test-question {
            background: rgba(240, 240, 240, 0.7);
        }

        .test-question h4 {
            margin-bottom: 15px;
            color: #3498db;
        }

        body.light-theme .test-question h4 {
            color: #2980b9;
        }

        .test-option {
            padding: 12px;
            margin: 8px 0;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        body.light-theme .test-option {
            background: rgba(240, 240, 240, 0.7);
            border-color: #ddd;
        }

        .test-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        body.light-theme .test-option:hover {
            background: rgba(230, 230, 230, 0.7);
        }

        .feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .feedback.success {
            background: rgba(46, 204, 113, 0.2);
            color: #27ae60;
        }

        .feedback.error {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .test-results {
            text-align: center;
        }

        .test-score {
            font-size: 2rem;
            margin: 20px 0;
            color: #3498db;
        }

        body.light-theme .test-score {
            color: #2980b9;
        }

        .sound-visualization {
            display: flex;
            gap: 2px;
            height: 20px;
            margin-top: 5px;
        }

        .sound-bar {
            flex: 1;
            background: #3498db;
            border-radius: 2px 2px 0 0;
            transition: height 0.05s;
        }

        .music-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            background: #e74c3c;
            border-radius: 50%;
            display: none;
        }

        /* Режим обучения */
        .learning-mode {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            display: none;
            z-index: 100;
        }

        body.light-theme .learning-mode {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .learning-mode h3 {
            margin-bottom: 10px;
            color: #FFD700;
        }

        body.light-theme .learning-mode h3 {
            color: #D35400;
        }

        /* Панель отладки */
        .debug-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 15px;
            display: none;
            z-index: 100;
            font-size: 0.9rem;
        }

        body.light-theme .debug-panel {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .debug-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .debug-item {
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-container">
            <div class="header">
                <h1>PacmanLearn</h1>
                <div class="header-controls">
                    <button id="mode-toggle" class="btn"><span>🎓</span> Режим обучения: Выкл</button>
                    <button id="theme-toggle" class="btn"><span>🌙</span> Темная тема</button>
                    <button id="achievements-btn" class="btn"><span>🏆</span> Достижения</button>
                    <button id="sound-toggle" class="btn"><span>🔊</span> Звук: Вкл</button>
                    <button id="pause-toggle" class="btn"><span>⏸️</span> Пауза</button>
                    <button id="level-editor-toggle" class="btn"><span>🛠️</span> Редактор</button>
                    <button id="save-progress" class="btn secondary"><span>💾</span> Сохранить</button>
                    <button id="load-progress" class="btn secondary"><span>📂</span> Загрузить</button>
                    <select id="difficulty-select" class="btn" style="padding:8px 10px;">
                        <option value="easy">Легко</option>
                        <option value="normal" selected>Норма</option>
                        <option value="hard">Сложно</option>
                    </select>
                </div>
            </div>
            
            <div class="game-area">
                <canvas id="game-canvas" width="440" height="520"></canvas>
                <div class="mini-map-container">
                    <canvas id="mini-map" width="100" height="100"></canvas>
                </div>
            </div>
            
            <div class="sound-visualization" id="sound-visualizer">
                <!-- Динамически генерируемые бары -->
            </div>
            <div class="music-indicator" id="music-indicator"></div>
            
            <div class="status-bar">
                <div class="score-info">
                    <div class="info-item">
                        <span>Очки</span>
                        <span id="score" class="info-value">0</span>
                    </div>
                    <div class="info-item">
                        <span>Рекорд</span>
                        <span id="high-score" class="info-value">0</span>
                    </div>
                </div>
                <div class="level-info">
                    <div class="info-item">
                        <span>Уровень</span>
                        <span id="level" class="info-value">1</span>
                    </div>
                    <div class="info-item">
                        <span>Жизни</span>
                        <span id="lives">❤️❤️❤️</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="learning-mode" id="learning-mode">
            <h3>Пояснение к коду</h3>
            <p id="learning-content">Нажмите на элемент игры, чтобы увидеть объяснение соответствующей части кода</p>
        </div>
        
        <div class="debug-panel" id="debug-panel">
            <h3>Режим отладки</h3>
            <div class="debug-content">
                <div class="debug-item">
                    <strong>Позиция Пакмана:</strong> <span id="debug-pos">10, 15</span>
                </div>
                <div class="debug-item">
                    <strong>Направление:</strong> <span id="debug-dir">right</span>
                </div>
                <div class="debug-item">
                    <strong>Скорость:</strong> <span id="debug-speed">200 мс</span>
                </div>
                <div class="debug-item">
                    <strong>Супер-еда:</strong> <span id="debug-power">Не активна</span>
                </div>
                <div class="debug-item">
                    <strong>FPS:</strong> <span id="debug-fps">60</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Панель достижений -->
    <div class="achievements-panel" id="achievements-panel">
        <div class="achievements-header">
            <h2 class="achievements-title">Достижения</h2>
            <button class="achievements-close" id="achievements-close">×</button>
        </div>
        <div id="achievements-list">
            <!-- Достижения будут добавлены здесь -->
        </div>
    </div>
    
    <!-- Уведомления -->
    <div class="notification" id="notification"></div>
    
    <!-- Модальные окна -->
    <div class="modal" id="game-over">
        <div class="modal-content">
            <h2>Игра окончена</h2>
            <p>Ваш счет: <span id="final-score" class="info-value">0</span></p>
            <div class="modal-buttons">
                <button class="btn" id="restart-game">Начать заново</button>
                <button class="btn secondary" id="close-game-over">Закрыть</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="level-complete">
        <div class="modal-content">
            <h2>Уровень пройден!</h2>
            <p>Поздравляем, вы успешно завершили уровень <span id="completed-level" class="info-value">1</span></p>
            <div class="modal-buttons">
                <button class="btn" id="next-level">Следующий уровень</button>
            </div>
        </div>
    </div>
    
    <!-- Панель уроков -->
    <div class="lesson-panel" id="lesson-panel">
        <div class="lesson-header">
            <h2 class="lesson-title" id="lesson-title"></h2>
            <button class="lesson-close" id="lesson-close">×</button>
        </div>
        <div class="lesson-content" id="lesson-content">
            <!-- Содержимое урока будет загружено здесь -->
        </div>
        <div class="lesson-controls">
            <button class="lesson-nav-btn" id="lesson-prev">Назад</button>
            <button class="lesson-nav-btn" id="lesson-next">Далее</button>
        </div>
    </div>
    
    <!-- Редактор уровней -->
    <div class="level-editor" id="level-editor">
        <div class="editor-toolbar">
            <button class="tool-button active" data-tool="wall">Стена</button>
            <button class="tool-button" data-tool="path">Путь</button>
            <button class="tool-button" data-tool="food">Еда</button>
            <button class="tool-button" data-tool="super-food">Супер-еда</button>
            <button class="tool-button" data-tool="pacman">Пакман</button>
            <button class="tool-button" data-tool="ghost">Привидение</button>
        </div>
        <div class="editor-content">
            <div class="editor-canvas-container">
                <canvas id="editor-canvas" width="440" height="520"></canvas>
            </div>
            <div class="editor-properties">
                <div class="property-group">
                    <h4>Свойства уровня</h4>
                    <input type="text" class="property-input" id="level-name" placeholder="Название уровня">
                    <input type="number" class="property-input" id="level-number" placeholder="Номер уровня" min="1">
                </div>
                <div class="property-group">
                    <h4>Действия</h4>
                    <button class="btn" id="save-level">Сохранить уровень</button>
                    <button class="btn secondary" id="load-level">Загрузить уровень</button>
                    <button class="btn secondary" id="reset-editor">Сбросить</button>
                </div>
            </div>
        </div>
        <div class="editor-controls">
            <button class="btn secondary" id="cancel-editor">Отмена</button>
            <button class="btn" id="apply-editor">Применить</button>
        </div>
    </div>
    
    <!-- Панель тестов -->
    <div class="test-panel" id="test-panel">
        <div class="test-header">
            <h2 class="test-title" id="test-title"></h2>
            <button class="test-close" id="test-close">×</button>
        </div>
        <div class="test-content" id="test-content">
            <!-- Содержимое теста будет загружено здесь -->
        </div>
    </div>
    
    <script>
        /**
         * Основной класс игры PacmanLearn
         * @class PacmanGame
         * @description Обучающая реализация классической игры с подробными комментариями
         * для изучения основ 2D-геймдева на JavaScript
         */
        class PacmanGame {
            /**
             * Создает экземпляр игры и инициализирует все компоненты
             * @constructor
             */
            constructor() {
                // Инициализация базовых параметров
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.cellSize = 22; // Размер ячейки в пикселях
                this.gameSpeed = 200; // Базовая скорость игры (мс)
                this.isRunning = false;
                this.isLearningMode = false;
                this.isSoundEnabled = true;
                this.currentLevel = 1;
                this.lastTimestamp = 0;
                this.animationFrameId = null;
                this.soundVisualizer = document.getElementById('sound-visualizer');
                this.musicIndicator = document.getElementById('music-indicator');
                this.editorMoveTimeout = null;
                this.codeModified = false;
                this.powerModeTimer = null;
                this.powerModeStart = 0;
                this.powerMode = false;
                this.isVisualizingPath = false;
                
                // Инициализация Пакмана
                this.pacman = {
                    x: 10,
                    y: 15,
                    direction: 'right',
                    nextDirection: null,
                    mouthAngle: 0,
                    mouthOpening: 0.1,
                    lastEatTime: 0,
                    eatInterval: 150 // Минимальное время между звуками поедания
                };
                
                // Инициализация привидений
                this.ghosts = [
                    {
                        x: 10,
                        y: 8,
                        direction: 'left',
                        mode: 'wandering', // wandering, chasing, fleeing
                        speed: 0.8,
                        color: 'red',
                        fearTimer: null
                    },
                    {
                        x: 9,
                        y: 9,
                        direction: 'up',
                        mode: 'wandering',
                        speed: 0.7,
                        color: 'pink',
                        fearTimer: null
                    },
                    {
                        x: 11,
                        y: 9,
                        direction: 'down',
                        mode: 'wandering',
                        speed: 0.6,
                        color: 'cyan',
                        fearTimer: null
                    },
                    {
                        x: 10,
                        y: 10,
                        direction: 'right',
                        mode: 'wandering',
                        speed: 0.5,
                        color: 'orange',
                        fearTimer: null
                    }
                ];
                
                // Инициализация игрового состояния
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('pacmanHighScore') || '0', 10);
                this.lives = 3; // Количество жизней
                this.foodCount = 0;
                this.totalFood = 0; // Общее количество еды на уровне
                this.particles = [];
                this.activeSounds = new Set();
                this.musicPlaying = false;
                this.musicTimeout = null;
                
                // Инициализация мини-карты
                this.miniMapCanvas = document.getElementById('mini-map');
                this.miniMapCtx = this.miniMapCanvas.getContext('2d');
                this.miniMapScale = 1;
                
                // Инициализация визуализации звука
                this.setupSoundVisualizer();
                
                // Инициализация дополнительных компонентов
                this.isDarkTheme = true;
                this.currentLesson = null;
                this.currentLessonStep = 0;
                this.currentTest = null;
                this.currentQuestion = 0;
                this.testScore = 0;
                this.codeModified = false;
                
                // Загрузка сохраненного прогресса
                this.loadProgress();
                
                // Настройка обработчиков событий
                this.setupEventListeners();
                
                // Загрузка уровней
                this.levels = this.loadLevels();
                this.currentMap = this.cloneMap(this.levels[0]);
                this.populateFoodIfMissing(this.currentMap);
                this.countTotalFood();
                
                // Обновление интерфейса
                this.updateUI();
                
                // Загрузка звуковых эффектов
                this.audioContext = null;
                this.sounds = this.loadSounds();
                this.ensureAudioContext = this.ensureAudioContext.bind(this);
                
                // Инициализация учебных материалов
                this.lessons = this.loadLessons();
                this.achievements = this.loadAchievements();
                this.tests = this.loadTests();
                
                // Инициализация дополнительных UI-компонентов
                this.initUIComponents();
                
                // Запуск основного игрового цикла
                this.startGameLoop();
            }
            
            /**
             * Экранирует HTML для безопасного отображения в код-блоке
             * @param {string} unsafe - Небезопасная строка
             * @returns {string} Экранированная строка
             */
            escapeHtml(unsafe) {
                return unsafe.replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }
            
            /**
             * Обеспечивает инициализацию AudioContext по требованию
             */
            ensureAudioContext() {
                if (!this.audioContext) {
                    try {
                        window.AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.audioContext = new AudioContext();
                    } catch (e) {
                        console.error('Web Audio API не поддерживается', e);
                        this.isSoundEnabled = false;
                    }
                }
            }
            
            /**
             * Активирует режим супер-еды
             */
            activatePowerMode() {
                this.collectFood(50);
                this.powerMode = true;
                this.powerModeStart = Date.now();
                
                // Изменяем цвет всех привидений на синий
                for (let i = 0; i < this.ghosts.length; i++) {
                    this.ghosts[i].color = 'blue';
                    this.ghosts[i].mode = 'fleeing';
                    
                    // Сбрасываем таймер страха, если он уже запущен
                    if (this.ghosts[i].fearTimer) {
                        clearTimeout(this.ghosts[i].fearTimer);
                        this.ghosts[i].fearTimer = null;
                    }
                }
                
                // Устанавливаем таймер для завершения режима супер-еды
                if (this.powerModeTimer) {
                    clearTimeout(this.powerModeTimer);
                }
                
                const powerDuration = this.difficulty === 'easy' ? 12000 : this.difficulty === 'hard' ? 8000 : 10000;
                this.powerModeTimer = setTimeout(() => {
                    this.powerMode = false;
                    // Возвращаем исходные цвета привидений
                    for (let i = 0; i < this.ghosts.length; i++) {
                        this.ghosts[i].color = ['red', 'pink', 'cyan', 'orange'][i % 4];
                        this.ghosts[i].mode = 'chasing';
                    }
                }, powerDuration);
            }
            
            /**
             * Сбрасывает позицию привидения после уничтожения
             * @param {number} index - Индекс привидения
             */
            resetGhost(index) {
                this.ghosts[index].x = 10;
                this.ghosts[index].y = 8;
                this.ghosts[index].direction = 'left';
                this.ghosts[index].mode = 'wandering';
                this.ghosts[index].color = ['red', 'pink', 'cyan', 'orange'][index];
            }
            
            /**
             * Проверяет столкновения между Пакманом и другими объектами
             */
            checkCollisions() {
                // Проверка столкновения с едой
                if (this.hasFood(this.pacman.x, this.pacman.y)) {
                    this.collectFood(10);
                }
                
                // Проверка столкновения с супер-едой
                if (this.hasPowerFood(this.pacman.x, this.pacman.y)) {
                    this.activatePowerMode();
                }
                
                // Проверка столкновения с привидениями
                for (let i = 0; i < this.ghosts.length; i++) {
                    const ghost = this.ghosts[i];
                    
                    // Проверка столкновения с привидением
                    if (this.pacman.x === ghost.x && this.pacman.y === ghost.y) {
                        // Если активен режим супер-еды, уничтожаем привидение
                        if (this.powerMode) {
                            this.score += 200;
                            this.resetGhost(i);
                            this.playSound('eat-ghost');
                            this.createParticles(ghost.x, ghost.y);
                            this.updateUI();
                            this.checkAchievements();
                        } 
                        // Обычное столкновение - конец игры
                        else {
                            this.gameOver();
                            return;
                        }
                    }
                }
            }
            
            /**
             * Обновляет режим привидения на основе текущего состояния игры
             */
            updateGhostMode() {
                const dx = this.pacman.x - this.ghosts[0].x;
                const dy = this.pacman.y - this.ghosts[0].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Режим супер-еды активен
                if (this.powerMode) {
                    this.ghosts[0].mode = 'fleeing';
                    this.ghosts[0].color = 'blue';
                } 
                // Близко к Пакману
                else if (distance < 5) {
                    this.ghosts[0].mode = 'chasing';
                    this.ghosts[0].color = 'red';
                }
                // Далеко от Пакмана
                else {
                    this.ghosts[0].mode = 'wandering';
                    this.ghosts[0].color = 'red';
                }
            }
            
            /**
             * Обрабатывает нажатие клавиш для управления Пакманом
             * @param {KeyboardEvent} event - Событие нажатия клавиши
             */
            handleKeyPress(event) {
                if (this.gameOverScreen) return;

                const key = event.key.toLowerCase();
                let direction = null;

                if (key === 'arrowup' || key === 'w') {
                    direction = 'up';
                } else if (key === 'arrowdown' || key === 's') {
                    direction = 'down';
                } else if (key === 'arrowleft' || key === 'a') {
                    direction = 'left';
                } else if (key === 'arrowright' || key === 'd') {
                    direction = 'right';
                }

                if (direction) {
                    this.pacman.setNextDirection(direction);
                }
            }

            /**
             * Основной игровой цикл
             */
            gameLoop() {
                this.updateUI();
                this.checkCollisions();
                this.updateGhostMode();

                if (this.pacman.isMoving()) {
                    this.pacman.move();
                }

                this.ghosts.forEach(ghost => {
                    if (ghost.isMoving()) {
                        ghost.move();
                    }
                });

                requestAnimationFrame(this.gameLoop.bind(this));
            }
            
            /**
             * Устанавливает начальное состояние игры
             * @param {string} difficulty - Уровень сложности ('easy', 'medium', 'hard')
             */
            init(difficulty) {
                this.difficulty = difficulty;
                this.score = 0;
                this.powerMode = false;
                this.powerModeTimer = 0;
                this.ghosts = [];
                this.pacman = new Pacman(14, 23);
                this.createGhosts();
                this.createMaze();
                this.gameLoop();
                window.addEventListener('keydown', this.handleKeyPress.bind(this));
            }
            
            /**
             * Останавливает игру и показывает экран конца игры
             */
            gameOver() {
                this.gameOverScreen = true;
                this.updateUI();
            }
            
            /**
             * Обновляет пользовательский интерфейс игры
             */
            updateUI() {
                document.getElementById('score').textContent = `Score: ${this.score}`;
                document.getElementById('lives').textContent = `Lives: ${this.pacman.lives}`;
                if (this.gameOverScreen) {
                    document.getElementById('game-over').style.display = 'block';
                }
            }
            
            /**
             * Проверяет достижения игрока
             */
            checkAchievements() {
                if (this.score >= 1000) {
                    this.unlockAchievement('1000 Points');
                }
                if (this.score >= 2000) {
                    this.unlockAchievement('2000 Points');
                }
                if (this.score >= 3000) {
                    this.unlockAchievement('3000 Points');
                }
                if (this.score >= 4000) {
                    this.unlockAchievement('4000 Points');
                }
                if (this.score >= 5000) {
                    this.unlockAchievement('5000 Points');
                }
            }
            
            /**
             * Подключает звуковой эффект
             * @param {string} soundName - Имя звукового эффекта
             */
            playSound(soundName) {
                const sound = new Audio(`sounds/${soundName}.mp3`);
                sound.play();
            }
            
            /**
             * Создает частицы в заданных координатах
             * @param {number} x - Координата по оси X
             * @param {number} y - Координата по оси Y
             */
            createParticles(x, y) {
                for (let i = 0; i < 50; i++) {
                    const particle = document.createElement('div');
                    particle.classList.add('particle');
                    particle.style.left = `${x * 20}px`;
                    particle.style.top = `${y * 20}px`;
                    particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    document.getElementById('game-container').appendChild(particle);
                    setTimeout(() => {
                        particle.remove();
                    }, 1000);
                }
            }
            
            /**
             * Создает привидений
             */
            createGhosts() {
                this.ghosts.push(new Ghost(14, 11, 'red'));
                this.ghosts.push(new Ghost(12, 14, 'pink'));
                this.ghosts.push(new Ghost(14, 14, 'cyan'));
                this.ghosts.push(new Ghost(16, 14, 'orange'));
            }
            
            /**
             * Создает лабиринт
             */
            createMaze() {
                const maze = document.getElementById('maze');
                maze.innerHTML = '';
                for (let y = 0; y < 28; y++) {
                    for (let x = 0; x < 28; x++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        if (this.isWall(x, y)) {
                            cell.classList.add('wall');
                        } else if (this.isDot(x, y)) {
                            cell.classList.add('dot');
                        } else if (this.isPowerPellet(x, y)) {
                            cell.classList.add('power-pellet');
                        }
                        maze.appendChild(cell);
                    }
                }
            }
            
            /**
             * Проверяет, является ли клетка стеной
             * @param {number} x - Координата по оси X
             * @param {number} y - Координата по оси Y
             * @returns {boolean} - Является ли клетка стеной
             */
            isWall(x, y) {
                return this.mazeData[y][x] === 1;
            }
            
            /**
             * Проверяет, является ли клетка точкой
             * @param {number} x - Координата по оси X
             * @param {number} y - Координата по оси Y
             * @returns {boolean} - Является ли клетка точкой
             */
            isDot(x, y) {
                return this.mazeData[y][x] === 2;
            }
            
            /**
             * Проверяет, является ли клетка супер-едой
             * @param {number} x - Координата по оси X
             * @param {number} y - Координата по оси Y
             * @returns {boolean} - Является ли клетка супер-едой
             */
            isPowerPellet(x, y) {
                return this.mazeData[y][x] === 3;
            }
            
            /**
             * Активирует режим супер-еды
             */
            activatePowerMode() {
                this.powerMode = true;
                this.powerModeTimer = 10000;
                this.playSound('power-pellet');
            }
            
            /**
             * Деактивирует режим супер-еды
             */
            deactivatePowerMode() {
                this.powerMode = false;
            }
            
            /**
             * Сбрасывает привидения в начальное состояние
             */
            resetGhosts() {
                this.ghosts.forEach(ghost => {
                    ghost.reset();
                });
            }
            
            /**
             * Сбрасывает конкретное привидение в начальное состояние
             * @param {number} index - Индекс привидения
             */
            resetGhost(index) {
                this.ghosts[index].reset();
            }
            
            /**
             * Разблокирует достижение
             * @param {string} achievement - Название достижения
             */
            unlockAchievement(achievement) {
                console.log(`Achievement unlocked: ${achievement}`);
            }
        }
        
        const game = new PacmanGame();
        game.init('medium');

                        ghost.mode = 'wandering';
                        ghost.color = ['red', 'pink', 'cyan', 'orange'][index];
                    }
                });
            }
            
            /**
             * Находит оптимальный путь к цели
             * @param {number} ghostIndex - Индекс привидения
             * @param {number} targetX - Целевая координата X
             * @param {number} targetY - Целевая координата Y
             * @returns {string} Лучшее направление движения
             */
            findPathToTarget(ghostIndex, targetX, targetY) {
                const ghost = this.ghosts[ghostIndex];
                const directions = ['up', 'down', 'left', 'right'];
                let bestDirection = null;
                // Определяем режим привидения для выбора стратегии
                const isFleeing = this.ghosts[ghostIndex].mode === 'fleeing';
                let bestScore = isFleeing ? -Infinity : Infinity;
                
                for (const direction of directions) {
                    const nextPos = this.getFuturePosition(ghost.x, ghost.y, direction);
                    
                    // Проверка валидности хода
                    if (!this.isValidMove(nextPos.x, nextPos.y, 'ghost') || 
                        direction === this.getOppositeDirection(ghost.direction)) {
                        continue;
                    }
                    
                    // Расчет расстояния до цели
                    const dx = targetX - nextPos.x;
                    const dy = targetY - nextPos.y;
                    const distance = dx * dx + dy * dy; // Используем квадрат расстояния для оптимизации
                    
                    if (!isFleeing && distance < bestScore) {
                        bestScore = distance;
                        bestDirection = direction;
                    }
                    if (isFleeing && distance > bestScore) {
                        bestScore = distance;
                        bestDirection = direction;
                    }
                }
                
                // Если нет допустимых направлений, остаемся на месте
                return bestDirection || ghost.direction;
            }
            
            /**
             * Возвращает противоположное направление
             * @param {string} direction - Текущее направление
             * @returns {string} Противоположное направление
             */
            getOppositeDirection(direction) {
                switch(direction) {
                    case 'up': return 'down';
                    case 'down': return 'up';
                    case 'left': return 'right';
                    case 'right': return 'left';
                    default: return direction;
                }
            }
            
            /**
             * Возвращает будущую позицию при движении в указанном направлении
             * @param {number} x - Текущая координата X
             * @param {number} y - Текущая координата Y
             * @param {string} direction - Направление движения
             * @returns {Object} Объект с координатами x и y
             */
            getFuturePosition(x, y, direction) {
                const nextPos = { x, y };
                switch(direction) {
                    case 'up': nextPos.y--; break;
                    case 'down': nextPos.y++; break;
                    case 'left': nextPos.x--; break;
                    case 'right': nextPos.x++; break;
                }
                return nextPos;
            }
            
            /**
             * Проверяет, является ли ход в указанном направлении допустимым
             * @param {number} x - Координата X
             * @param {number} y - Координата Y
             * @param {string} type - Тип объекта (pacman или ghost)
             * @returns {boolean} Допустим ли ход
             */
            isValidMove(x, y, type) {
                // Проверка выхода за границы карты
                if (y < 0 || y >= this.currentMap.length || 
                    x < 0 || x >= this.currentMap[0].length) {
                    return false;
                }
                
                // Проверка на стену
                if (this.currentMap[y][x] === 0) {
                    return false;
                }
                
                // Валидный ход
                return true;
            }
            
            /**
             * Проверяет наличие обычной еды в указанной позиции
             * @param {number} x - Координата X
             * @param {number} y - Координата Y
             * @returns {boolean} Есть ли еда
             */
            hasFood(x, y) {
                return this.currentMap[y] && this.currentMap[y][x] === 2;
            }
            
            /**
             * Проверяет наличие супер-еды в указанной позиции
             * @param {number} x - Координата X
             * @param {number} y - Координата Y
             * @returns {boolean} Есть ли супер-еда
             */
            hasPowerFood(x, y) {
                return this.currentMap[y] && this.currentMap[y][x] === 3;
            }
            
            /**
             * Собирает еду в указанной позиции
             * @param {number} points - Количество очков
             */
            collectFood(points) {
                const x = this.pacman.x;
                const y = this.pacman.y;
                
                // Удаляем еду с карты
                if (points === 10) {
                    this.currentMap[y][x] = 1;
                    this.foodCount++;
                    this.playSound('eat');
                } else if (points === 50) {
                    this.currentMap[y][x] = 1;
                    this.foodCount += 5;
                }
                
                // Добавляем очки
                this.score += points;
                this.updateUI();
                this.checkAchievements();
                
                // Проверка завершения уровня
                this.checkLevelCompletion();
            }
            
            /**
             * Проверяет завершение уровня
             */
            checkLevelCompletion() {
                if (this.foodCount >= this.totalFood) {
                    this.levelComplete();
                }
            }
            
            /**
             * Обрабатывает завершение уровня
             */
            levelComplete() {
                this.pauseGame();
                this.currentLevel++;
                
                // Зацикливаем уровни
                if (this.currentLevel > this.levels.length) {
                    this.currentLevel = 1;
                }
                
                // Увеличение скорости игры
                this.gameSpeed = Math.max(80, this.gameSpeed - 20);
                
                // Сброс состояния
                this.resetGameState();
                
                // Отображение уведомления
                const levelComplete = document.getElementById('level-complete');
                document.getElementById('completed-level').textContent = this.currentLevel - 1;
                levelComplete.style.display = 'block';
                
                setTimeout(() => {
                    levelComplete.style.display = 'none';
                    this.resumeGame();
                }, 2000);
                
                this.updateUI();
                this.checkAchievements();
            }
            
            /**
             * Обрабатывает окончание игры
             */
            gameOver() {
                this.lives--;
                if (this.lives <= 0) {
                    // Игра действительно окончена
                    this.pauseGame();
                    const statusEl = document.getElementById('game-status');
                    if (statusEl) statusEl.textContent = 'Игра окончена';
                    document.getElementById('final-score').textContent = this.score;
                    document.getElementById('game-over').style.display = 'block';
                    this.playSound('death');
                    this.createConfetti();
                } else {
                    // У игрока еще есть жизни, перезапускаем уровень
                    this.showNotification(`Осталось жизней: ${this.lives}`, 'error');
                    this.resetLevel();
                }
            }
            
            /**
             * Сбрасывает текущий уровень
             */
            resetLevel() {
                this.pauseGame();
                this.resetGameState();
                this.updateUI();
                this.resumeGame();
            }
            
            /**
             * Сбрасывает состояние игры к начальному
             */
            resetGameState() {
                // Сброс Пакмана
                this.pacman = {
                    x: 10,
                    y: 15,
                    direction: 'right',
                    nextDirection: null,
                    mouthAngle: 0,
                    mouthOpening: 0.1,
                    lastEatTime: 0,
                    eatInterval: 150
                };
                
                // Сброс всех привидений
                this.ghosts = [
                    {
                        x: 10,
                        y: 8,
                        direction: 'left',
                        mode: 'wandering',
                        speed: 0.8,
                        color: 'red',
                        fearTimer: null
                    },
                    {
                        x: 9,
                        y: 9,
                        direction: 'up',
                        mode: 'wandering',
                        speed: 0.7,
                        color: 'pink',
                        fearTimer: null
                    },
                    {
                        x: 11,
                        y: 9,
                        direction: 'down',
                        mode: 'wandering',
                        speed: 0.6,
                        color: 'cyan',
                        fearTimer: null
                    },
                    {
                        x: 10,
                        y: 10,
                        direction: 'right',
                        mode: 'wandering',
                        speed: 0.5,
                        color: 'orange',
                        fearTimer: null
                    }
                ];
                
                // Сброс игрового состояния
                this.powerMode = false;
                this.foodCount = 0;
                
                // Перезагрузка текущего уровня
                this.currentMap = this.cloneMap(this.levels[this.currentLevel - 1]);
                this.populateFoodIfMissing(this.currentMap);
                this.mapLayerDirty = true;
                this.countTotalFood();
            }
            
            /**
             * Перезапускает игру сначала
             */
            restartGame() {
                this.currentLevel = 1;
                this.lives = 3;
                this.score = 0;
                this.gameSpeed = 200;
                this.resetLevel();
                document.getElementById('game-over').style.display = 'none';
                this.updateUI();
            }
            
            /**
             * Обновляет UI, добавив проверки существования элементов
             */
            updateUI() {
                const scoreElement = document.getElementById('score');
                const highScoreElement = document.getElementById('high-score');
                const levelElement = document.getElementById('level');
                const livesElement = document.getElementById('lives');
                
                if (scoreElement) scoreElement.textContent = this.score;
                if (highScoreElement) highScoreElement.textContent = this.highScore;
                if (levelElement) levelElement.textContent = this.currentLevel;
                
                // Обновляем отображение жизней
                if (livesElement) {
                    livesElement.innerHTML = '';
                    for (let i = 0; i < this.lives; i++) {
                        const life = document.createElement('span');
                        life.innerHTML = '❤️';
                        livesElement.appendChild(life);
                    }
                }
                
                // Обновляем отладочную информацию
                this.updateDebugInfo();
                
                // Проверка рекорда
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('pacmanHighScore', this.highScore.toString());
                    if (highScoreElement) highScoreElement.textContent = this.highScore;
                }
            }
            
            /**
             * Обновляет информацию в панели отладки
             */
            updateDebugInfo() {
                const debugPos = document.getElementById('debug-pos');
                const debugDir = document.getElementById('debug-dir');
                const debugSpeed = document.getElementById('debug-speed');
                const debugPower = document.getElementById('debug-power');
                
                if (debugPos) debugPos.textContent = `${this.pacman.x}, ${this.pacman.y}`;
                if (debugDir) debugDir.textContent = this.pacman.direction;
                if (debugSpeed) debugSpeed.textContent = `${this.gameSpeed} мс`;
                if (debugPower) {
                    if (this.powerMode) {
                        const timeLeft = 10 - Math.floor((Date.now() - this.powerModeStart) / 1000);
                        debugPower.textContent = `Активна (${timeLeft} с)`;
                    } else {
                        debugPower.textContent = 'Не активна';
                    }
                }
            }
            
            /**
             * Обновляет мини-карту
             */
            updateMiniMap() {
                const mapHeight = this.currentMap.length;
                const mapWidth = this.currentMap[0].length;
                const scale = Math.min(
                    this.miniMapCanvas.width / mapWidth,
                    this.miniMapCanvas.height / mapHeight
                );
                
                this.miniMapCtx.clearRect(0, 0, this.miniMapCanvas.width, this.miniMapCanvas.height);
                
                for (let y = 0; y < mapHeight; y++) {
                    for (let x = 0; x < mapWidth; x++) {
                        const cell = this.currentMap[y][x];
                        
                        // Стены
                        if (cell === 0) {
                            this.miniMapCtx.fillStyle = '#34495e';
                            this.miniMapCtx.fillRect(x * scale, y * scale, scale, scale);
                        }
                        // Путь
                        else if (cell === 1) {
                            this.miniMapCtx.fillStyle = '#2c3e50';
                            this.miniMapCtx.fillRect(x * scale, y * scale, scale, scale);
                        }
                        // Еда
                        else if (cell === 2) {
                            this.miniMapCtx.fillStyle = '#ecf0f1';
                            this.miniMapCtx.fillRect(x * scale + scale/3, y * scale + scale/3, scale/3, scale/3);
                        }
                        // Супер-еда
                        else if (cell === 3) {
                            this.miniMapCtx.fillStyle = '#f1c40f';
                            this.miniMapCtx.fillRect(x * scale + scale/4, y * scale + scale/4, scale/2, scale/2);
                        }
                    }
                }
                
                // Позиция Пакмана
                this.miniMapCtx.fillStyle = '#f1c40f';
                this.miniMapCtx.beginPath();
                this.miniMapCtx.arc(
                    this.pacman.x * scale + scale/2,
                    this.pacman.y * scale + scale/2,
                    scale/2.5,
                    0,
                    Math.PI * 2
                );
                this.miniMapCtx.fill();
                
                // Позиции привидений
                for (const ghost of this.ghosts) {
                    this.miniMapCtx.fillStyle = ghost.color;
                    this.miniMapCtx.beginPath();
                    this.miniMapCtx.arc(
                        ghost.x * scale + scale/2,
                        ghost.y * scale + scale/2,
                        scale/2.5,
                        0,
                        Math.PI * 2
                    );
                    this.miniMapCtx.fill();
                }
            }
            
            /**
             * Отрисовывает карту
             */
            drawMap() {
                const mapHeight = this.currentMap.length;
                const mapWidth = this.currentMap[0].length;
                // Инициализируем offscreen слой
                if (!this.mapLayerCanvas) {
                    this.mapLayerCanvas = document.createElement('canvas');
                    this.mapLayerCanvas.width = this.canvas.width;
                    this.mapLayerCanvas.height = this.canvas.height;
                    this.mapLayerCtx = this.mapLayerCanvas.getContext('2d');
                    this.redrawStaticMapLayer();
                }
                
                // Если карта менялась, перерисуем слой
                if (this.mapLayerDirty) {
                    this.redrawStaticMapLayer();
                    this.mapLayerDirty = false;
                }
                
                // Рисуем слой карты
                this.ctx.drawImage(this.mapLayerCanvas, 0, 0);
                
                // Дорисовываем еду поверх
                for (let y = 0; y < mapHeight; y++) {
                    for (let x = 0; x < mapWidth; x++) {
                        const cell = this.currentMap[y][x];
                        const xPos = x * this.cellSize;
                        const yPos = y * this.cellSize;
                        if (cell === 2) {
                            this.ctx.fillStyle = 'white';
                            this.ctx.beginPath();
                            this.ctx.arc(xPos + this.cellSize/2, yPos + this.cellSize/2, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        } else if (cell === 3) {
                            this.ctx.fillStyle = '#FFD700';
                            this.ctx.beginPath();
                            this.ctx.arc(xPos + this.cellSize/2, yPos + this.cellSize/2, 5, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
            }

            /**
             * Перерисовывает статический слой карты (стены/путь)
             */
            redrawStaticMapLayer() {
                const mapHeight = this.currentMap.length;
                const mapWidth = this.currentMap[0].length;
                this.mapLayerCtx.fillStyle = '#000';
                this.mapLayerCtx.fillRect(0, 0, this.mapLayerCanvas.width, this.mapLayerCanvas.height);
                for (let y = 0; y < mapHeight; y++) {
                    for (let x = 0; x < mapWidth; x++) {
                        const cell = this.currentMap[y][x];
                        const xPos = x * this.cellSize;
                        const yPos = y * this.cellSize;
                        if (cell === 0) {
                            this.mapLayerCtx.fillStyle = '#2c3e50';
                            this.mapLayerCtx.fillRect(xPos, yPos, this.cellSize, this.cellSize);
                        } else if (cell === 1) {
                            this.mapLayerCtx.fillStyle = '#1a1a1a';
                            this.mapLayerCtx.fillRect(xPos, yPos, this.cellSize, this.cellSize);
                        }
                    }
                }
            }
            
            /**
             * Отрисовывает Пакмана
             */
            drawPacman() {
                const x = this.pacman.x * this.cellSize + this.cellSize/2;
                const y = this.pacman.y * this.cellSize + this.cellSize/2;
                const radius = this.cellSize/2 - 2;
                
                this.ctx.fillStyle = 'yellow';
                this.ctx.beginPath();
                
                // Рассчитываем угол рта в зависимости от направления
                let startAngle, endAngle;
                switch(this.pacman.direction) {
                    case 'right':
                        startAngle = this.pacman.mouthAngle;
                        endAngle = Math.PI * 2 - this.pacman.mouthAngle;
                        break;
                    case 'left':
                        startAngle = Math.PI + this.pacman.mouthAngle;
                        endAngle = Math.PI * 3 - this.pacman.mouthAngle;
                        break;
                    case 'up':
                        startAngle = Math.PI * 1.5 + this.pacman.mouthAngle;
                        endAngle = Math.PI * 1.5 - this.pacman.mouthAngle + Math.PI * 2;
                        break;
                    case 'down':
                        startAngle = Math.PI * 0.5 + this.pacman.mouthAngle;
                        endAngle = Math.PI * 0.5 - this.pacman.mouthAngle + Math.PI * 2;
                        break;
                    default:
                        startAngle = 0;
                        endAngle = Math.PI * 2;
                }
                
                this.ctx.arc(x, y, radius, startAngle, endAngle);
                this.ctx.lineTo(x, y);
                this.ctx.fill();
            }
            
            /**
             * Отрисовывает привидение
             */
            drawGhosts() {
                for (const ghost of this.ghosts) {
                    const x = ghost.x * this.cellSize;
                    const y = ghost.y * this.cellSize;
                    
                    // Тело привидения
                    this.ctx.fillStyle = ghost.color;
                    this.ctx.beginPath();
                    this.ctx.arc(
                        x + this.cellSize/3,
                        y + this.cellSize/2,
                        this.cellSize/3,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.arc(
                        x + 2 * this.cellSize/3,
                        y + this.cellSize/2,
                        this.cellSize/3,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fillRect(
                        x + this.cellSize/3,
                        y + this.cellSize/2,
                        this.cellSize/3,
                        this.cellSize/2
                    );
                    this.ctx.fill();
                    
                    // Закругленный низ
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, y + this.cellSize/2);
                    this.ctx.lineTo(x, y + this.cellSize);
                    this.ctx.lineTo(x + this.cellSize, y + this.cellSize);
                    this.ctx.lineTo(x + this.cellSize, y + this.cellSize/2);
                    
                    for (let i = 0; i < 3; i++) {
                        const step = this.cellSize / 6;
                        const xPos = x + step * (i * 2 + 1);
                        const yPos = y + this.cellSize - (i % 2 === 0 ? step : 0);
                        
                        this.ctx.lineTo(xPos, yPos);
                    }
                    
                    this.ctx.lineTo(x + this.cellSize, y + this.cellSize/2);
                    this.ctx.fill();
                    
                    // Зрачки (направление взгляда)
                    this.ctx.fillStyle = 'blue';
                    const pupilOffset = this.cellSize/8;
                    let pupilX = 0, pupilY = 0;
                    
                    switch(ghost.direction) {
                        case 'up': pupilY = -pupilOffset; break;
                        case 'down': pupilY = pupilOffset; break;
                        case 'left': pupilX = -pupilOffset; break;
                        case 'right': pupilX = pupilOffset; break;
                    }
                    
                    // Левый зрачок
                    this.ctx.beginPath();
                    this.ctx.arc(
                        x + this.cellSize/3 + pupilX,
                        y + this.cellSize/3 + pupilY,
                        this.cellSize/10,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                    
                    // Правый зрачок
                    this.ctx.beginPath();
                    this.ctx.arc(
                        x + 2 * this.cellSize/3 + pupilX,
                        y + this.cellSize/3 + pupilY,
                        this.cellSize/10,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }
            }
            
            /**
             * Анимирует рот Пакмана
             */
            animateMouth() {
                // Изменение угла рта
                this.pacman.mouthAngle += this.pacman.mouthOpening;
                
                // Смена направления открытия/закрытия
                if (this.pacman.mouthAngle >= 0.4 || this.pacman.mouthAngle <= 0.05) {
                    this.pacman.mouthOpening = -this.pacman.mouthOpening;
                }
            }
            
            /**
             * Создает частицы для визуальных эффектов
             * @param {number} x - Координата X
             * @param {number} y - Координата Y
             */
            createParticles(x, y) {
                const particleCount = 20;
                const baseSize = 3;
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.5 + Math.random() * 2;
                    
                    this.particles.push({
                        x: x * this.cellSize + this.cellSize/2,
                        y: y * this.cellSize + this.cellSize/2,
                        size: baseSize * (0.5 + Math.random()),
                        speedX: Math.cos(angle) * speed,
                        speedY: Math.sin(angle) * speed,
                        color: '#FFD700',
                        alpha: 1,
                        decay: 0.02 + Math.random() * 0.03
                    });
                }
            }
            
            /**
             * Обновляет состояние частиц
             */
            updateParticles() {
                // Оптимизированная обработка частиц
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    particle.alpha -= particle.decay;
                    
                    if (particle.alpha <= 0) {
                        this.particles.splice(i, 1);
                        continue;
                    }
                    
                    this.ctx.globalAlpha = particle.alpha;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.globalAlpha = 1;
            }
            
            /**
             * Создает конфетти для празднования
             */
            createConfetti() {
                const confettiCount = 100;
                
                for (let i = 0; i < confettiCount; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = -20;
                    const size = 5 + Math.random() * 10;
                    const color = `hsl(${Math.random() * 360}, 70%, 50%)`;
                    
                    this.particles.push({
                        x,
                        y,
                        size,
                        speedX: (Math.random() - 0.5) * 6,
                        speedY: 2 + Math.random() * 3,
                        color,
                        alpha: 1,
                        decay: 0.01
                    });
                }
            }
            
            /**
             * Обрабатывает перемещение Пакмана
             */
            movePacman() {
                // Проверка, можно ли изменить направление
                if (this.pacman.nextDirection) {
                    const nextPos = this.getFuturePosition(
                        this.pacman.x,
                        this.pacman.y,
                        this.pacman.nextDirection
                    );
                    
                    if (this.isValidMove(nextPos.x, nextPos.y, 'pacman')) {
                        this.pacman.direction = this.pacman.nextDirection;
                        this.pacman.nextDirection = null;
                    }
                }
                
                // Перемещение в текущем направлении
                const nextPos = this.getFuturePosition(
                    this.pacman.x,
                    this.pacman.y,
                    this.pacman.direction
                );
                
                if (this.isValidMove(nextPos.x, nextPos.y, 'pacman')) {
                    this.pacman.x = nextPos.x;
                    this.pacman.y = nextPos.y;
                    
                    // Туннели
                    if (this.pacman.x < 0) this.pacman.x = this.currentMap[0].length - 1;
                    if (this.pacman.x >= this.currentMap[0].length) this.pacman.x = 0;
                    if (this.pacman.y < 0) this.pacman.y = this.currentMap.length - 1;
                    if (this.pacman.y >= this.currentMap.length) this.pacman.y = 0;
                }
            }
            
            /**
             * Обрабатывает перемещение привидений
             */
            moveGhosts() {
                this.ghosts.forEach((ghost, index) => {
                    // Обновляем режим привидения
                    this.updateGhostMode();
                    
                    // Определяем цель в зависимости от режима
                    let targetX, targetY;
                    
                    if (ghost.mode === 'fleeing') {
                        // Цель - противоположная сторона от Пакмана
                        targetX = this.pacman.x + (this.pacman.x - ghost.x) * 2;
                        targetY = this.pacman.y + (this.pacman.y - ghost.y) * 2;
                    } else {
                        // Цель - Пакман
                        targetX = this.pacman.x;
                        targetY = this.pacman.y;
                    }
                    
                    // Находим оптимальный путь к цели
                    const direction = this.findPathToTarget(index, targetX, targetY);
                    
                    // Перемещаем привидение
                    const nextPos = this.getFuturePosition(ghost.x, ghost.y, direction);
                    
                    if (this.isValidMove(nextPos.x, nextPos.y, 'ghost')) {
                        ghost.x = nextPos.x;
                        ghost.y = nextPos.y;
                        ghost.direction = direction;
                        
                        // Туннели
                        if (ghost.x < 0) ghost.x = this.currentMap[0].length - 1;
                        if (ghost.x >= this.currentMap[0].length) ghost.x = 0;
                        if (ghost.y < 0) ghost.y = this.currentMap.length - 1;
                        if (ghost.y >= this.currentMap.length) ghost.y = 0;
                    }
                });
            }
            
            /**
             * Обновляет игру
             */
            update() {
                this.movePacman();
                this.moveGhosts();
                this.checkCollisions();
                this.checkLevelCompletion();
            }
            
            /**
             * Отрисовывает игру
             */
            draw() {
                // Очистка холста
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Рисуем карту
                this.drawMap();
                
                // Рисуем Пакмана
                this.drawPacman();
                
                // Рисуем привидений
                this.drawGhosts();
                
                // Обновляем частицы
                this.updateParticles();
                
                // Обновляем мини-карту
                this.updateMiniMap();
                
                // Визуализация пути (для обучения)
                if (this.isVisualizingPath) {
                    this.visualizePathfinding();
                }
            }
            
            /**
             * Визуализирует алгоритм поиска пути
             */
            visualizePathfinding() {
                // Отображаем целевые точки для привидений
                this.ghosts.forEach((ghost, index) => {
                    let targetX, targetY;
                    
                    if (ghost.mode === 'fleeing') {
                        targetX = this.pacman.x + (this.pacman.x - ghost.x) * 2;
                        targetY = this.pacman.y + (this.pacman.y - ghost.y) * 2;
                    } else {
                        targetX = this.pacman.x;
                        targetY = this.pacman.y;
                    }
                    
                    // Ограничиваем целевые координаты
                    targetX = Math.max(0, Math.min(targetX, this.currentMap[0].length - 1));
                    targetY = Math.max(0, Math.min(targetY, this.currentMap.length - 1));
                    
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(
                        targetX * this.cellSize + this.cellSize/2,
                        targetY * this.cellSize + this.cellSize/2,
                        this.cellSize/3,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.stroke();
                });
            }
            
            /**
             * Запускает игровой цикл с использованием фиксированного шага обновления
             */
            startGameLoop() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                
                const FIXED_TIMESTEP = 16.67; // ~60 FPS
                let accumulator = 0;
                let lastFpsTime = performance.now();
                let frames = 0;
                
                const gameLoop = (timestamp) => {
                    // Вычисляем deltaTime для независимости от частоты кадров
                    const deltaTime = timestamp - this.lastTimestamp;
                    accumulator += deltaTime;
                    
                    // Обрабатываем физику с фиксированным шагом
                    while (accumulator >= FIXED_TIMESTEP) {
                        this.update();
                        accumulator -= FIXED_TIMESTEP;
                    }
                    
                // Отрисовка игры
                this.draw();
                this.animateMouth();
                    
                    this.lastTimestamp = timestamp;
                    this.animationFrameId = requestAnimationFrame(gameLoop);

                    // FPS
                    frames++;
                    if (timestamp - lastFpsTime >= 500) {
                        const fps = Math.round((frames * 1000) / (timestamp - lastFpsTime));
                        const fpsEl = document.getElementById('debug-fps');
                        if (fpsEl) fpsEl.textContent = `${fps}`;
                        frames = 0;
                        lastFpsTime = timestamp;
                    }
                };
                
                this.isRunning = true;
                this.lastTimestamp = performance.now();
                this.animationFrameId = requestAnimationFrame(gameLoop);
                
                // Запускаем музыку
                if (this.isSoundEnabled) {
                    this.ensureAudioContext();
                    this.sounds.music.play(this);
                }
            }
            
            /**
             * Приостанавливает игру
             */
            pauseGame() {
                this.isRunning = false;
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                // Останавливаем музыку
                if (this.isSoundEnabled) {
                    this.sounds.music.stop(this);
                }
            }
            
            /**
             * Возобновляет игру
             */
            resumeGame() {
                if (!this.isRunning) {
                    this.startGameLoop();
                }
            }
            
            /**
             * Обрабатывает нажатие клавиш для управления Пакманом
             * @param {KeyboardEvent} e - Событие нажатия клавиши
             */
            handleKey(e) {
                if (!this.isRunning) return;
                
                // Сохраняем направление для последующего применения
                switch(e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        this.pacman.nextDirection = 'up';
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        this.pacman.nextDirection = 'down';
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        this.pacman.nextDirection = 'left';
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        this.pacman.nextDirection = 'right';
                        e.preventDefault();
                        break;
                    case 'l':
                        if (e.ctrlKey) {
                            this.openLesson(1);
                            e.preventDefault();
                        }
                        break;
                }
            }
            
            /**
             * Обрабатывает клик по игровому полю в режиме обучения
             * @param {MouseEvent} e - Событие клика
             */
            handleCanvasClick(e) {
                if (!this.isLearningMode) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / this.cellSize);
                const y = Math.floor((e.clientY - rect.top) / this.cellSize);
                
                let explanation = '';
                if (x === this.pacman.x && y === this.pacman.y) {
                    explanation = 'Это Пакман! Управляет игрок. Движется по лабиринту, собирая еду и избегая привидений.';
                } else {
                    for (let i = 0; i < this.ghosts.length; i++) {
                        if (x === this.ghosts[i].x && y === this.ghosts[i].y) {
                            explanation = 'Это привидение! Имеет три режима: блуждание, преследование и бегство (при активации супер-еды).';
                            break;
                        }
                    }
                }
                
                if (!explanation && this.currentMap[y] && this.currentMap[y][x] === 2) {
                    explanation = 'Обычная еда. Дает 10 очков при сборе.';
                } else if (!explanation && this.currentMap[y] && this.currentMap[y][x] === 3) {
                    explanation = 'Супер-еда. Дает 50 очков и активирует режим охоты на 10 секунд.';
                } else if (!explanation && this.currentMap[y] && this.currentMap[y][x] === 0) {
                    explanation = 'Стена. Пакман и привидение не могут проходить сквозь стены.';
                }
                
                if (explanation) {
                    document.getElementById('learning-content').textContent = explanation;
                    document.getElementById('learning-mode').style.display = 'block';
                }
            }
            
            /**
             * Обрабатывает перемещение мыши в редакторе уровней с debounce
             * @param {MouseEvent} e - Событие движения мыши
             */
            handleEditorMouseMove(e) {
                if (this.isDrawing) {
                    if (!this.editorMoveTimeout) {
                        this.editorMoveTimeout = setTimeout(() => {
                            this.updateEditorCell(e);
                            this.editorMoveTimeout = null;
                        }, 50);
                    }
                }
            }
            
            /**
             * Настраивает обработчики событий
             */
            setupEventListeners() {
                // Обработка клавиш
                document.addEventListener('keydown', (e) => this.handleKey(e));
                // Горячие клавиши паузы
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        const btn = document.getElementById('pause-toggle');
                        if (this.isRunning) {
                            this.pauseGame();
                            if (btn) btn.innerHTML = `<span>▶️</span> Продолжить`;
                        } else {
                            if (btn) btn.innerHTML = `<span>⏸️</span> Пауза`;
                            this.resumeGame();
                        }
                    }
                });
                
                // Обработка клика по холсту
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                
                // Управление игрой
                document.getElementById('mode-toggle').addEventListener('click', () => {
                    this.isLearningMode = !this.isLearningMode;
                    const button = document.getElementById('mode-toggle');
                    button.innerHTML = `<span>🎓</span> Режим обучения: ${this.isLearningMode ? 'Вкл' : 'Выкл'}`;
                    this.showNotification(`Режим обучения: ${this.isLearningMode ? 'включен' : 'выключен'}`);
                });
                
                document.getElementById('theme-toggle').addEventListener('click', () => this.toggleTheme());
                document.getElementById('achievements-btn').addEventListener('click', () => this.showAchievementsPanel());
                
                // Управление звуком
                document.getElementById('sound-toggle').addEventListener('click', () => {
                    this.isSoundEnabled = !this.isSoundEnabled;
                    const btn = document.getElementById('sound-toggle');
                    btn.innerHTML = `<span>${this.isSoundEnabled ? '🔊' : '🔇'}</span> Звук: ${this.isSoundEnabled ? 'Вкл' : 'Выкл'}`;
                    if (!this.isSoundEnabled) {
                        this.sounds.music.stop(this);
                    } else if (this.isRunning) {
                        this.ensureAudioContext();
                        this.sounds.music.play(this);
                    }
                });
                
                // Пауза
                document.getElementById('pause-toggle').addEventListener('click', () => {
                    if (this.isRunning) {
                        this.pauseGame();
                        document.getElementById('pause-toggle').innerHTML = `<span>▶️</span> Продолжить`;
                    } else {
                        document.getElementById('pause-toggle').innerHTML = `<span>⏸️</span> Пауза`;
                        this.resumeGame();
                    }
                });
                
                // Кнопки управления
                document.getElementById('restart-game').addEventListener('click', () => this.restartGame());
                document.getElementById('close-game-over').addEventListener('click', () => {
                    document.getElementById('game-over').style.display = 'none';
                    this.resumeGame();
                });
                
                document.getElementById('next-level').addEventListener('click', () => {
                    document.getElementById('level-complete').style.display = 'none';
                    this.resumeGame();
                });
                
                // Закрытие панели достижений
                document.getElementById('achievements-close').addEventListener('click', () => {
                    document.getElementById('achievements-panel').classList.remove('open');
                });
                
                // Редактор уровней
                document.getElementById('level-editor-toggle').addEventListener('click', () => this.openLevelEditor());
                document.getElementById('cancel-editor').addEventListener('click', () => this.closeLevelEditor());
                document.getElementById('apply-editor').addEventListener('click', () => this.applyLevelChanges());
                document.getElementById('save-level').addEventListener('click', () => this.applyLevelChanges());
                
                // Обработка уроков
                document.getElementById('lesson-close').addEventListener('click', () => this.closeLesson());
                document.getElementById('lesson-prev').addEventListener('click', () => this.previousLessonStep());
                document.getElementById('lesson-next').addEventListener('click', () => this.nextLessonStep());
                
                // Обработка тестов
                document.getElementById('test-close').addEventListener('click', () => this.closeTest());
                
                // Прогресс
                document.getElementById('save-progress').addEventListener('click', () => this.saveProgress());
                document.getElementById('load-progress').addEventListener('click', () => {
                    if (this.loadProgress()) {
                        this.showNotification('Прогресс загружен');
                    } else {
                        this.showNotification('Нет сохраненного прогресса', 'error');
                    }
                });

                // Настраиваем консоль разработчика
                this.setupDevConsole();
            }
            
            /**
             * Настраивает консоль разработчика с сохранением контекста
             */
            setupDevConsole() {
                const gameInstance = this;
                window.game = {
                    /**
                     * Увеличивает скорость игры
                     * @param {number} [amount=20] - На сколько уменьшить задержку
                     */
                    increaseSpeed: function(amount = 20) {
                        gameInstance.gameSpeed = Math.max(50, gameInstance.gameSpeed - amount);
                        gameInstance.codeModified = true;
                        gameInstance.checkAchievements();
                        gameInstance.showNotification('Скорость игры увеличена!');
                    },
                    
                    /**
                     * Добавляет новое привидение
                     */
                    addGhost: function() {
                        // Создаем новое привидение
                        const colors = ['red', 'pink', 'cyan', 'orange', 'purple', 'green'];
                        gameInstance.ghosts.push({
                            x: 10,
                            y: 8,
                            direction: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
                            mode: 'wandering',
                            speed: 0.5 + Math.random() * 0.5,
                            color: colors[Math.floor(Math.random() * colors.length)],
                            fearTimer: null
                        });
                        
                        gameInstance.codeModified = true;
                        gameInstance.checkAchievements();
                        gameInstance.showNotification('Добавлено новое привидение!');
                    },
                    
                    /**
                     * Телепортирует Пакмана в указанную позицию
                     * @param {number} x - Координата X
                     * @param {number} y - Координата Y
                     */
                    teleport: function(x, y) {
                        gameInstance.pacman.x = x;
                        gameInstance.pacman.y = y;
                        gameInstance.codeModified = true;
                        gameInstance.checkAchievements();
                        gameInstance.showNotification(`Пакман телепортирован в (${x}, ${y})`);
                    },
                    
                    /**
                     * Переключает режим обучения
                     */
                    toggleLearningMode: function() {
                        gameInstance.isLearningMode = !gameInstance.isLearningMode;
                        const button = document.getElementById('mode-toggle');
                        if (button) {
                            button.innerHTML = `<span>🎓</span> Режим обучения: ${gameInstance.isLearningMode ? 'Вкл' : 'Выкл'}`;
                        }
                        gameInstance.showNotification(`Режим обучения: ${gameInstance.isLearningMode ? 'включен' : 'выключен'}`);
                    },
                    
                    /**
                     * Включает визуализацию алгоритмов
                     */
                    enablePathVisualization: function() {
                        gameInstance.isVisualizingPath = true;
                        gameInstance.showNotification('Визуализация алгоритмов включена');
                    },
                    
                    /**
                     * Отключает визуализацию алгоритмов
                     */
                    disablePathVisualization: function() {
                        gameInstance.isVisualizingPath = false;
                        gameInstance.showNotification('Визуализация алгоритмов выключена');
                    }
                };
            }
            
            /**
             * Загружает уровни игры
             * @returns {Array} Массив уровней
             */
            loadLevels() {
                return [
                    // Уровень 1: Базовый лабиринт
                    [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
                        [0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0],
                        [0,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0],
                        [0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,1,0,1,0],
                        [0,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0],
                        [0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0],
                        [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ],
                    
                    // Уровень 2: Усложненная структура
                    [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0],
                        [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0],
                        [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ],
                    
                    // Уровень 3: Лабиринт с тупиками
                    [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0],
                        [0,2,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,2,0],
                        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0],
                        [0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0],
                        [0,0,0,0,1,0,0,0,2,0,2,0,0,0,1,0,0,0,0,0],
                        [0,0,0,0,1,0,2,0,0,2,0,0,2,0,1,0,0,0,0,0],
                        [0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0],
                        [0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0],
                        [0,3,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,3,1,0],
                        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ],
                    
                    // Уровень 4: Звездный лабиринт
                    [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0],
                        [0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0],
                        [0,2,0,0,0,1,0,0,2,3,3,2,0,0,1,0,0,0,2,0],
                        [0,1,0,0,0,1,0,0,3,2,2,3,0,0,1,0,0,0,1,0],
                        [0,1,0,1,0,1,0,0,2,3,3,2,0,0,1,0,1,0,1,0],
                        [0,1,1,1,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0],
                        [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0],
                        [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ],
                    
                    // Уровень 5: Спиральный лабиринт
                    [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
                        [0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0],
                        [0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0],
                        [0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0],
                        [0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0],
                        [0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0],
                        [0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0],
                        [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ]
                ];
            }
            
            /**
             * Загружает учебные материалы
             * @returns {Array} Массив уроков
             */
            loadLessons() {
                return [
                    {
                        id: 1,
                        title: "Основы игрового цикла",
                        description: "Узнайте, как работает основной игровой цикл и почему он важен для 2D-игр.",
                        steps: [
                            {
                                highlight: "gameLoop",
                                explanation: "Метод gameLoop - сердце любой игры. Он вызывается постоянно и обновляет состояние игры.",
                                codeSnippet: `startGameLoop() {
    if (!this.isRunning) return;
    
    const FIXED_TIMESTEP = 16.67; // ~60 FPS
    let accumulator = 0;
    
    const gameLoop = (timestamp) => {
        // Вычисляем deltaTime для независимости от частоты кадров
        const deltaTime = timestamp - this.lastTimestamp;
        accumulator += deltaTime;
        
        // Обрабатываем физику с фиксированным шагом
        while (accumulator >= FIXED_TIMESTEP) {
            this.update();
            accumulator -= FIXED_TIMESTEP;
        }
        
        // Отрисовка игры
        this.draw();
        this.animateMouth();
        this.updateParticles();
        
        this.lastTimestamp = timestamp;
        this.animationFrameId = requestAnimationFrame(gameLoop);
    };
    
    this.lastTimestamp = performance.now();
    this.animationFrameId = requestAnimationFrame(gameLoop);
}`
                            },
                            {
                                highlight: "update()",
                                explanation: "Метод update() обрабатывает логику игры: перемещение объектов, проверку коллизий и т.д.",
                                codeSnippet: `update() {
    this.movePacman();
    this.moveGhosts();
    this.checkCollisions();
    this.checkLevelCompletion();
}`
                            },
                            {
                                highlight: "draw()",
                                explanation: "Метод draw() отвечает за отрисовку всех объектов на экране.",
                                codeSnippet: `draw() {
    // Очистка холста
    this.ctx.fillStyle = 'black';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Рисуем карту
    this.drawMap();
    
    // Рисуем Пакмана
    this.drawPacman();
    
    // Рисуем привидений
    this.drawGhosts();
    
    // Обновляем мини-карту
    this.updateMiniMap();
}`
                            }
                        ]
                    },
                    {
                        id: 2,
                        title: "Обработка ввода",
                        description: "Изучите, как обрабатывать пользовательский ввод в играх на JavaScript.",
                        steps: [
                            {
                                highlight: "handleKey",
                                explanation: "Метод handleKey обрабатывает нажатия клавиш для управления Пакманом.",
                                codeSnippet: `handleKey(e) {
    if (!this.isRunning) return;
    
    // Сохраняем направление для последующего применения
    switch(e.key) {
        case 'ArrowUp':
            this.pacman.nextDirection = 'up';
            e.preventDefault();
            break;
        case 'ArrowDown':
            this.pacman.nextDirection = 'down';
            e.preventDefault();
            break;
        case 'ArrowLeft':
            this.pacman.nextDirection = 'left';
            e.preventDefault();
            break;
        case 'ArrowRight':
            this.pacman.nextDirection = 'right';
            e.preventDefault();
            break;
    }
}`
                            },
                            {
                                highlight: "movePacman",
                                explanation: "Метод movePacman обрабатывает перемещение Пакмана с учетом направления и проверки на стену.",
                                codeSnippet: `movePacman() {
    // Проверка, можно ли изменить направление
    if (this.pacman.nextDirection) {
        const nextPos = this.getFuturePosition(
            this.pacman.x,
            this.pacman.y,
            this.pacman.nextDirection
        );
        
        if (this.isValidMove(nextPos.x, nextPos.y, 'pacman')) {
            this.pacman.direction = this.pacman.nextDirection;
            this.pacman.nextDirection = null;
        }
    }
    
    // Перемещение в текущем направлении
    const nextPos = this.getFuturePosition(
        this.pacman.x,
        this.pacman.y,
        this.pacman.direction
    );
    
    if (this.isValidMove(nextPos.x, nextPos.y, 'pacman')) {
        this.pacman.x = nextPos.x;
        this.pacman.y = nextPos.y;
    }
}`

                    },
                    {
                        id: 3,
                        title: "ИИ привидения",
                        description: "Изучите, как создать простой, но эффективный искусственный интеллект для привидений.",
                        steps: [
                            {
                                highlight: "updateGhostMode",
                                explanation: "Метод updateGhostMode определяет текущий режим привидения на основе расстояния до Пакмана.",
                                codeSnippet: `updateGhostMode() {
    this.ghosts.forEach((ghost, index) => {
        const dx = this.pacman.x - ghost.x;
        const dy = this.pacman.y - ghost.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const chaseThreshold = this.difficulty === 'easy' ? 4 : this.difficulty === 'hard' ? 7 : 5;
        
        // Режим супер-еды активен
        if (this.powerMode) {
            ghost.mode = 'fleeing';
            ghost.color = 'blue';
        } 
        // Близко к Пакману
        else if (distance < chaseThreshold) {
            ghost.mode = 'chasing';
            ghost.color = ['red', 'pink', 'cyan', 'orange'][index];
        }
        // Далеко от Пакмана
        else {
            ghost.mode = 'wandering';
            ghost.color = ['red', 'pink', 'cyan', 'orange'][index];
        }
    });
}`
                            },
                            {
                                highlight: "findPathToTarget",
                                explanation: "Метод findPathToTarget использует простой алгоритм поиска пути для определения оптимального направления движения.",
                                codeSnippet: `findPathToTarget(ghostIndex, targetX, targetY) {
    const ghost = this.ghosts[ghostIndex];
    const directions = ['up', 'down', 'left', 'right'];
    let bestDirection = null;
    // Определяем режим привидения для выбора стратегии
    const isFleeing = this.ghosts[ghostIndex].mode === 'fleeing';
    let bestScore = isFleeing ? -Infinity : Infinity;
    
    for (const direction of directions) {
        const nextPos = this.getFuturePosition(ghost.x, ghost.y, direction);
        
        // Проверка валидности хода
        if (!this.isValidMove(nextPos.x, nextPos.y, 'ghost') ||
            direction === this.getOppositeDirection(ghost.direction)) {
            continue;
        }
        
        // Расчет расстояния до цели
        const dx = targetX - nextPos.x;
        const dy = targetY - nextPos.y;
        const distance = dx * dx + dy * dy; // Используем квадрат расстояния для оптимизации
        
        if (!isFleeing && distance < bestScore) {
            bestScore = distance;
            bestDirection = direction;
        }
        if (isFleeing && distance > bestScore) {
            bestScore = distance;
            bestDirection = direction;
        }
    }
    
    // Если нет допустимых направлений, остаемся на месте
    return bestDirection || ghost.direction;
}`
                            }
                        title: 'Мастер лабиринта',
                        description: 'Пройдите первый уровень',
                        condition: () => this.currentLevel > 1,
                        earned: false
                    },
                    {
                        id: 'power-mode',
                        title: 'Супергерой',
                        description: 'Активируйте режим супер-еды',
                        condition: () => this.powerMode,
                        earned: false
                    },
                    {
                        id: 'code-modified',
                        title: 'Разработчик',
                        description: 'Измените игровой код через консоль разработчика',
                        condition: () => this.codeModified,
                        earned: false
                    },
                    {
                        id: 'ghost-destroyed',
                        title: 'Охотник',
                        description: 'Уничтожьте привидение в режиме супер-еды',
                        condition: () => this.score >= 210,
                        earned: false
                    },
                    {
                        id: 'five-levels',
                        title: 'Профессионал',
                        description: 'Пройдите 5 уровней подряд',
                        condition: () => this.currentLevel > 5,
                        earned: false
                    }
                ];
            }
            
            /**
             * Загружает тесты
             * @returns {Array} Массив тестов
             */
            loadTests() {
                return [
                    {
                        id: 'game-loop',
                        title: 'Тест: Игровой цикл',
                        questions: [
                            {
                                question: 'Какой метод является основой игрового цикла?',
                                options: ['update()', 'draw()', 'gameLoop()', 'startGameLoop()'],
                                correctAnswer: 2,
                                explanation: 'Метод gameLoop() вызывается постоянно через requestAnimationFrame и является основой игрового цикла.'
                            },
                            {
                                question: 'Что делает метод update()?',
                                options: ['Отрисовывает игру', 'Обрабатывает логику игры', 'Управляет звуком', 'Обрабатывает ввод пользователя'],
                                correctAnswer: 1,
                                explanation: 'Метод update() отвечает за обработку игровой логики: перемещение объектов, проверку коллизий и т.д.'
                            },
                            {
                                question: 'Какой метод используется для отрисовки игры?',
                                options: ['update()', 'draw()', 'gameLoop()', 'render()'],
                                correctAnswer: 1,
                                explanation: 'Метод draw() отвечает за отрисовку всех объектов на экране.'
                            }
                        ]
                    },
                    {
                        id: 'input-handling',
                        title: 'Тест: Обработка ввода',
                        questions: [
                            {
                                question: 'Какой метод обрабатывает нажатия клавиш?',
                                options: ['handleInput()', 'handleKey()', 'processInput()', 'processKey()'],
                                correctAnswer: 1,
                                explanation: 'Метод handleKey() обрабатывает нажатия клавиш для управления Пакманом.'
                            },
                            {
                                question: 'Какое свойство используется для предварительного задания направления Пакмана?',
                                options: ['direction', 'nextDirection', 'targetDirection', 'pendingDirection'],
                                correctAnswer: 1,
                                explanation: 'Свойство nextDirection используется для предварительного задания направления, пока текущее направление недоступно.'
                            }
                        ]
                    }
                ];
            }
            
            /**
             * Загружает звуковые эффекты
             * @returns {Object} Объект со звуками
             */
            loadSounds() {
                return {
                    eat: {
                        play: (game) => {
                            if (!game.isSoundEnabled || game.activeSounds.has('eat')) return;
                            
                            game.activeSounds.add('eat');
                            setTimeout(() => {
                                game.activeSounds.delete('eat');
                            }, 200);
                            
                            // Создаем простой звук
                            if (game.audioContext) {
                                const oscillator = game.audioContext.createOscillator();
                                const gainNode = game.audioContext.createGain();
                                
                                oscillator.connect(gainNode);
                                gainNode.connect(game.audioContext.destination);
                                
                                oscillator.type = 'sine';
                                oscillator.frequency.value = 440;
                                gainNode.gain.value = 0.1;
                                
                                oscillator.start();
                                oscillator.stop(game.audioContext.currentTime + 0.1);
                            }
                        }
                    },
                    'eat-ghost': {
                        play: (game) => {
                            if (!game.isSoundEnabled || game.activeSounds.has('eat-ghost')) return;
                            
                            game.activeSounds.add('eat-ghost');
                            setTimeout(() => {
                                game.activeSounds.delete('eat-ghost');
                            }, 500);
                            
                            if (game.audioContext) {
                                const oscillator = game.audioContext.createOscillator();
                                const gainNode = game.audioContext.createGain();
                                
                                oscillator.connect(gainNode);
                                gainNode.connect(game.audioContext.destination);
                                
                                oscillator.type = 'sine';
                                oscillator.frequency.value = 880;
                                gainNode.gain.value = 0.2;
                                
                                oscillator.start();
                                oscillator.stop(game.audioContext.currentTime + 0.3);
                            }
                        }
                    },
                    death: {
                        play: (game) => {
                            if (!game.isSoundEnabled || game.activeSounds.has('death')) return;
                            
                            game.activeSounds.add('death');
                            setTimeout(() => {
                                game.activeSounds.delete('death');
                            }, 1000);
                            
                            if (game.audioContext) {
                                const oscillator = game.audioContext.createOscillator();
                                const gainNode = game.audioContext.createGain();
                                
                                oscillator.connect(gainNode);
                                gainNode.connect(game.audioContext.destination);
                                
                                oscillator.type = 'sine';
                                oscillator.frequency.value = 110;
                                gainNode.gain.value = 0.3;
                                
                                oscillator.start();
                                oscillator.stop(game.audioContext.currentTime + 0.8);
                            }
                        }
                    },
                    music: {
                        play: (game) => {
                            if (!game.isSoundEnabled || game.musicPlaying) return;
                            
                            game.musicPlaying = true;
                            game.musicIndicator.style.display = 'block';
                            
                            // Создаем простую мелодию
                            const sequence = [
                                { freq: 261.63, dur: 0.2 }, // C4
                                { freq: 293.66, dur: 0.2 }, // D4
                                { freq: 329.63, dur: 0.2 }, // E4
                                { freq: 349.23, dur: 0.2 }, // F4
                                { freq: 392.00, dur: 0.2 }, // G4
                                { freq: 349.23, dur: 0.2 }, // F4
                                { freq: 329.63, dur: 0.2 }, // E4
                                { freq: 293.66, dur: 0.2 }  // D4
                            ];
                            
                            const startTime = game.audioContext.currentTime;
                            const totalDuration = sequence.reduce((sum, note) => sum + note.dur, 0) * 1000 + 500;
                            
                            sequence.forEach((note, i) => {
                                const oscillator = game.audioContext.createOscillator();
                                const gainNode = game.audioContext.createGain();
                                
                                oscillator.connect(gainNode);
                                gainNode.connect(game.audioContext.destination);
                                
                                oscillator.type = 'sine';
                                oscillator.frequency.value = note.freq;
                                gainNode.gain.value = 0.1;
                                
                                oscillator.start(startTime + i * 0.2);
                                oscillator.stop(startTime + i * 0.2 + note.dur);
                            });
                            
                            // Планируем следующее воспроизведение через паузу
                            game.musicTimeout = setTimeout(() => {
                                game.musicTimeout = null;
                                if (game.isRunning && game.isSoundEnabled) {
                                    game.sounds.music.play(game);
                                } else {
                                    game.musicPlaying = false;
                                    if (game.updateSoundVisualization) {
                                        game.updateSoundVisualization();
                                    }
                                }
                            }, totalDuration);
                        },
                        /**
                         * Настраивает визуализацию звука
                         */
                        setupSoundVisualizer() {
                            // Создаем бары для визуализации
                            for (let i = 0; i < 20; i++) {
                                const bar = document.createElement('div');
                                bar.className = 'sound-bar';
                                this.soundVisualizer.appendChild(bar);
                            }
                            
                            // Обновляем визуализацию
                            setInterval(() => {
                                if (this.musicPlaying) {
                                    const bars = this.soundVisualizer.querySelectorAll('.sound-bar');
                                    bars.forEach(bar => {
                                        const height = 5 + Math.random() * 15;
                                        bar.style.height = `${height}px`;
                                    });
                                }
                            }, 50);
                        }
            
                        /**
                         * Обновляет визуализацию звука
                         */
                        updateSoundVisualization() {
                            if (this.musicPlaying) {
                                const bars = this.soundVisualizer.querySelectorAll('.sound-bar');
                                bars.forEach(bar => {
                                    const height = 5 + Math.random() * 15;
                                    bar.style.height = `${height}px`;
                                });
                            }
                        }
                    },
                    {
                        /**
                         * Инициализирует UI-компоненты
                         */
                        initUIComponents() {
                            // Инициализация темы
                            this.initTheme();
                            
                            // Инициализация достижений
                            this.initAchievements();
                            
                            // Инициализация редактора уровней
                            this.initLevelEditor();

                            // Кнопки по умолчанию
                            const soundBtn = document.getElementById('sound-toggle');
                            if (soundBtn) {
                                soundBtn.innerHTML = `<span>${this.isSoundEnabled ? '🔊' : '🔇'}</span> Звук: ${this.isSoundEnabled ? 'Вкл' : 'Выкл'}`;
                            }
                            const pauseBtn = document.getElementById('pause-toggle');
                            if (pauseBtn) {
                                pauseBtn.innerHTML = `<span>⏸️</span> Пауза`;
                            }

                            // Сложность
                            this.difficulty = 'normal';
                            const diffSelect = document.getElementById('difficulty-select');
                            if (diffSelect) {
                                diffSelect.value = 'normal';
                                diffSelect.addEventListener('change', () => {
                                    this.difficulty = diffSelect.value;
                                });
                            }
                        },
                        /**
                         * Инициализирует тему
                         */
                        initTheme() {
                            this.currentTheme = this.themeService.getRandomTheme();
                            const backgroundEl = document.querySelector('#theme');
                            if (backgroundEl) {
                                backgroundEl.style.backgroundColor = this.currentTheme.backgroundColor;
                            }
                        },
                        /**
                         * Инициализирует достижения
                         */
                        initAchievements() {
                            const allAchievements = [
                                'start-quest', 
                                'reach-score', 
                                'finish-first-quest', 
                                'collect-max-spheres'
                            ];

                            const achievementsListEl = document.querySelector('#achievements');
                            if (achievementsListEl) {
                                allAchievements.forEach(key => {
                                    const itemEl = document.createElement('div');
                                    itemEl.classList.add('achievement', `achievement--${key}`, key === this.completedAchievement ? 'achievement--completed' : '');
                                    const title = key[0].toUpperCase() + key.substring(1);
                                    title.replace(/([A-Z])/g, ' $1');
                                    itemEl.textContent = title.replace('-', ' ');

                                    achievementsListEl.appendChild(itemEl);
                                });
                            }
                        },
                        /**
                         * Инициализирует редактор уровней
                         */
                        initLevelEditor() {
                            const levelEditorContainerEl = document.querySelector('#level-editor');
                            if (levelEditorContainerEl) {
                                const levelEditor = document.createElement('textarea');
                                levelEditor.className = 'level-editor';
                                levelEditor.rows = '12';

                                const loadLevelsEl = document.createElement('button');
                                loadLevelsEl.textContent = 'Загрузить уровни из textarea';

                                const saveLevelBtnEl = document.createElement('button');
                                saveLevelBtnEl.textContent = 'Сохранить уровень';
                                
                                const saveFileEl = document.createElement('input');
                                saveFileEl.type = 'file';

                                levelEditorContainerEl.appendChild(levelEditor);
                                levelEditorContainerEl.appendChild(loadLevelsEl);
                                levelEditorContainerEl.appendChild(saveLevelBtnEl);
                                levelEditorContainerEl.appendChild(saveFileEl);

                                // Функции сохранения
                                levelEditor.addEventListener('input', e => this.loadLevelTextFrom(e.target));
                                saveLevelBtnEl.addEventListener('click', e => this.saveCurrentLevel());

                                saveFileEl.addEventListener('input', e => {
                                    const file = saveFileEl.files[0];
                                    this.loadLevelTextFrom(file);

                                });

                                loadLevelsEl.addEventListener('click', e => {
                                    const levelsString = levelEditor.value.split(/,
?
|
\*,*
?|\*,\s|,,+/)
                                      .filter(i => !!i.length && !!parseInt(i.substring(i.lastIndexOf('_'), i.indexOf('+')))
                                          || this.themeService.getAllThemeIDs()
                                      );

                                  for(let lvlIDStr = ''; isNaN((lvlID = +lvlIDStr));)
                                if (this.currentLvl = ~levelMap.has(4*(parseInt('')+~(' '+i)))){ }
                             let lvlID = 0;
                             let levelMap = new Map();
                             let levels = [];
                             let levelIDs = [];
                             let currentLvl = 0;

                             for(let lvlIDStr = ''; isNaN((lvlID = +lvlIDStr));)
                             if (this.currentLvl = ~levelMap.has(4*(parseInt('')+~(' '+i)))){ }
                             let lvlID = 0;
                             let levelMap = new Map();
                             let levels = [];
                             let levelIDs = [];
                             let currentLvl = 0;
                                });

                                levelEditor.value = this.levelService.getLevelsString();
                            }
                        }
                    }
                ]
            }
                        this.showNotification(`Сложность: ${this.difficulty}`);
                    });
                }
            }
            
            /**
             * Инициализирует тему
             */
            initTheme() {
                const savedTheme = localStorage.getItem('pacmanTheme');
                this.isDarkTheme = savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches);
                document.body.classList.toggle('light-theme', !this.isDarkTheme);
                
                // Обновляем кнопку темы
                const themeButton = document.getElementById('theme-toggle');
                themeButton.innerHTML = `<span>${this.isDarkTheme ? '🌙' : '☀️'}</span> ${this.isDarkTheme ? 'Темная' : 'Светлая'} тема`;
            }
            
            /**
             * Переключает тему (темная/светлая)
             */
            toggleTheme() {
                this.isDarkTheme = !this.isDarkTheme;
                document.body.classList.toggle('light-theme', !this.isDarkTheme);
                
                // Сохраняем выбор темы
                localStorage.setItem('pacmanTheme', this.isDarkTheme ? 'dark' : 'light');
                
                // Обновляем кнопку темы
                const themeButton = document.getElementById('theme-toggle');
                themeButton.innerHTML = `<span>${this.isDarkTheme ? '🌙' : '☀️'}</span> ${this.isDarkTheme ? 'Темная' : 'Светлая'} тема`;
            }
            
            /**
             * Инициализирует систему достижений
             */
            initAchievements() {
                // Загружаем сохраненные достижения
                const savedAchievements = JSON.parse(localStorage.getItem('pacmanAchievements') || '[]');
                
                this.achievements.forEach(achievement => {
                    const saved = savedAchievements.find(a => a.id === achievement.id);
                    if (saved) {
                        achievement.earned = saved.earned;
                    }
                });
                
                // Отображаем достижения
                this.renderAchievements();
            }
            
            /**
             * Отображает достижения в панели
             */
            renderAchievements() {
                const achievementsList = document.getElementById('achievements-list');
                achievementsList.innerHTML = '';
                
                this.achievements.forEach(achievement => {
                    const achievementElement = document.createElement('div');
                    achievementElement.className = 'achievement';
                    
                    achievementElement.innerHTML = `
                        <h3 class="achievement-title">${achievement.title}</h3>
                        <p class="achievement-description">${achievement.description}</p>
                        <span class="achievement-status">${achievement.earned ? 'Получено' : 'Не получено'}</span>
                    `;
                    
                    achievementsList.appendChild(achievementElement);
                });
            }
            
            /**
             * Показывает панель достижений
             */
            showAchievementsPanel() {
                document.getElementById('achievements-panel').classList.add('open');
            }
            
            /**
             * Проверяет выполнение достижений
             */
            checkAchievements() {
                let newAchievements = 0;
                
                this.achievements.forEach(achievement => {
                    if (!achievement.earned && achievement.condition()) {
                        achievement.earned = true;
                        newAchievements++;
                        this.showAchievement(achievement);
                    }
                });
                
                if (newAchievements > 0) {
                    this.saveAchievements();
                    this.renderAchievements();
                }
            }
            
            /**
             * Отображает достижение
             * @param {Object} achievement - Достижение
             */
            showAchievement(achievement) {
                const notification = document.getElementById('notification');
                notification.textContent = `Новое достижение: ${achievement.title} - ${achievement.description}`;
                notification.className = 'notification achievement';
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
            
            /**
             * Сохраняет достижения в localStorage
             */
            saveAchievements() {
                const earnedAchievements = this.achievements.map(a => ({
                    id: a.id,
                    earned: a.earned
                }));
                
                localStorage.setItem('pacmanAchievements', JSON.stringify(earnedAchievements));
            }
            
            /**
             * Инициализирует редактор уровней
             */
            initLevelEditor() {
                this.editorCanvas = document.getElementById('editor-canvas');
                this.editorCtx = this.editorCanvas.getContext('2d');
                this.editorMap = this.cloneMap(this.levels[0]);
                this.currentTool = 'wall';
                
                // Настройка обработчиков
                this.editorCanvas.addEventListener('mousedown', (e) => {
                    this.isDrawing = true;
                    this.updateEditorCell(e);
                });
                
                this.editorCanvas.addEventListener('mousemove', (e) => this.handleEditorMouseMove(e));
                document.addEventListener('mouseup', () => {
                    this.isDrawing = false;
                    if (this.editorMoveTimeout) {
                        clearTimeout(this.editorMoveTimeout);
                        this.editorMoveTimeout = null;
                    }
                });
                
                // Настройка инструментов
                document.querySelectorAll('.tool-button').forEach(button => {
                    button.addEventListener('click', () => {
                        document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                        button.classList.add('active');
                        this.currentTool = button.dataset.tool;
                    });
                });
            }
            
            /**
             * Обновляет ячейку в редакторе уровней
             * @param {MouseEvent} e - Событие мыши
             */
            updateEditorCell(e) {
                const rect = this.editorCanvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / this.cellSize);
                const y = Math.floor((e.clientY - rect.top) / this.cellSize);
                
                if (x >= 0 && x < this.editorMap[0].length && y >= 0 && y < this.editorMap.length) {
                    switch(this.currentTool) {
                        case 'wall':
                            this.editorMap[y][x] = 0;
                            break;
                        case 'path':
                            this.editorMap[y][x] = 1;
                            break;
                        case 'food':
                            this.editorMap[y][x] = 2;
                            break;
                        case 'super-food':
                            this.editorMap[y][x] = 3;
                            break;
                        case 'pacman':
                            // Сначала очищаем предыдущую позицию Пакмана
                            for (let i = 0; i < this.editorMap.length; i++) {
                                for (let j = 0; j < this.editorMap[i].length; j++) {
                                    if (this.editorMap[i][j] === 4) {
                                        this.editorMap[i][j] = 1;
                                    }
                                }
                            }
                            this.editorMap[y][x] = 4;
                            break;
                        case 'ghost':
                            // Сначала очищаем предыдущую позицию привидения
                            for (let i = 0; i < this.editorMap.length; i++) {
                                for (let j = 0; j < this.editorMap[i].length; j++) {
                                    if (this.editorMap[i][j] === 5) {
                                        this.editorMap[i][j] = 1;
                                    }
                                }
                            }
                            this.editorMap[y][x] = 5;
                            break;
                    }
                    
                    this.drawEditorMap();
                }
            }
            
            /**
             * Отрисовывает карту в редакторе уровней
             */
            drawEditorMap() {
                const mapHeight = this.editorMap.length;
                const mapWidth = this.editorMap[0].length;
                
                // Очистка холста
                this.editorCtx.fillStyle = 'black';
                this.editorCtx.fillRect(0, 0, this.editorCanvas.width, this.editorCanvas.height);
                
                for (let y = 0; y < mapHeight; y++) {
                    for (let x = 0; x < mapWidth; x++) {
                        const cell = this.editorMap[y][x];
                        
                        // Стены
                        if (cell === 0) {
                            this.editorCtx.fillStyle = 'blue';
                            this.editorCtx.fillRect(
                                x * this.cellSize,
                                y * this.cellSize,
                                this.cellSize,
                                this.cellSize
                            );
                        }
                        // Путь
                        else if (cell === 1) {
                            this.editorCtx.fillStyle = 'black';
                            this.editorCtx.fillRect(
                                x * this.cellSize,
                                y * this.cellSize,
                                this.cellSize,
                                this.cellSize
                            );
                        }
                        // Обычная еда
                        else if (cell === 2) {
                            this.editorCtx.fillStyle = 'white';
                            this.editorCtx.beginPath();
                            this.editorCtx.arc(
                                x * this.cellSize + this.cellSize/2,
                                y * this.cellSize + this.cellSize/2,
                                2,
                                0,
                                Math.PI * 2
                            );
                            this.editorCtx.fill();
                        }
                        // Супер-еда
                        else if (cell === 3) {
                            this.editorCtx.fillStyle = '#FFD700';
                            this.editorCtx.beginPath();
                            this.editorCtx.arc(
                                x * this.cellSize + this.cellSize/2,
                                y * this.cellSize + this.cellSize/2,
                                5,
                                0,
                                Math.PI * 2
                            );
                            this.editorCtx.fill();
                        }
                        // Пакман
                        else if (cell === 4) {
                            this.editorCtx.fillStyle = 'yellow';
                            this.editorCtx.beginPath();
                            this.editorCtx.arc(
                                x * this.cellSize + this.cellSize/2,
                                y * this.cellSize + this.cellSize/2,
                                this.cellSize/2 - 2,
                                0,
                                Math.PI * 1.8
                            );
                            this.editorCtx.lineTo(
                                x * this.cellSize + this.cellSize/2,
                                y * this.cellSize + this.cellSize/2
                            );
                            this.editorCtx.fill();
                        }
                        // Привидение
                        else if (cell === 5) {
                            this.editorCtx.fillStyle = 'red';
                            this.editorCtx.fillRect(
                                x * this.cellSize,
                                y * this.cellSize,
                                this.cellSize,
                                this.cellSize
                            );
                        }
                    }
                }
            }
            
            /**
             * Применяет изменения из редактора уровней
             */
            applyLevelChanges() {
                const levelName = document.getElementById('level-name').value;
                const levelNumber = parseInt(document.getElementById('level-number').value);
                
                if (!levelName || !levelNumber) {
                    this.showNotification('Введите название и номер уровня', 'error');
                    return;
                }
                
                // Сохраняем уровень в массив уровней
                this.levels[levelNumber - 1] = this.cloneMap(this.editorMap);
                
                this.showNotification(`Уровень "${levelName}" сохранен!`);
                this.closeLevelEditor();
            }
            
            /**
             * Открывает редактор уровней
             */
            openLevelEditor() {
                document.getElementById('level-editor').style.display = 'flex';
                this.editorMap = this.cloneMap(this.levels[this.currentLevel - 1]);
                document.getElementById('level-name').value = `Уровень ${this.currentLevel}`;
                document.getElementById('level-number').value = this.currentLevel;
                this.drawEditorMap();
            }
            
            /**
             * Закрывает редактор уровней
             */
            closeLevelEditor() {
                document.getElementById('level-editor').style.display = 'none';
            }
            
            /**
             * Открывает урок
             * @param {number} lessonId - ID урока
             */
            openLesson(lessonId) {
                this.currentLesson = this.lessons.find(lesson => lesson.id === lessonId);
                if (!this.currentLesson) return;
                
                this.currentLessonStep = 0;
                document.getElementById('lesson-title').textContent = this.currentLesson.title;
                this.showLessonStep();
                document.getElementById('lesson-panel').style.display = 'flex';
            }
            
            /**
             * Закрывает урок
             */
            closeLesson() {
                document.getElementById('lesson-panel').style.display = 'none';
            }
            
            /**
             * Отображает текущий шаг урока
             */
            showLessonStep() {
                const lesson = this.currentLesson;
                const step = lesson.steps[this.currentLessonStep];
                
                const content = document.getElementById('lesson-content');
                content.innerHTML = '';
                
                const stepElement = document.createElement('div');
                stepElement.className = 'lesson-step';
                
                stepElement.innerHTML = `
                    <h4>${step.highlight}</h4>
                    <p>${step.explanation}</p>
                    <div class="code-block">${this.escapeHtml(step.codeSnippet)}</div>
                `;
                
                content.appendChild(stepElement);
                
                // Обновляем состояние кнопок
                document.getElementById('lesson-prev').disabled = this.currentLessonStep === 0;
                document.getElementById('lesson-next').disabled = this.currentLessonStep === lesson.steps.length - 1;
            }
            
            /**
             * Переходит к предыдущему шагу урока
             */
            previousLessonStep() {
                if (this.currentLessonStep > 0) {
                    this.currentLessonStep--;
                    this.showLessonStep();
                }
            }
            
            /**
             * Переходит к следующему шагу урока
             */
            nextLessonStep() {
                if (this.currentLessonStep < this.currentLesson.steps.length - 1) {
                    this.currentLessonStep++;
                    this.showLessonStep();
                } else {
                    this.closeLesson();
                }
            }
            
            /**
             * Открывает тест
             * @param {string} testId - ID теста
             */
            openTest(testId) {
                this.currentTest = this.tests.find(test => test.id === testId);
                if (!this.currentTest) return;
                
                this.currentQuestion = 0;
                this.testScore = 0;
                
                document.getElementById('test-title').textContent = this.currentTest.title;
                this.showTestQuestion();
                document.getElementById('test-panel').style.display = 'flex';
            }
            
            /**
             * Закрывает тест
             */
            closeTest() {
                document.getElementById('test-panel').style.display = 'none';
            }
            
            /**
             * Отображает текущий вопрос теста
             */
            showTestQuestion() {
                const test = this.currentTest;
                const question = test.questions[this.currentQuestion];
                
                const content = document.getElementById('test-content');
                content.innerHTML = `
                    <div class="test-question">
                        <h4>Вопрос ${this.currentQuestion + 1} из ${test.questions.length}</h4>
                        <p>${question.question}</p>
                        ${question.options.map((option, i) => `
                            <div class="test-option" data-index="${i}">
                                ${option}
                            </div>
                        `).join('')}
                        <div class="feedback" id="test-feedback"></div>
                    </div>
                `;
                
                // Добавляем обработчики
                document.querySelectorAll('.test-option').forEach(option => {
                    option.addEventListener('click', () => {
                        this.checkAnswer(parseInt(option.dataset.index));
                    });
                });
            }
            
            /**
             * Проверяет ответ на вопрос
             * @param {number} answerIndex - Индекс выбранного ответа
             */
            checkAnswer(answerIndex) {
                const question = this.currentTest.questions[this.currentQuestion];
                const feedback = document.getElementById('test-feedback');
                
                if (answerIndex === question.correctAnswer) {
                    feedback.className = 'feedback success';
                    feedback.textContent = 'Правильно! ' + question.explanation;
                    this.testScore++;
                } else {
                    feedback.className = 'feedback error';
                    feedback.textContent = 'Неправильно. ' + question.explanation;
                }
                
                // Следующий вопрос через 2 секунды
                setTimeout(() => {
                    this.currentQuestion++;
                    
                    if (this.currentQuestion < this.currentTest.questions.length) {
                        this.showTestQuestion();
                    } else {
                        this.showTestResults();
                    }
                }, 2000);
            }
            
            /**
             * Отображает результаты теста
             */
            showTestResults() {
                const content = document.getElementById('test-content');
                content.innerHTML = `
                    <div class="test-results">
                        <h3>Результаты теста</h3>
                        <div class="test-score">${this.testScore} из ${this.currentTest.questions.length}</div>
                        <p>Ваш результат: ${Math.round((this.testScore / this.currentTest.questions.length) * 100)}%</p>
                        <div class="modal-buttons" style="margin-top: 30px;">
                            <button class="btn" id="close-test-results">Закрыть</button>
                        </div>
                    </div>
                `;
                
                document.getElementById('close-test-results').addEventListener('click', () => {
                    this.closeTest();
                });
            }
            
            /**
             * Клонирует карту уровня
             * @param {Array} map - Карта уровня
             * @returns {Array} Клонированная карта
             */
            cloneMap(map) {
                return JSON.parse(JSON.stringify(map));
            }
            
            /**
             * Подсчитывает общее количество еды на уровне
             */
            countTotalFood() {
                this.totalFood = 0;
                for (const row of this.currentMap) {
                    for (const cell of row) {
                        if (cell === 2 || cell === 3) {
                            this.totalFood++;
                        }
                    }
                }
            }
            
            /**
             * Автозаполнение еды на уровне, если она отсутствует
             * @param {Array} map - Карта уровня
             */
            populateFoodIfMissing(map) {
                let hasFood = false;
                for (let y = 0; y < map.length; y++) {
                    for (let x = 0; x < map[y].length; x++) {
                        if (map[y][x] === 2 || map[y][x] === 3) {
                            hasFood = true;
                            break;
                        }
                    }
                    if (hasFood) break;
                }
                if (!hasFood) {
                    for (let y = 0; y < map.length; y++) {
                        for (let x = 0; x < map[y].length; x++) {
                            if (map[y][x] === 1) {
                                map[y][x] = 2;
                            }
                        }
                    }
                    // Добавим 4 супер-точки по углам проходов, если доступны
                    const positions = [
                        {x:1,y:1},
                        {x:map[0].length-2,y:1},
                        {x:1,y:map.length-2},
                        {x:map[0].length-2,y:map.length-2}
                    ];
                    positions.forEach(p => {
                        if (map[p.y] && map[p.y][p.x] && map[p.y][p.x] !== 0) {
                            map[p.y][p.x] = 3;
                        }
                    });
                }
            }
            
            /**
             * Загружает прогресс игры
             * @returns {boolean} Успешно ли загружено
             */
            loadProgress() {
                const saved = localStorage.getItem('pacmanProgress');
                if (saved) {
                    try {
                        const progress = JSON.parse(saved);
                        if (progress.version === '1.1') {
                            this.highScore = progress.highScore;
                            this.currentLevel = Math.min(progress.currentLevel, this.levels.length);
                            
                            // Восстанавливаем достижения
                            if (progress.achievements && Array.isArray(progress.achievements)) {
                                progress.achievements.forEach(id => {
                                    const achievement = this.achievements.find(a => a.id === id);
                                    if (achievement) achievement.earned = true;
                                });
                            }
                            
                            // Восстанавливаем настройки
                            if (progress.settings) {
                                this.isSoundEnabled = progress.settings.soundEnabled !== undefined ? 
                                    progress.settings.soundEnabled : true;
                                this.isLearningMode = progress.settings.learningMode !== undefined ? 
                                    progress.settings.learningMode : false;
                                
                                // Переключаем тему
                                this.isDarkTheme = progress.settings.theme !== 'light';
                                document.body.classList.toggle('light-theme', !this.isDarkTheme);
                                
                                // Обновляем отображение кнопки темы
                                const themeBtn = document.getElementById('theme-toggle');
                                if (themeBtn) {
                                    themeBtn.innerHTML = `<span>${this.isDarkTheme ? '🌙' : '☀️'}</span> ${this.isDarkTheme ? 'Темная' : 'Светлая'} тема`;
                                }
                            }
                            
                            // Обновляем интерфейс
                            this.updateUI();
                            return true;
                        }
                    } catch (e) {
                        console.error('Ошибка загрузки прогресса:', e);
                    }
                }
                return false;
            }
            
            /**
             * Сохраняет прогресс игры
             */
            saveProgress() {
                try {
                    const progress = {
                        version: '1.1',
                        highScore: this.highScore,
                        currentLevel: this.currentLevel,
                        unlockedLevels: Math.min(this.levels.length, this.currentLevel),
                        achievements: this.achievements.filter(a => a.earned).map(a => a.id),
                        settings: {
                            soundEnabled: this.isSoundEnabled,
                            learningMode: this.isLearningMode,
                            theme: this.isDarkTheme ? 'dark' : 'light'
                        }
                    };
                    
                    localStorage.setItem('pacmanProgress', JSON.stringify(progress));
                    this.showNotification('Прогресс сохранен!');
                } catch (e) {
                    console.error('Ошибка при сохранении прогресса:', e);
                    this.showNotification('Не удалось сохранить прогресс', 'error');
                }
            }
            
            /**
             * Показывает уведомление
             * @param {string} message - Текст уведомления
             * @param {string} [type='success'] - Тип уведомления (success, error, achievement)
             */
            showNotification(message, type = 'success') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = 'notification';
                notification.classList.add('show');
                
                if (type !== 'success') {
                    notification.classList.add(type);
                }
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
        }
        
        // Инициализация игры при загрузке страницы
        document.addEventListener('DOMContentLoaded', () => {
            // Создаем экземпляр игры
            const game = new PacmanGame();
        });
    </script>
</body>
</html>