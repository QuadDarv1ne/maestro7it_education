/**
 * Автор: Дуплей Максим Игоревич - AGLA
 * ORCID: https://orcid.org/0009-0007-7605-539X
 * GitHub: https://github.com/QuadDarv1ne/
 * 
 * Полезные ссылки:
 * 1. Telegram ❃ Хижина программиста Æ: https://t.me/hut_programmer_07
 * 2. Telegram №1 @quadd4rv1n7
 * 3. Telegram №2 @dupley_maxim_1999
 * 4. Rutube канал: https://rutube.ru/channel/4218729/
 * 5. Plvideo канал: https://plvideo.ru/channel/AUPv_p1r5AQJ
 * 6. YouTube канал: https://www.youtube.com/@it-coders
 * 7. ВК группа: https://vk.com/science_geeks
 */

// ==================== JavaScript ====================

/**
 * Конструирует минимальный побитовый массив.
 * 
 * Для каждого элемента nums[i] находит минимальное ans[i] такое, что:
 * ans[i] OR (ans[i] + 1) == nums[i]
 * 
 * @param {number[]} nums - массив простых чисел
 * @return {number[]} массив минимальных значений или -1
 */
var minBitwiseArray = function(nums) {
    const ans = [];
    
    for (const x of nums) {
        // Если x равно 2, решение невозможно
        if (x === 2) {
            ans.push(-1);
        } else {
            // Находим первый 0-бит справа (после завершающих единиц)
            for (let i = 1; i < 32; i++) {
                // Проверяем, является ли бит на позиции i нулем
                if (((x >> i) & 1) === 0) {
                    // Переворачиваем бит на позиции i-1
                    const result = x ^ (1 << (i - 1));
                    ans.push(result);
                    break;
                }
            }
        }
    }
    
    return ans;
};

// ==================== Объяснение алгоритма ====================
/*
ЛОГИКА РЕШЕНИЯ:

1. Для каждого числа x из массива nums:
   - Если x == 2, то решение невозможно → возвращаем -1
   - Иначе ищем первый 0-бит справа (после всех завершающих единиц)

2. Почему это работает:
   - Когда мы прибавляем 1 к числу, самый правый 0-бит становится 1,
     а все биты справа от него становятся 0
   - При операции OR с исходным числом мы должны получить nums[i]
   - Минимальное значение получается, когда мы "выключаем" самую правую 1
     перед первым 0-битом

3. Примеры:
   x = 7 (111 в двоичной):
   - Ищем первый 0 → позиция 3
   - Переворачиваем бит на позиции 2: 7 ^ 4 = 3 (011)
   - Проверка: 3 OR 4 = 011 OR 100 = 111 = 7 ✓

   x = 5 (101 в двоичной):
   - Первый 0 на позиции 1
   - Переворачиваем бит на позиции 0: 5 ^ 1 = 4 (100)
   - Проверка: 4 OR 5 = 100 OR 101 = 101 = 5 ✓

СЛОЖНОСТЬ:
- Временная: O(n × 32) = O(n), где n - длина массива
- Пространственная: O(n) для выходного массива
*/