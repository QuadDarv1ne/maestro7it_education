"""
Автор: Дуплей Максим Игоревич - AGLA
ORCID: https://orcid.org/0009-0007-7605-539X
GitHub: https://github.com/QuadDarv1ne/

Полезные ссылки:
1. Telegram ❃ Хижина программиста Æ: https://t.me/hut_programmer_07
2. Telegram №1 @quadd4rv1n7
3. Telegram №2 @dupley_maxim_1999
4. Rutube канал: https://rutube.ru/channel/4218729/
5. Plvideo канал: https://plvideo.ru/channel/AUPv_p1r5AQJ
6. YouTube канал: https://www.youtube.com/@it-coders
7. ВК группа: https://vk.com/science_geeks
"""

class Solution:
    def maxSumTrionic(self, nums):
        """
        Находит максимальную сумму трионического подмассива.
        
        Трионический подмассив - это непрерывный подмассив nums[l...r],
        для которого существуют индексы l < p < q < r такие, что:
        - nums[l...p] строго возрастает
        - nums[p...q] строго убывает
        - nums[q...r] строго возрастает
        
        Алгоритм использует жадный подход со скользящим окном:
        1. Находит возрастающую последовательность
        2. Находит следующую убывающую последовательность
        3. Находит следующую возрастающую последовательность
        4. Для каждой такой тройки вычисляет максимальную сумму,
           оптимально выбирая длины левой и правой частей
        
        Сложность: O(n) - один проход по массиву
        
        Аргументы:
            nums: Массив целых чисел длины n (4 <= n <= 10^5)
        
        Возвращает:
            Максимальную сумму элементов трионического подмассива
        """
        n = len(nums)
        i = 0
        ans = float('-inf')
        
        while i < n:
            # Запоминаем начало возрастающей части
            l = i
            i += 1
            
            # Находим конец возрастающей части
            while i < n and nums[i - 1] < nums[i]:
                i += 1
            
            # Если возрастающая часть состоит только из одного элемента - пропускаем
            if i == l + 1:
                continue
            
            # p - индекс последнего элемента возрастающей части
            p = i - 1
            
            # Начальная сумма: два последних элемента возрастающей части
            s = nums[p - 1] + nums[p]
            
            # Находим убывающую часть
            while i < n and nums[i - 1] > nums[i]:
                s += nums[i]
                i += 1
            
            # Проверяем валидность убывающей части
            if i == p + 1 or i == n or nums[i - 1] == nums[i]:
                continue
            
            # q - индекс последнего элемента убывающей части
            q = i - 1
            
            # Добавляем первый элемент возрастающей части справа
            s += nums[i]
            i += 1
            
            # Находим максимальную сумму для правой возрастающей части
            mx = t = 0
            while i < n and nums[i - 1] < nums[i]:
                t += nums[i]
                i += 1
                mx = max(mx, t)
            s += mx
            
            # Находим максимальную сумму для левой возрастающей части
            # (идем назад от p-2 до l)
            mx = t = 0
            for j in range(p - 2, l - 1, -1):
                t += nums[j]
                mx = max(mx, t)
            s += mx
            
            # Обновляем максимальный результат
            ans = max(ans, s)
            
            # Продолжаем поиск с позиции q
            i = q
        
        return ans


# Тестирование решения
if __name__ == "__main__":
    solution = Solution()
    
    # Тест 1
    nums1 = [0, -2, -1, -3, 0, 2, -1]
    result1 = solution.maxSumTrionic(nums1)
    print(f"Тест 1: nums = {nums1}")
    print(f"Результат: {result1}, Ожидается: -4")
    print(f"{'✓ ПРОШЕЛ' if result1 == -4 else '✗ ПРОВАЛЕН'}")
    print()
    
    # Тест 2
    nums2 = [1, 4, 2, 7]
    result2 = solution.maxSumTrionic(nums2)
    print(f"Тест 2: nums = {nums2}")
    print(f"Результат: {result2}, Ожидается: 14")
    print(f"{'✓ ПРОШЕЛ' if result2 == 14 else '✗ ПРОВАЛЕН'}")
    print()
    
    # Тест 3
    nums3 = [2, 993, -791, -635, -569]
    result3 = solution.maxSumTrionic(nums3)
    print(f"Тест 3: nums = {nums3}")
    print(f"Результат: {result3}, Ожидается: -431")
    print(f"{'✓ ПРОШЕЛ' if result3 == -431 else '✗ ПРОВАЛЕН'}")
    print()
    
    print("=" * 50)
    print("Объяснение алгоритма:")
    print("=" * 50)
    print("Алгоритм находит все 'волны' вида ↗↘↗ в массиве")
    print("Для каждой волны оптимально выбирает длины частей,")
    print("максимизируя сумму элементов.")
    print("Время работы: O(n) - линейное по размеру массива.")
    print("=" * 50)