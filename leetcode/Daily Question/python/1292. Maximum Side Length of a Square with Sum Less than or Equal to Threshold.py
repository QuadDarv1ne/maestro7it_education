"""
Решение задачи "Максимальная длина стороны квадрата с суммой не превышающей порог"

Задача:
Дан двумерный массив mat размера m x n и целочисленный порог threshold.
Необходимо найти максимальную длину стороны квадрата, сумма элементов которого
не превышает заданный порог. Если такого квадрата не существует, вернуть 0.

Алгоритм:
1. Вычисление матрицы префиксных сумм для быстрого определения суммы любого подмассива.
2. Использование бинарного поиска для нахождения максимальной длины стороны квадрата.
3. Для каждой проверяемой длины k проверяем все возможные квадраты со стороной k.
4. Если существует квадрат со стороной k и суммой ≤ threshold, пытаемся увеличить k.

Параметры:
    mat: List[List[int]]
        Входная матрица целых чисел размера m x n.
    threshold: int
        Максимально допустимая сумма элементов квадрата.

Возвращает:
    int
        Максимальная длина стороны квадрата с суммой ≤ threshold.
        Если такой квадрат не существует, возвращает 0.

Сложность:
    Время: O(m * n * log(min(m, n)))
        - Построение префиксных сумм: O(m * n)
        - Бинарный поиск: O(log(min(m, n)))
        - Проверка всех квадратов: O((m-k+1)*(n-k+1)) для каждого k
    Память: O(m * n)
        - Для хранения матрицы префиксных сумм

Примеры:
    Пример 1:
        Вход: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
        Выход: 2
        Объяснение: Максимальный квадрат со стороной 2 имеет сумму 4.

    Пример 2:
        Вход: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
        Выход: 0
        Объяснение: Не существует квадрата с суммой ≤ 1.

Примечания:
    1. Матрица может содержать отрицательные числа, но префиксные суммы работают корректно.
    2. Длина стороны квадрата измеряется в количестве ячеек.
    3. Квадрат должен быть непрерывным (не разрывным) подмассивом.

Автор решения: Дуплей Максим Игоревич - AGLA
Контакты:
    - GitHub: https://github.com/QuadDarv1ne/
    - ORCID: https://orcid.org/0009-0007-7605-539X
 
Полезные ссылки:
1. ❃ Хижина программиста Æ: https://t.me/hut_programmer_07
2. Telegram №1: @quadd4rv1n7
3. Telegram №2: @dupley_maxim_1999
4. Rutube канал: https://rutube.ru/channel/4218729/
5. Plvideo канал: https://plvideo.ru/channel/AUPv_p1r5AQJ
6. YouTube канал: https://www.youtube.com/@it-coders
7. ВК группа: https://vk.com/science_geeks

Дата: 19.01.2026
"""

class Solution:
    def maxSideLength(self, mat, threshold):
        m, n = len(mat), len(mat[0])
        
        # Матрица префиксных сумм с дополнительными строкой и столбцом из нулей
        prefix = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(m):
            for j in range(n):
                prefix[i + 1][j + 1] = mat[i][j] + prefix[i][j + 1] + \
                                        prefix[i + 1][j] - prefix[i][j]
        
        # Вспомогательная функция для вычисления суммы квадрата
        def square_sum(i, j, k):
            """
            Вычисляет сумму квадрата со стороной k, 
            начиная с позиции (i, j) (0-индексация).
            
            Аргументы:
                i: int - начальная строка
                j: int - начальный столбец
                k: int - длина стороны квадрата
                
            Возвращает:
                int - сумма элементов квадрата
            """
            return prefix[i + k][j + k] - prefix[i][j + k] - \
                   prefix[i + k][j] + prefix[i][j]
        
        # Бинарный поиск максимальной длины стороны
        left, right = 1, min(m, n)
        ans = 0
        
        while left <= right:
            k = (left + right) // 2
            found = False
            
            # Проверяем все возможные верхние левые углы для квадрата со стороной k
            for i in range(m - k + 1):
                for j in range(n - k + 1):
                    if square_sum(i, j, k) <= threshold:
                        found = True
                        break
                if found:
                    break
            
            if found:
                ans = k        # Обновляем наилучший результат
                left = k + 1   # Пробуем больший квадрат
            else:
                right = k - 1  # Пробуем меньший квадрат
        
        return ans


# Альтернативная версия с оптимизацией (предварительная проверка для k+1)
"""
Альтернативный подход с проверкой от максимального возможного k вниз:
    - Начинаем с максимального возможного k = min(m, n)
    - Для каждого k проверяем все квадраты
    - Если нашли подходящий квадрат, сразу возвращаем k
    - Если не нашли, уменьшаем k на 1
    
Преимущества:
    - Не требует бинарного поиска
    - Более простая логика
    - Может быть быстрее, если ожидается большой квадрат

Недостатки:
    - В худшем случае O(m * n * min(m, n))
"""

def maxSideLengthAlternative(mat, threshold):
    """
    Альтернативная реализация без бинарного поиска.
    Проверяет квадраты от максимального размера к минимальному.
    
    Возвращает 0, если не найден ни один подходящий квадрат.
    """
    m, n = len(mat), len(mat[0])
    
    # Построение префиксных сумм
    prefix = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m):
        for j in range(n):
            prefix[i + 1][j + 1] = mat[i][j] + prefix[i][j + 1] + \
                                   prefix[i + 1][j] - prefix[i][j]
    
    # Проверяем квадраты от максимального размера к минимальному
    for k in range(min(m, n), 0, -1):
        for i in range(m - k + 1):
            for j in range(n - k + 1):
                # Вычисляем сумму квадрата
                square_sum = (prefix[i + k][j + k] - prefix[i][j + k] - 
                             prefix[i + k][j] + prefix[i][j])
                if square_sum <= threshold:
                    return k
    
    return 0