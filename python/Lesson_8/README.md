# Объектно-Ориентированное Программирование (ООП) в Python

**Объектно-Ориентированное Программирование (ООП)** — это парадигма программирования, основанная на представлении данных в виде объектов.

В Python ООП играет важную роль, позволяя создавать удобные и структурированные программы.

### 1. Основы ООП

**ООП основано на следующих ключевых концепциях:**
- `Класс` — это шаблон (или чертёж) для создания объектов.
- `Объект` — это экземпляр класса, который содержит данные (атрибуты) и методы (функции, связанные с объектом).
- `Инкапсуляция` — механизм, который объединяет данные и методы, защищая их от внешнего вмешательства.
- `Наследование` — процесс создания нового класса на основе существующего.
- `Полиморфизм` — способность объекта использовать методы, общие для всех классов в его иерархии.

### 2. Классы и объекты

В Python классы определяются с помощью ключевого слова `class`

После определения класса можно создавать его объекты.

**Пример создания класса и объекта:**
```python
class Car:
    """
    Класс, представляющий обычный автомобиль.

    Атрибуты:
        brand (str): Марка автомобиля.
        model (str): Модель автомобиля.
        year (int): Год выпуска автомобиля.
    """

    def __init__(self, brand, model, year):
        """
        Инициализация объекта класса Car.

        Аргументы:
            brand (str): Марка автомобиля.
            model (str): Модель автомобиля.
            year (int): Год выпуска автомобиля.
        """
        self.brand = brand
        self.model = model
        self.year = year

    def drive(self):
        """Выводит сообщение о движении автомобиля."""
        print(f"{self.brand} {self.model} едет.")


class Vehicle:
    """
    Класс, представляющий транспортное средство.

    Атрибуты:
        brand (str): Марка транспортного средства.
        model (str): Модель транспортного средства.
    """

    def __init__(self, brand, model):
        """
        Инициализация объекта класса Vehicle.

        Аргументы:
            brand (str): Марка транспортного средства.
            model (str): Модель транспортного средства.
        """
        self.brand = brand
        self.model = model

    def drive(self):
        """Выводит сообщение о движении транспортного средства."""
        print(f"{self.brand} {self.model} едет.")


class ElectricCar(Vehicle):
    """
    Класс, представляющий электрический автомобиль (наследует Vehicle).

    Атрибуты:
        brand (str): Марка автомобиля.
        model (str): Модель автомобиля.
        battery_capacity (int): Ёмкость батареи в кВт/ч.
    """

    def __init__(self, brand, model, battery_capacity):
        """
        Инициализация объекта класса ElectricCar.

        Аргументы:
            brand (str): Марка автомобиля.
            model (str): Модель автомобиля.
            battery_capacity (int): Ёмкость батареи в кВт/ч.
        """
        super().__init__(brand, model)
        self.battery_capacity = battery_capacity

    def charge(self):
        """Выводит сообщение о начале зарядки автомобиля."""
        print(f"{self.brand} {self.model} заряжается на {self.battery_capacity} кВт/ч.")

    def calculate_charge_time(self, charge_percentage, charge_rate):
        """
        Рассчитывает время зарядки автомобиля до указанного процента.

        Аргументы:
            charge_percentage (int): Процент зарядки (от 0 до 100).
            charge_rate (int): Скорость зарядки в кВт/ч.

        Возвращает:
            float: Время зарядки в часах.
        """
        if charge_rate <= 0:
            raise ValueError("Скорость зарядки должна быть больше нуля.")

        energy_needed = (self.battery_capacity * charge_percentage) / 100
        charge_time = energy_needed / charge_rate
        return charge_time


# Создание объекта класса ElectricCar
my_electric_car = ElectricCar("Tesla", "Model S", 100)

# Демонстрация функциональности
my_electric_car.drive()  # Tesla Model S едет
my_electric_car.charge()  # Tesla Model S заряжается на 100 кВт/ч

# Расчёт времени зарядки
charge_percentage = 50  # Процент зарядки
charge_rate = 22  # Скорость зарядки в кВт/ч

charge_time = my_electric_car.calculate_charge_time(charge_percentage, charge_rate)
print(f"Для зарядки {charge_percentage}% батареи потребуется {charge_time:.2f} часов при скорости {charge_rate} кВт/ч.")
```

- **Атрибуты** — это данные, связанные с объектом. Они задаются в конструкторе `__init__()`

- **Методы** — это функции, связанные с объектом класса. Внутри методов первый параметр всегда должен быть `self`, чтобы иметь доступ к атрибутам объекта.

### 3. Наследование

Наследование позволяет одному классу наследовать свойства и методы другого класса.

Класс, от которого наследуются, называется родительским (или базовым), а класс, который наследует, называется дочерним.

**Пример наследования:**
```python
class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def drive(self):
        print(f"{self.brand} {self.model} едет!")

# Дочерний класс
class ElectricCar(Vehicle):
    def __init__(self, brand, model, battery_capacity):
        super().__init__(brand, model)  # Вызов конструктора родительского класса
        self.battery_capacity = battery_capacity

    def charge(self):
        print(f"{self.brand} {self.model} заряжается на {self.battery_capacity} кВт/ч")

# Создание объекта дочернего класса
my_electric_car = ElectricCar("Tesla", "Model S", 100)

my_electric_car.drive()  # Tesla Model S едет!
my_electric_car.charge()  # Tesla Model S заряжается на 100 кВт/ч
```

В этом примере класс `ElectricCar` наследует от класса `Vehicle`, что позволяет использовать методы и атрибуты родительского класса.

Метод `super()` используется для вызова конструктора родительского класса.

### 4. Полиморфизм

Полиморфизм позволяет использовать методы, общие для всех классов в иерархии, даже если конкретная реализация метода различна.

**Пример полиморфизма:**
```python
class Animal:
    def sound(self):
        pass  # Определяется в подклассах

class Dog(Animal):
    def sound(self):
        return "Гав"

class Cat(Animal):
    def sound(self):
        return "Мяу"

# Используем полиморфизм
def make_sound(animal):
    print(animal.sound())

dog = Dog()
cat = Cat()

make_sound(dog)  # Гав
make_sound(cat)  # Мяу
```

В этом примере метод `sound` реализован по-разному для каждого подкласса, но мы можем использовать их одинаково через общую функцию `make_sound`, что является примером полиморфизма.

### 5. Инкапсуляция

**Инкапсуляция** — это концепция сокрытия внутренней реализации объекта.

В Python атрибуты и методы могут быть защищены от внешнего доступа с помощью соглашения о наименовании.

**Пример инкапсуляции:**
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.__age = age  # Приватный атрибут

    def get_age(self):
        return self.__age  # Метод для доступа к приватному атрибуту

person = Person("Алиса", 30)
print(person.name)  # Алиса
print(person.get_age())  # 30
# print(person.__age)  # Ошибка: AttributeError, так как __age — приватный
```

В Python приватные атрибуты и методы обозначаются двумя подчёркиваниями в начале имени `(__)`.

Прямой доступ к ним извне невозможен, но можно создать специальные методы для получения или изменения этих данных.

### Выводы

ООП позволяет создавать более структурированные программы, в которых данные и методы объединены в классы.

Важные концепции ООП, такие как наследование, инкапсуляция и полиморфизм, помогают организовать код таким образом, чтобы он был легче читаемым, поддерживаемым и расширяемым.



**Автор:** Дуплей Максим Игоревич

**Дата:** 07.09.2024

**Версия 1.0**
