# Оптимизации шахматного движка

## Обзор выполненных оптимизаций

В рамках продолжающегося развития шахматного движка были реализованы ключевые оптимизации, направленные на повышение производительности и качества игры ИИ.

## 1. Транспозиционная таблица

### Описание
Реализована транспозиционная таблица для кэширования результатов вычислений позиций, что позволяет избежать повторных вычислений одинаковых позиций в дереве поиска.

### Технические детали
- Размер таблицы: 100,000 записей
- Структура записи (TTEntry):
  - `hash` - хеш позиции
  - `depth` - глубина, на которой была вычислена позиция
  - `score` - оценка позиции
  - `bestMove` - лучший ход для данной позиции
  - `flag` - тип записи ('E' - точное значение, 'L' - нижняя граница, 'U' - верхняя граница)

### Алгоритм
1. При каждом вызове минимакса вычисляется хеш позиции
2. Проверяется наличие записи в транспозиционной таблице
3. Если запись найдена и глубина >= текущей, используется закэшированное значение
4. После завершения вычислений результат сохраняется в таблицу

### Преимущества
- Значительное ускорение поиска
- Улучшение качества игры за счет большего количества просчитанных позиций
- Эффективное использование результатов предыдущих вычислений

## 2. Упорядочивание ходов (Move Ordering)

### Описание
Реализовано упорядочивание ходов по приоритетам для улучшения альфа-бета отсечений.

### Приоритеты ходов
1. **Взятия фигур (MVV/LVA)** - Most Valuable Victim / Least Valuable Attacker
   - Приоритет: 1000 + (стоимость жертвы - стоимость атакующей фигуры / 10)
2. **Ходы пешек вперед**
   - Приоритет: 500 + продвижение по вертикали * 10
3. **Ходы ферзя**
   - Приоритет: 400
4. **Ходы короля**
   - Приоритет: 300
5. **Другие ходы**
   - Приоритет: стоимость фигуры

### Алгоритм
```cpp
int Minimax::getMovePriority(const Move& move) const {
    Piece capturedPiece = board_.getPiece(move.to);
    Piece movingPiece = board_.getPiece(move.from);
    
    // Приоритет для взятий
    if (!capturedPiece.isEmpty()) {
        int mvvLva = capturedPiece.getValue() - movingPiece.getValue() / 10;
        return 1000 + mvvLva;
    }
    
    // Приоритет для ходов пешки вперед
    if (movingPiece.getType() == PieceType::PAWN) {
        int rankDiff = (movingPiece.getColor() == Color::WHITE) ? 
                      (board_.rank(move.to) - board_.rank(move.from)) : 
                      (board_.rank(move.from) - board_.rank(move.to));
        if (rankDiff > 0) {
            return 500 + rankDiff * 10;
        }
    }
    
    // Приоритет для ходов ферзя и короля
    if (movingPiece.getType() == PieceType::QUEEN) return 400;
    if (movingPiece.getType() == PieceType::KING) return 300;
    
    return movingPiece.getValue();
}
```

### Преимущества
- Улучшенные альфа-бета отсечения
- Более раннее нахождение хороших ходов
- Значительное ускорение поиска

## 3. Итеративное углубление

### Описание
Реализован алгоритм итеративного углубления, при котором поиск происходит последовательно с возрастающей глубиной.

### Алгоритм
```cpp
Move Minimax::findBestMove(Color color) {
    Move bestMove;
    int bestValue;
    
    // Итеративное углубление: начинаем с малой глубины и постепенно увеличиваем
    for (int depth = 1; depth <= maxDepth_; depth++) {
        std::vector<Move> moves = orderMoves(MoveGenerator(board_).generateLegalMoves());
        
        if (moves.empty()) {
            return Move();
        }
        
        Move currentBestMove = moves[0];
        int currentValue = (color == Color::WHITE) ? INT_MIN : INT_MAX;
        
        for (const Move& move : moves) {
            int value = minimax(depth, INT_MIN, INT_MAX, color);
            
            if ((color == Color::WHITE && value > currentValue) || 
                (color == Color::BLACK && value < currentValue)) {
                currentValue = value;
                currentBestMove = move;
            }
        }
        
        // Обновляем лучший ход и значение
        bestMove = currentBestMove;
        bestValue = currentValue;
    }
    
    return bestMove;
}
```

### Преимущества
- Получение промежуточных результатов при ограниченном времени
- Использование результатов предыдущих итераций для улучшения упорядочивания ходов
- Возможность остановки поиска в любой момент

## 4. Совершенствование оценки позиции

### Улучшенные значения фигур
- Пешка: 100 (вместо 1)
- Конь: 320 (вместо 3)
- Слон: 330 (вместо 3)
- Ладья: 500 (вместо 5)
- Ферзь: 900 (вместо 9)
- Король: 20000 (вместо 1000)

### Улучшенные компоненты оценки
- **Мобильность**: оценка количества возможных ходов
- **Безопасность короля**: учет защитников и атакующих фигур
- **Пешечная структура**: оценка связанных, изолированных и проходных пешек

## 5. Инструменты бенчмаркинга

### PerformanceBenchmark
Создан инструмент для измерения производительности:
- Генерация ходов
- Оценка позиции
- Алгоритм минимакс
- Комплексные позиции

### Метрики
- Среднее время выполнения
- Операций в секунду
- Количество итераций

## Результаты оптимизаций

### Производительность
- Ускорение поиска благодаря транспозиционной таблице
- Улучшенные альфа-бета отсечения за счет упорядочивания ходов
- Более эффективное использование времени благодаря итеративному углублению

### Качество игры
- Более точная оценка позиции
- Лучшее понимание стратегических элементов
- Улучшенное дерево поиска

## Планы на будущее

### Ближайшие шаги
- Реализация null-move pruning
- Добавление killer heuristic
- Улучшенный quiescence search
- Bitboard представление доски

### Долгосрочные цели
- Параллельный поиск (многопоточность)
- Интеграция с шахматными базами данных
- Машинное обучение для настройки параметров оценки
- Поддержка протоколов UCI/XBoard

## Заключение

Реализованные оптимизации значительно повысили производительность и качество игры шахматного движка. Транспозиционная таблица, упорядочивание ходов и итеративное углубление являются ключевыми компонентами современного сильного шахматного ИИ.