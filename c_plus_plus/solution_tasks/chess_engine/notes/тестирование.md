# Руководство по тестированию шахматного движка

## Обзор

Этот документ описывает процесс тестирования шахматного движка, включая автоматические и ручные тесты.

## Автоматическое тестирование

### Компиляция тестов

```bash
# Windows
cd build
cmake .. -G "MinGW Makefiles"
mingw32-make test_chess

# Linux/macOS
cd build
cmake ..
make test_chess
```

### Запуск тестов

```bash
# Windows
cd build
test_chess.exe

# Linux/macOS
cd build
./test_chess
```

## Ручное тестирование

### Базовые тесты

#### 1. Начальная позиция

- Проверить отображение доски
- Подсчитать количество легальных ходов (должно быть 20)
- Убедиться, что все ходы корректны

#### 2. Ходы пешек

- e2-e4 (корректный)
- e2-e5 (некорректный)
- d2-d4 (корректный)

#### 3. Ходы коней

- Ng1-f3 (корректный)
- Nb1-a3 (корректный)
- Ng1-h3 (корректный)

#### 4. Специальные ситуации

- Попытка хода под шахом
- Взятие фигур
- Превращение пешки (при достижении 8-й горизонтали)

### Тестовые позиции

#### Позиция №1: Открытая игра

```printtext
rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1
```

**Ожидаемые результаты:**

- Черные могут сделать 20 ходов
- e7-e5 легален
- d7-d5 легален

#### Позиция №2: Сицилианская защита

```printtext
rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2
```

**Ожидаемые результаты:**

- d7-d6 легален
- Nc6 легален
- e7-e5 легален

## Профилирование производительности

### Измерение скорости генерации ходов

```cpp
#include <chrono>

void performanceTest() {
    Board board;
    MoveGenerator generator(board);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < 1000; i++) {
        std::vector<Move> moves = generator.generateLegalMoves();
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "Время для 1000 генераций: " << duration.count() << " мс" << std::endl;
}
```

## Отладка

### Частые проблемы и решения

#### 1. Некорректное количество ходов

- Проверить реализацию generatePseudoLegalMoves()
- Убедиться, что все направления учтены
- Проверить граничные условия

#### 2. Легальные ходы помечаются как нелегальные

- Проверить реализацию isLegalMove()
- Убедиться в корректности wouldBeInCheck()

#### 3. Ошибки сегментации

- Проверить bounds checking
- Убедиться, что все указатели валидны

### Инструменты отладки

#### GDB (Linux/macOS)

```bash
gdb ./test_chess
(gdb) run
(gdb) bt  # backtrace при падении
```

#### Visual Studio Debugger (Windows)

- Установить breakpoints
- Использовать Watch window для просмотра переменных
- Анализировать call stack

## Юнит-тесты

### Пример структуры теста

```cpp
void testPawnMoves() {
    Board board;
    board.setupFromFEN("8/8/8/8/4P3/8/8/8 w - - 0 1");
    MoveGenerator generator(board);
    
    std::vector<Move> moves = generator.generateLegalMoves();
    
    // Проверяем количество ходов
    assert(moves.size() == 2); // e4-e5 и e4-e6
    
    // Проверяем конкретные ходы
    bool found_e4_e5 = false;
    bool found_e4_e6 = false;
    
    for (const Move& move : moves) {
        if (move.from == board.algebraicToSquare("e4") && 
            move.to == board.algebraicToSquare("e5")) {
            found_e4_e5 = true;
        }
        if (move.from == board.algebraicToSquare("e4") && 
            move.to == board.algebraicToSquare("e6")) {
            found_e4_e6 = true;
        }
    }
    
    assert(found_e4_e5);
    assert(found_e4_e6);
    
    std::cout << "✓ Тест ходов пешки пройден" << std::endl;
}
```

## Интеграционное тестирование

### Полные партии

```cpp
void testFullGame() {
    Board board;
    MoveGenerator generator(board);
    GameRules rules(board);
    
    // Имитируем короткую партию
    std::vector<std::string> moves = {
        "e2-e4", "e7-e5",
        "Ng1-f3", "Nb8-c6",
        "Bf1-b5" // Испанский дебют
    };
    
    for (const std::string& moveStr : moves) {
        Move move = parseMove(moveStr); // Функция для парсинга
        assert(rules.isValidMove(move));
        rules.makeMove(move);
    }
    
    std::cout << "✓ Тест полной партии пройден" << std::endl;
}
```

## Регрессионное тестирование

### Сохранение тестовых сценариев

**Создайте файлы с известными позициями и ожидаемыми результатами:**

```printtext
test_positions/
├── opening_moves.txt
├── middle_game.txt
├── endgame.txt
└── special_moves.txt
```

## Метрики качества

### Покрытие кода

- Целевое покрытие: 80%+
- Ключевые области: генерация ходов, проверка легальности
- Сложные алгоритмы: минимакс, оценка позиции

### Производительность

- Генерация ходов: < 10 мс для средней позиции
- Поиск лучшего хода (глубина 4): < 1 секунда
- Память: < 100 MB при нормальной игре

## Автоматизация

### CI/CD интеграция

```yaml
# .github/workflows/test.yml
name: Chess Engine Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: |
        mkdir build
        cd build
        cmake ..
        make
    - name: Test
      run: |
        cd build
        ./test_chess
```

## Отчеты об ошибках

### Шаблон отчета

```printtext
Ошибка: [Краткое описание]
Дата: [Дата обнаружения]
Версия: [Номер версии]
Платформа: [Windows/Linux/macOS]

Шаги воспроизведения:
1. [Шаг 1]
2. [Шаг 2]
3. [Шаг 3]

Ожидаемый результат: [Что должно было произойти]
Фактический результат: [Что произошло на самом деле]

Дополнительная информация:
[Логи, скриншоты, FEN позиция]
```
