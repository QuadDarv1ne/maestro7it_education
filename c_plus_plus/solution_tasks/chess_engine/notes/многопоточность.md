# Многопоточный шахматный движок

## Обзор

Многопоточная реализация шахматного движка использует параллельный поиск для распределения вычислений между несколькими ядрами процессора. Это обеспечивает 2-4x ускорение на современных многоядерных системах.

## Архитектура многопоточности

### Подход Lazy SMP

Реализован подход Lazy SMP (Simple Multi-Processing), который:
- Запускает несколько независимых потоков поиска
- Каждый поток выполняет тот же алгоритм минимакс
- Потоки делят общую транспозиционную таблицу
- Основной поток координирует результаты

### Преимущества Lazy SMP:
- **Простота реализации** - минимальные изменения в существующем коде
- **Отличная масштабируемость** - линейное ускорение до 4-8 ядер
- **Надежность** - отсутствие сложной синхронизации
- **Совместимость** - работает с существующими оптимизациями

## Техническая реализация

### Основные компоненты:

1. **Пул потоков** - управление рабочими потоками
2. **Разделяемая память** - транспозиционная таблица и история
3. **Синхронизация** - атомарные операции и мьютексы
4. **Координация** - обмен лучшими ходами между потоками

### Структура данных:

```cpp
class ParallelChessEngine {
private:
    // Разделяемые данные
    std::atomic<bool> stopSearch_;      // Флаг остановки
    std::atomic<int> bestScore_;        // Лучший результат
    std::atomic<Move> bestMove_;        // Лучший ход
    std::vector<TranspositionEntry> transpositionTable_; // Общая ТТ
    std::vector<int> historyTable_;     // Общая история
    
    // Синхронизация
    mutable std::mutex sharedMutex_;
    std::condition_variable searchFinished_;
};
```

## Алгоритм работы

### 1. Инициализация:
```
- Создание пула потоков
- Инициализация разделяемых структур данных
- Установка начальных параметров поиска
```

### 2. Параллельный поиск:
```
Для каждого потока:
  - Генерация_legal_moves()
  - Упорядочивание ходов
  - Итеративное углубление
  - Минимакс с альфа-бета отсечением
  - Обновление общих результатов
```

### 3. Координация:
```
- Основной поток собирает лучшие результаты
- Атомарное обновление глобальных значений
- Синхронизация по времени
- Корректная остановка всех потоков
```

## Производительность

### Ожидаемые улучшения:

| Число ядер | Ускорение | Эффективность |
|------------|-----------|---------------|
| 2 ядра     | 1.8x      | 90%           |
| 4 ядра     | 3.2x      | 80%           |
| 6 ядер     | 4.5x      | 75%           |
| 8 ядер     | 6.0x      | 75%           |

### Факторы масштабируемости:

1. **Размер транспозиционной таблицы** - больше памяти = лучше кэширование
2. **Глубина поиска** - глубже = больше параллелизма
3. **Сложность позиции** - тактические позиции = больше ветвления
4. **Качество упорядочивания ходов** - лучше = эффективнее отсечения

## Оптимизации многопоточности

### 1. Work Stealing
- Потоки могут "украсть" работу у других потоков
- Балансировка нагрузки в реальном времени
- Уменьшение времени простоя

### 2. Адаптивное разделение
- Разные стратегии разделения для разных типов позиций
- Учет истории ходов при распределении
- Динамическая настройка глубины разделения

### 3. Оптимизированная синхронизация
- Минимизация блокировок
- Атомарные операции для критических данных
- Lock-free структуры данных где возможно

## Практические рекомендации

### Настройка числа потоков:
- **2-4 ядра**: использовать все ядра
- **6-8 ядер**: 6-7 потоков (оставить 1-2 для системы)
- **8+ ядер**: 8-12 потоков (уменьшающаяся эффективность)

### Настройка памяти:
- **Транспозиционная таблица**: 1MB на поток минимум
- **Общая память**: 16-32MB для сложных позиций
- **Кэширование**: использовать L3 кэш оптимально

### Мониторинг производительности:
- Количество обработанных узлов в секунду (NPS)
- Эффективность использования CPU
- Размер и попадания в транспозиционную таблицу
- Балансировка нагрузки между потоками

## Интеграция с существующими компонентами

### Совместимость:
- ✅ Bitboard представление
- ✅ Инкрементальная оценка
- ✅ Все эвристики поиска
- ✅ Транспозиционные таблицы
- ✅ Упорядочивание ходов

### Требования:
- Поддержка C++11 threads
- Атомарные операции
- Синхронизация потоков

## Тестирование и отладка

### Стратегии тестирования:
1. **Функциональное тестирование** - корректность результатов
2. **Стресс-тестирование** - стабильность при высокой нагрузке
3. **Регрессионное тестирование** - отсутствие ухудшений
4. **Производительностное тестирование** - измерение ускорения

### Инструменты отладки:
- Thread sanitizers
- Профилировщики CPU
- Мониторинг памяти
- Логирование потоков

## Заключение

Многопоточная реализация является ключевым этапом создания профессионального шахматного движка. При правильной реализации она обеспечивает значительное ускорение без потери качества игры и готова к интеграции с другими оптимизациями.