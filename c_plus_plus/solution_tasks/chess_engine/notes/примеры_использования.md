# Примеры использования шахматного движка

## Базовое использование

### Создание и настройка доски

```cpp
#include "board.hpp"
#include "console_ui.hpp"

int main() {
    // Создание новой игры
    ConsoleUI game;
    game.run(); // Запуск основного цикла игры
    return 0;
}
```

### Работа с доской напрямую

```cpp
#include "board.hpp"
#include "move_generator.hpp"

void demonstrateBasicUsage() {
    // Создание начальной позиции
    Board board;
    board.setupStartPosition();
    
    // Отображение доски
    board.printBoard();
    
    // Получение фигуры с конкретной клетки
    Piece piece = board.getPiece(board.algebraicToSquare("e2"));
    std::cout << "Фигура на e2: " << piece.getName() << std::endl;
    
    // Создание генератора ходов
    MoveGenerator generator(board);
    std::vector<Move> moves = generator.generateLegalMoves();
    
    std::cout << "Доступных ходов: " << moves.size() << std::endl;
}
```

## Игровые сценарии

### Человек против человека

```cpp
#include "console_ui.hpp"

void humanVsHuman() {
    ConsoleUI game;
    game.setGameMode(GameMode::HUMAN_VS_HUMAN);
    game.run();
}
```

### Человек против компьютера

```cpp
#include "console_ui.hpp"

void humanVsAI() {
    ConsoleUI game;
    game.setGameMode(GameMode::HUMAN_VS_AI);
    game.setPlayerTypes(PlayerType::HUMAN, PlayerType::AI);
    game.setAIDifficulty(4); // Глубина поиска 4
    game.run();
}
```

### Компьютер против компьютера (демонстрация)

```cpp
#include "console_ui.hpp"

void aiVsAiDemo() {
    ConsoleUI game;
    game.setGameMode(GameMode::AI_VS_AI);
    game.setPlayerTypes(PlayerType::AI, PlayerType::AI);
    game.setAIDifficulty(3); // Оба ИИ с глубиной 3
    game.run();
}
```

## Работа с ходами

### Создание и выполнение ходов

```cpp
#include "board.hpp"
#include "move_generator.hpp"

void makeMovesExample() {
    Board board;
    board.setupStartPosition();
    
    // Создание хода в алгебраической нотации
    Move move1(board.algebraicToSquare("e2"), board.algebraicToSquare("e4"));
    Move move2 = MoveGenerator::parseMove("Ng1-f3"); // Если будет такой метод
    
    // Выполнение хода
    if (board.isValidMove(move1.from, move1.to)) {
        board.makeMove(move1.from, move1.to);
        board.printBoard();
    }
}
```

### Генерация всех легальных ходов

```cpp
#include "board.hpp"
#include "move_generator.hpp"

void generateAllMoves() {
    Board board;
    board.setupStartPosition();
    
    MoveGenerator generator(board);
    std::vector<Move> legalMoves = generator.generateLegalMoves();
    
    std::cout << "Все легальные ходы из начальной позиции:" << std::endl;
    for (const Move& move : legalMoves) {
        std::cout << board.squareToAlgebraic(move.from) 
                  << "-" << board.squareToAlgebraic(move.to) << std::endl;
    }
}
```

## Работа с ИИ

### Поиск лучшего хода

```cpp
#include "board.hpp"
#include "minimax.hpp"

void findBestMove() {
    Board board;
    board.setupStartPosition();
    
    Minimax engine(board, 4); // Глубина поиска 4
    Move bestMove = engine.findBestMove(Color::WHITE);
    
    std::cout << "Лучший ход для белых: " 
              << board.squareToAlgebraic(bestMove.from)
              << "-" << board.squareToAlgebraic(bestMove.to) << std::endl;
}
```

### Оценка позиции

```cpp
#include "board.hpp"
#include "position_evaluator.hpp"

void evaluatePosition() {
    Board board;
    // Настройка какой-то позиции
    PositionEvaluator evaluator(board);
    
    int score = evaluator.evaluate();
    std::cout << "Оценка позиции: " << score << std::endl;
    
    if (score > 0) {
        std::cout << "Белые имеют преимущество" << std::endl;
    } else if (score < 0) {
        std::cout << "Черные имеют преимущество" << std::endl;
    } else {
        std::cout << "Позиция равная" << std::endl;
    }
}
```

## Расширенные примеры

### Анализ партии

```cpp
#include "board.hpp"
#include "game_rules.hpp"
#include "move_generator.hpp"

void analyzeGame() {
    Board board;
    GameRules rules(board);
    MoveGenerator generator(board);
    
    // Пример партии
    std::vector<std::string> moves = {
        "e2-e4", "e7-e5",
        "Ng1-f3", "Nb8-c6",
        "Bf1-b5" // Испанский дебют
    };
    
    for (const std::string& moveStr : moves) {
        Move move = parseAlgebraicMove(moveStr, board);
        if (rules.isValidMove(move)) {
            rules.makeMove(move);
            board.printBoard();
            
            // Проверка состояния игры
            if (rules.isCheck(Color::BLACK)) {
                std::cout << "Шах черному королю!" << std::endl;
            }
        }
    }
}
```

### Создание произвольной позиции (FEN)

```cpp
void setupCustomPosition() {
    Board board;
    // Позиция после ходов: 1.e4 e5 2.Nf3 Nc6 3.Bb5
    std::string fen = "r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 0 3";
    board.setupFromFEN(fen);
    board.printBoard();
}
```

### Тестирование производительности

```cpp
#include <chrono>

void performanceTest() {
    Board board;
    board.setupStartPosition();
    Minimax engine(board, 5);
    
    auto start = std::chrono::high_resolution_clock::now();
    Move bestMove = engine.findBestMove(Color::WHITE);
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "Найден лучший ход: " 
              << board.squareToAlgebraic(bestMove.from)
              << "-" << board.squareToAlgebraic(bestMove.to) << std::endl;
    std::cout << "Время поиска: " << duration.count() << " мс" << std::endl;
}
```

## Обработка ошибок

```cpp
#include "board.hpp"
#include "game_rules.hpp"

void errorHandling() {
    Board board;
    GameRules rules(board);
    
    try {
        // Попытка сделать некорректный ход
        Move invalidMove(board.algebraicToSquare("e1"), board.algebraicToSquare("e3"));
        if (!rules.isValidMove(invalidMove)) {
            std::cout << "Ошибка: Некорректный ход!" << std::endl;
        }
        
        // Попытка хода когда игра окончена
        if (rules.isGameOver()) {
            std::cout << "Ошибка: Игра уже окончена!" << std::endl;
        }
        
    } catch (const std::exception& e) {
        std::cout << "Произошла ошибка: " << e.what() << std::endl;
    }
}
```

## Советы по использованию

1. **Всегда проверяйте легальность ходов** перед их выполнением
2. **Используйте соответствующую глубину поиска** для ИИ в зависимости от доступного времени
3. **Сохраняйте историю ходов** для возможности отмены и анализа
4. **Обрабатывайте все возможные исключения** для надежной работы
5. **Профилируйте код** для определения узких мест производительности

