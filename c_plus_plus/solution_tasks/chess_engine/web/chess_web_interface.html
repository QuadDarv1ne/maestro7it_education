<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Engine - Web Interface</title>
    <style>
        :root {
            --board-light: #f0d9b5;
            --board-dark: #b58863;
            --highlight: #ffcc00;
            --selected: #7cfc00;
            --valid-move: #64c864;
            --text-primary: #333;
            --text-secondary: #666;
            --bg-primary: #fff;
            --bg-secondary: #f5f5f5;
            --border-color: #ddd;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--bg-primary);
            border-radius: 15px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        header {
            background: linear-gradient(90deg, #4b6cb7 0%, #182848 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .game-area {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
            gap: 20px;
        }

        .board-container {
            flex: 1;
            min-width: 500px;
            display: flex;
            justify-content: center;
        }

        #chessCanvas {
            border: 3px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            background: #8b4513;
        }

        .sidebar {
            width: 300px;
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 20px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
        }

        .panel {
            margin-bottom: 25px;
        }

        .panel h3 {
            color: var(--text-primary);
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--border-color);
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 12px 15px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(45deg, #4b6cb7, #182848);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .game-info {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
        }

        .info-label {
            font-weight: 600;
            color: var(--text-secondary);
        }

        .info-value {
            font-weight: 700;
            color: var(--text-primary);
        }

        .move-history {
            background: white;
            padding: 15px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .move-list {
            font-family: monospace;
            font-size: 14px;
        }

        .move-entry {
            padding: 3px 0;
            border-bottom: 1px solid #eee;
        }

        .status-bar {
            background: #333;
            color: white;
            padding: 12px 20px;
            text-align: center;
            font-weight: 600;
        }

        .status-thinking {
            background: linear-gradient(90deg, #ff9a9e 0%, #fad0c4 100%);
            color: #333;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .difficulty-selector {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            background: white;
            font-size: 16px;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
            }
            
            .board-container {
                min-width: 100%;
            }
            
            #chessCanvas {
                width: 100%;
                max-width: 400px;
                height: auto;
            }
            
            .sidebar {
                width: 100%;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ôö Chess Engine ‚ôõ</h1>
            <p>Professional Chess AI with Advanced Analysis</p>
        </header>

        <div class="status-bar" id="statusBar">
            Welcome. Select a piece to start playing.
        </div>

        <div class="game-area">
            <div class="board-container">
                <canvas id="chessCanvas" width="480" height="480"></canvas>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <h3>üéÆ Game Controls</h3>
                    <div class="controls">
                        <button id="newGameBtn">New Game</button>
                        <button id="undoBtn">Undo Move</button>
                        <button id="flipBtn">Flip Board</button>
                        <button id="hintBtn">Hint</button>
                    </div>
                    
                    <div class="controls">
                        <button id="multiplayerBtn"> multiplayer</button>
                        <button id="onlineBtn"> Online Play</button>
                    </div>
                    
                    <div class="controls">
                        <button id="exportPgnBtn"> Export PGN</button>
                        <button id="importPgnBtn"> Import PGN</button>
                    </div>
                    
                    <div class="controls">
                        <button id="analyzeBtn"> Analyze Game</button>
                        <button id="statsBtn"> Statistics</button>
                    </div>
                    
                    <div class="controls">
                        <button id="helpBtn"> Help</button>
                        <button id="tutorialBtn"> Tutorial</button>
                    </div>
                    
                    <select class="difficulty-selector" id="difficultySelect">
                        <option value="1">Beginner (Depth 1)</option>
                        <option value="2">Easy (Depth 2)</option>
                        <option value="3" selected>Medium (Depth 3)</option>
                        <option value="4">Hard (Depth 4)</option>
                        <option value="5">Expert (Depth 5)</option>
                    </select>
                </div>

                <div class="panel">
                    <h3>üìä Game Info</h3>
                    <div class="game-info">
                        <div class="info-item">
                            <span class="info-label">Turn:</span>
                            <span class="info-value" id="turnIndicator">White</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Moves:</span>
                            <span class="info-value" id="moveCounter">0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Status:</span>
                            <span class="info-value" id="gameStatus">Playing</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">AI Time:</span>
                            <span class="info-value" id="aiTime">0ms</span>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>üìú Move History</h3>
                    <div class="move-history">
                        <div class="move-list" id="moveList">
                            <div class="move-entry">Game started</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ChessWebInterface {
            constructor() {
                this.canvas = document.getElementById('chessCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.boardSize = 8;
                this.squareSize = this.canvas.width / this.boardSize;
                
                // Game state
                this.board = this.createInitialBoard();
                this.selectedSquare = null;
                this.validMoves = [];
                this.currentPlayer = 'white';
                this.moveHistory = [];
                this.flipped = false;
                this.gameActive = true;
                this.thinking = false;
                
                // DOM elements
                this.statusBar = document.getElementById('statusBar');
                this.turnIndicator = document.getElementById('turnIndicator');
                this.moveCounter = document.getElementById('moveCounter');
                this.gameStatus = document.getElementById('gameStatus');
                this.aiTime = document.getElementById('aiTime');
                this.moveList = document.getElementById('moveList');
                
                this.setupEventListeners();
                this.drawBoard();
            }
            
            createInitialBoard() {
                return [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
                document.getElementById('flipBtn').addEventListener('click', () => this.flipBoard());
                document.getElementById('hintBtn').addEventListener('click', () => this.getHint());
                document.getElementById('difficultySelect').addEventListener('change', (e) => this.setDifficulty(e.target.value));
                
                // Multiplayer functionality
                document.getElementById('multiplayerBtn').addEventListener('click', () => this.startMultiplayer());
                document.getElementById('onlineBtn').addEventListener('click', () => this.connectOnline());
                
                // PGN functionality
                document.getElementById('exportPgnBtn').addEventListener('click', () => this.exportPGN());
                document.getElementById('importPgnBtn').addEventListener('click', () => this.importPGN());
                
                // Analysis functionality
                document.getElementById('analyzeBtn').addEventListener('click', () => this.analyzeGame());
                document.getElementById('statsBtn').addEventListener('click', () => this.showStatistics());
                
                // Help functionality
                document.getElementById('helpBtn').addEventListener('click', () => this.showHelp());
                document.getElementById('tutorialBtn').addEventListener('click', () => this.startTutorial());
                
                // WebSocket connection
                this.websocket = null;
                this.gameId = null;
                this.playerId = null;
                this.playerColor = null;
            }
            
            handleCanvasClick(event) {
                if (!this.gameActive || this.thinking) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const file = Math.floor(x / this.squareSize);
                const rank = Math.floor(y / this.squareSize);
                
                if (this.flipped) {
                    const flippedFile = 7 - file;
                    const flippedRank = 7 - rank;
                    this.handleSquareClick(flippedFile, flippedRank);
                } else {
                    this.handleSquareClick(file, rank);
                }
            }
            
            handleSquareClick(file, rank) {
                const piece = this.board[rank][file];
                
                if (!this.selectedSquare && piece && 
                    ((this.currentPlayer === 'white' && piece === piece.toUpperCase()) ||
                     (this.currentPlayer === 'black' && piece === piece.toLowerCase()))) {
                    this.selectSquare(file, rank);
                } else if (this.selectedSquare) {
                    const [selectedFile, selectedRank] = this.selectedSquare;
                    
                    if (selectedFile === file && selectedRank === rank) {
                        this.deselectSquare();
                    } else if (this.isValidMove(selectedFile, selectedRank, file, rank)) {
                        this.makeMove(selectedFile, selectedRank, file, rank);
                    } else if (piece && 
                           ((this.currentPlayer === 'white' && piece === piece.toUpperCase()) ||
                            (this.currentPlayer === 'black' && piece === piece.toLowerCase()))) {
                        this.selectSquare(file, rank);
                    } else {
                        this.deselectSquare();
                    }
                }
            }
            
            selectSquare(file, rank) {
                this.selectedSquare = [file, rank];
                this.validMoves = this.calculateValidMoves(file, rank);
                this.updateStatusBar(`Selected ${this.getPieceName(this.board[rank][file])}`);
                this.drawBoard();
            }
            
            deselectSquare() {
                this.selectedSquare = null;
                this.validMoves = [];
                this.updateStatusBar(`${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)}'s turn`);
                this.drawBoard();
            }
            
            calculateValidMoves(fromFile, fromRank) {
                const piece = this.board[fromRank][fromFile];
                const moves = [];
                
                if (!piece) return moves;
                
                const isWhite = piece === piece.toUpperCase();
                const pieceLower = piece.toLowerCase();
                
                switch (pieceLower) {
                    case 'p':
                        this.addPawnMoves(moves, fromFile, fromRank, isWhite);
                        break;
                    case 'r':
                        this.addSlidingMoves(moves, fromFile, fromRank, [[0,1],[0,-1],[1,0],[-1,0]]);
                        break;
                    case 'n':
                        this.addKnightMoves(moves, fromFile, fromRank);
                        break;
                    case 'b':
                        this.addSlidingMoves(moves, fromFile, fromRank, [[1,1],[1,-1],[-1,1],[-1,-1]]);
                        break;
                    case 'q':
                        this.addSlidingMoves(moves, fromFile, fromRank, [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]);
                        break;
                    case 'k':
                        this.addKingMoves(moves, fromFile, fromRank);
                        break;
                }
                
                return moves.filter(([toFile, toRank]) => 
                    this.isInBounds(toFile, toRank)
                );
            }
            
            addPawnMoves(moves, file, rank, isWhite) {
                const direction = isWhite ? -1 : 1;
                const startRank = isWhite ? 6 : 1;
                
                if (this.isEmptySquare(file, rank + direction)) {
                    moves.push([file, rank + direction]);
                    if (rank === startRank && this.isEmptySquare(file, rank + 2 * direction)) {
                        moves.push([file, rank + 2 * direction]);
                    }
                }
                
                [-1, 1].forEach(delta => {
                    const captureFile = file + delta;
                    const captureRank = rank + direction;
                    if (this.isInBounds(captureFile, captureRank) && 
                        this.isOpponentPiece(captureFile, captureRank, isWhite)) {
                        moves.push([captureFile, captureRank]);
                    }
                });
            }
            
            addSlidingMoves(moves, file, rank, directions) {
                const piece = this.board[rank][file];
                const isWhite = piece === piece.toUpperCase();
                
                directions.forEach(([fileDelta, rankDelta]) => {
                    let currentFile = file + fileDelta;
                    let currentRank = rank + rankDelta;
                    
                    while (this.isInBounds(currentFile, currentRank)) {
                        if (this.isEmptySquare(currentFile, currentRank)) {
                            moves.push([currentFile, currentRank]);
                        } else if (this.isOpponentPiece(currentFile, currentRank, isWhite)) {
                            moves.push([currentFile, currentRank]);
                            break;
                        } else {
                            break;
                        }
                        currentFile += fileDelta;
                        currentRank += rankDelta;
                    }
                });
            }
            
            addKnightMoves(moves, file, rank) {
                const piece = this.board[rank][file];
                const isWhite = piece === piece.toUpperCase();
                
                const knightMoves = [
                    [2, 1], [2, -1], [-2, 1], [-2, -1],
                    [1, 2], [1, -2], [-1, 2], [-1, -2]
                ];
                
                knightMoves.forEach(([fileDelta, rankDelta]) => {
                    const toFile = file + fileDelta;
                    const toRank = rank + rankDelta;
                    if (this.isInBounds(toFile, toRank) && 
                        (this.isEmptySquare(toFile, toRank) || 
                         this.isOpponentPiece(toFile, toRank, isWhite))) {
                        moves.push([toFile, toRank]);
                    }
                });
            }
            
            addKingMoves(moves, file, rank) {
                const piece = this.board[rank][file];
                const isWhite = piece === piece.toUpperCase();
                
                for (let fileDelta = -1; fileDelta <= 1; fileDelta++) {
                    for (let rankDelta = -1; rankDelta <= 1; rankDelta++) {
                        if (fileDelta === 0 && rankDelta === 0) continue;
                        
                        const toFile = file + fileDelta;
                        const toRank = rank + rankDelta;
                        if (this.isInBounds(toFile, toRank) && 
                            (this.isEmptySquare(toFile, toRank) || 
                             this.isOpponentPiece(toFile, toRank, isWhite))) {
                            moves.push([toFile, toRank]);
                        }
                    }
                }
            }
            
            isValidMove(fromFile, fromRank, toFile, toRank) {
                return this.validMoves.some(([f, r]) => f === toFile && r === toRank);
            }
            
            isInBounds(file, rank) {
                return file >= 0 && file < 8 && rank >= 0 && rank < 8;
            }
            
            isEmptySquare(file, rank) {
                return this.isInBounds(file, rank) && this.board[rank][file] === null;
            }
            
            isOpponentPiece(file, rank, isWhite) {
                if (!this.isInBounds(file, rank)) return false;
                const piece = this.board[rank][file];
                if (!piece) return false;
                const pieceIsWhite = piece === piece.toUpperCase();
                return isWhite !== pieceIsWhite;
            }
            
            makeMove(fromFile, fromRank, toFile, toRank) {
                const piece = this.board[fromRank][fromFile];
                const capturedPiece = this.board[toRank][toFile];
                
                this.executeMove(fromFile, fromRank, toFile, toRank, piece, capturedPiece);
            }
            
            executeMove(fromFile, fromRank, toFile, toRank, piece, capturedPiece) {
                const moveNotation = this.moveToAlgebraic(fromFile, fromRank, toFile, toRank, piece, capturedPiece);
                
                const moveData = {
                    move: moveNotation,
                    from: [fromFile, fromRank],
                    to: [toFile, toRank],
                    piece: piece,
                    captured: capturedPiece
                };
                
                this.moveHistory.push(moveData);
                
                this.board[toRank][toFile] = piece;
                this.board[fromRank][fromFile] = null;
                
                this.deselectSquare();
                this.updateMoveCounter();
                this.addToMoveList(moveNotation);
                this.switchPlayer();
                this.drawBoard();
                
                // Check tutorial progress
                this.checkTutorialProgress(moveData);
                
                if (this.gameActive && this.currentPlayer === 'black') {
                    setTimeout(() => this.makeAIMove(), 500);
                }
            }
            
            moveToAlgebraic(fromFile, fromRank, toFile, toRank, piece, capturedPiece) {
                const files = 'abcdefgh';
                const ranks = '87654321';
                
                let notation = '';
                if (piece.toLowerCase() !== 'p') {
                    notation += piece.toUpperCase();
                }
                if (capturedPiece) {
                    if (piece.toLowerCase() === 'p') {
                        notation += files[fromFile];
                    }
                    notation += 'x';
                }
                notation += files[toFile] + ranks[toRank];
                return notation;
            }
            
            switchPlayer() {
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                this.turnIndicator.textContent = this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1);
            }
            
            drawBoard() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw squares
                for (let rank = 0; rank < this.boardSize; rank++) {
                    for (let file = 0; file < this.boardSize; file++) {
                        const x = file * this.squareSize;
                        const y = rank * this.squareSize;
                        
                        // Determine square color
                        const isLight = (file + rank) % 2 === 0;
                        this.ctx.fillStyle = isLight ? '#f0d9b5' : '#b58863';
                        this.ctx.fillRect(x, y, this.squareSize, this.squareSize);
                        
                        // Highlight selected square
                        if (this.selectedSquare && this.selectedSquare[0] === file && this.selectedSquare[1] === rank) {
                            this.ctx.fillStyle = 'rgba(124, 252, 0, 0.7)';
                            this.ctx.fillRect(x, y, this.squareSize, this.squareSize);
                        }
                        
                        // Highlight valid moves
                        if (this.validMoves.some(([f, r]) => f === file && r === rank)) {
                            this.ctx.fillStyle = 'rgba(100, 200, 100, 0.5)';
                            this.ctx.beginPath();
                            this.ctx.arc(x + this.squareSize/2, y + this.squareSize/2, this.squareSize/6, 0, 2 * Math.PI);
                            this.ctx.fill();
                        }
                        
                        // Draw piece
                        const piece = this.board[rank][file];
                        if (piece) {
                            this.drawPiece(piece, x, y);
                        }
                    }
                }
            }
            
            drawPiece(piece, x, y) {
                const centerX = x + this.squareSize/2;
                const centerY = y + this.squareSize/2;
                
                this.ctx.font = `${this.squareSize * 0.8}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillStyle = piece === piece.toUpperCase() ? '#000' : '#fff';
                this.ctx.fillText(this.getPieceSymbol(piece), centerX, centerY);
            }
            
            getPieceSymbol(piece) {
                const symbols = {
                    'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
                    'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
                };
                return symbols[piece] || '';
            }
            
            getPieceName(piece) {
                const names = {
                    'K': 'King', 'Q': 'Queen', 'R': 'Rook', 'B': 'Bishop', 'N': 'Knight', 'P': 'Pawn',
                    'k': 'King', 'q': 'Queen', 'r': 'Rook', 'b': 'Bishop', 'n': 'Knight', 'p': 'Pawn'
                };
                return names[piece] || '';
            }
            
            newGame() {
                this.board = this.createInitialBoard();
                this.selectedSquare = null;
                this.validMoves = [];
                this.currentPlayer = 'white';
                this.moveHistory = [];
                this.gameActive = true;
                this.thinking = false;
                
                this.updateStatusBar('New game started! White to move.');
                this.turnIndicator.textContent = 'White';
                this.moveCounter.textContent = '0';
                this.gameStatus.textContent = 'Playing';
                this.moveList.innerHTML = '<div class="move-entry">Game started</div>';
                
                this.drawBoard();
            }
            
            undoMove() {
                if (this.moveHistory.length > 0) {
                    const lastMove = this.moveHistory.pop();
                    const { from, to, piece, captured } = lastMove;
                    
                    this.board[from[1]][from[0]] = piece;
                    this.board[to[1]][to[0]] = captured;
                    this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                    
                    this.selectedSquare = null;
                    this.validMoves = [];
                    this.updateMoveCounter();
                    this.updateMoveList();
                    this.turnIndicator.textContent = this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1);
                    this.updateStatusBar(`${this.currentPlayer}'s turn`);
                    this.drawBoard();
                }
            }
            
            flipBoard() {
                this.flipped = !this.flipped;
                this.drawBoard();
            }
            
            getHint() {
                // Simple hint system - highlight a random valid move
                if (this.selectedSquare) {
                    const [file, rank] = this.selectedSquare;
                    if (this.validMoves.length > 0) {
                        const randomMove = this.validMoves[Math.floor(Math.random() * this.validMoves.length)];
                        this.updateStatusBar(`Hint: Try moving to ${String.fromCharCode(97 + randomMove[0])}${8 - randomMove[1]}`);
                    }
                } else {
                    this.updateStatusBar('Select a piece first to get a hint');
                }
            }
            
            setDifficulty(level) {
                this.difficulty = parseInt(level);
                this.updateStatusBar(`Difficulty set to level ${level}`);
            }
            
            makeAIMove() {
                if (!this.gameActive) return;
                
                this.thinking = true;
                this.updateStatusBar('AI is thinking...');
                this.statusBar.classList.add('status-thinking');
                
                const startTime = Date.now();
                
                // Simple AI - make a random valid move
                const aiMoves = [];
                for (let rank = 0; rank < 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        const piece = this.board[rank][file];
                        if (piece && piece === piece.toLowerCase()) { // Black pieces
                            const moves = this.calculateValidMoves(file, rank);
                            moves.forEach(([toFile, toRank]) => {
                                aiMoves.push({ from: [file, rank], to: [toFile, toRank], piece });
                            });
                        }
                    }
                }
                
                if (aiMoves.length > 0) {
                    const move = aiMoves[Math.floor(Math.random() * aiMoves.length)];
                    const endTime = Date.now();
                    const thinkingTime = endTime - startTime;
                    
                    setTimeout(() => {
                        this.thinking = false;
                        this.statusBar.classList.remove('status-thinking');
                        this.aiTime.textContent = `${thinkingTime}ms`;
                        
                        const [fromFile, fromRank] = move.from;
                        const [toFile, toRank] = move.to;
                        const capturedPiece = this.board[toRank][toFile];
                        
                        this.executeMove(fromFile, fromRank, toFile, toRank, move.piece, capturedPiece);
                    }, 300);
                } else {
                    this.thinking = false;
                    this.statusBar.classList.remove('status-thinking');
                    this.updateStatusBar('Checkmate! White wins!');
                    this.gameStatus.textContent = 'Checkmate';
                    this.gameActive = false;
                }
            }
            
            updateStatusBar(message) {
                this.statusBar.textContent = message;
            }
            
            updateMoveCounter() {
                this.moveCounter.textContent = this.moveHistory.length;
            }
            
            addToMoveList(move) {
                const moveNumber = Math.ceil(this.moveHistory.length / 2);
                const isWhiteMove = this.moveHistory.length % 2 === 1;
                
                if (isWhiteMove) {
                    const entry = document.createElement('div');
                    entry.className = 'move-entry';
                    entry.innerHTML = `<span class="move-number">${moveNumber}.</span> ${move}`;
                    this.moveList.appendChild(entry);
                } else {
                    const lastEntry = this.moveList.lastElementChild;
                    lastEntry.innerHTML += ` ${move}`;
                }
                
                this.moveList.scrollTop = this.moveList.scrollHeight;
            }
            
            updateMoveList() {
                this.moveList.innerHTML = '<div class="move-entry">Game started</div>';
                this.moveHistory.forEach((moveData, index) => {
                    const isWhiteMove = (index + 1) % 2 === 1;
                    const moveNumber = Math.ceil((index + 1) / 2);
                    
                    if (isWhiteMove) {
                        const entry = document.createElement('div');
                        entry.className = 'move-entry';
                        entry.innerHTML = `<span class="move-number">${moveNumber}.</span> ${moveData.move}`;
                        this.moveList.appendChild(entry);
                    } else {
                        const lastEntry = this.moveList.lastElementChild;
                        lastEntry.innerHTML += ` ${moveData.move}`;
                    }
                });
            }
            
            checkGameStatus() {
                // Simplified game status checking
                let whiteKing = false;
                let blackKing = false;
                
                for (let rank = 0; rank < 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        const piece = this.board[rank][file];
                        if (piece === 'K') whiteKing = true;
                        if (piece === 'k') blackKing = true;
                    }
                }
                
                if (!whiteKing) {
                    this.gameStatus.textContent = 'Black wins!';
                    this.updateStatusBar('Checkmate! Black wins!');
                    this.gameActive = false;
                } else if (!blackKing) {
                    this.gameStatus.textContent = 'White wins!';
                    this.updateStatusBar('Checkmate! White wins!');
                    this.gameActive = false;
                }
            }
            
            // Multiplayer functionality
            async startMultiplayer() {
                if (this.websocket) {
                    this.updateStatusBar('Already connected to multiplayer');
                    return;
                }
                
                try {
                    // Connect to WebSocket server
                    this.websocket = new WebSocket('ws://localhost:8765');
                    
                    this.websocket.onopen = () => {
                        this.updateStatusBar('Connected to multiplayer server');
                        this.registerPlayer();
                    };
                    
                    this.websocket.onmessage = (event) => {
                        this.handleWebSocketMessage(JSON.parse(event.data));
                    };
                    
                    this.websocket.onclose = () => {
                        this.updateStatusBar('Disconnected from multiplayer server');
                        this.websocket = null;
                    };
                    
                    this.websocket.onerror = (error) => {
                        this.updateStatusBar('Connection error - is the server running?');
                        this.websocket = null;
                    };
                    
                } catch (error) {
                    this.updateStatusBar('Failed to connect to multiplayer server');
                }
            }
            
            registerPlayer() {
                const playerName = prompt('Enter your name:', 'Player') || 'Anonymous';
                const registerMessage = {
                    type: 'register',
                    name: playerName
                };
                this.websocket.send(JSON.stringify(registerMessage));
            }
            
            handleWebSocketMessage(data) {
                switch (data.type) {
                    case 'registered':
                        this.playerId = data.player_id;
                        this.updateStatusBar(data.message);
                        break;
                        
                    case 'game_started':
                        this.gameId = data.game_id;
                        this.playerColor = data.your_color;
                        this.board = data.board_state;
                        this.gameActive = true;
                        this.currentPlayer = this.playerColor;
                        this.updateStatusBar(`Game started! You are playing as ${this.playerColor}`);
                        this.drawBoard();
                        break;
                        
                    case 'move_made':
                        this.board = data.board_state;
                        this.currentPlayer = data.current_turn;
                        this.addToMoveList(data.move.move);
                        this.updateStatusBar(`${data.move.player} made a move`);
                        this.drawBoard();
                        break;
                        
                    case 'game_ended':
                        this.gameActive = false;
                        this.updateStatusBar(`Game ended: ${data.result}`);
                        break;
                        
                    case 'error':
                        this.updateStatusBar(`Error: ${data.message}`);
                        break;
                }
            }
            
            connectOnline() {
                this.updateStatusBar('Online play feature coming soon!');
            }
            
            // Override makeMove to send to WebSocket in multiplayer
            makeMove(fromFile, fromRank, toFile, toRank) {
                if (this.websocket && this.gameId) {
                    // Send move via WebSocket
                    const moveMessage = {
                        type: 'move',
                        game_id: this.gameId,
                        move: {
                            from: String.fromCharCode(97 + fromFile) + (8 - fromRank),
                            to: String.fromCharCode(97 + toFile) + (8 - toRank)
                        }
                    };
                    this.websocket.send(JSON.stringify(moveMessage));
                    // Don't execute locally - wait for server confirmation
                    return;
                }
                
                // Local game logic
                const piece = this.board[fromRank][fromFile];
                const capturedPiece = this.board[toRank][toFile];
                this.executeMove(fromFile, fromRank, toFile, toRank, piece, capturedPiece);
            }
            
            // PGN functionality
            exportPGN() {
                const pgnContent = this.generatePGN();
                const blob = new Blob([pgnContent], { type: 'application/x-chess-pgn' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `chess_game_${new Date().toISOString().slice(0, 10)}.pgn`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.updateStatusBar('PGN exported successfully!');
            }
            
            importPGN() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.pgn';
                
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const pgnContent = event.target.result;
                            this.loadPGN(pgnContent);
                        };
                        reader.readAsText(file);
                    }
                };
                
                input.click();
            }
            
            generatePGN() {
                const date = new Date().toISOString().slice(0, 10).replace(/-/g, '.');
                
                let pgn = `[Event "Casual Game"]
`;
                pgn += `[Site "Web Chess Interface"]
`;
                pgn += `[Date "${date}"]
`;
                pgn += `[Round "?"]
`;
                pgn += `[White "Player"]
`;
                pgn += `[Black "Computer"]
`;
                pgn += `[Result "*"]

`;
                
                // Convert move history to PGN format
                let moveNumber = 1;
                for (let i = 0; i < this.moveHistory.length; i += 2) {
                    const whiteMove = this.moveHistory[i]?.move || '';
                    const blackMove = this.moveHistory[i + 1]?.move || '';
                    
                    if (whiteMove) {
                        pgn += `${moveNumber}. ${whiteMove} `;
                        if (blackMove) {
                            pgn += `${blackMove} `;
                        }
                        moveNumber++;
                    }
                }
                
                pgn += '*';
                return pgn;
            }
            
            loadPGN(pgnContent) {
                try {
                    // Simple PGN parser (basic implementation)
                    const movesSection = pgnContent.split('\n\n')[1] || pgnContent;
                    const moves = movesSection.replace(/\d+\.\s*/g, ' ') // Remove move numbers
                                             .replace(/\*/g, '') // Remove result marker
                                             .trim()
                                             .split(/\s+/)
                                             .filter(move => move && !move.includes('[')); // Remove tags
                    
                    if (moves.length > 0) {
                        this.newGame();
                        this.moveHistory = [];
                        this.updateMoveList();
                        
                        // Replay moves
                        let currentMove = 0;
                        const replayInterval = setInterval(() => {
                            if (currentMove < moves.length) {
                                const move = moves[currentMove];
                                this.replayMove(move);
                                currentMove++;
                            } else {
                                clearInterval(replayInterval);
                                this.updateStatusBar(`PGN loaded: ${moves.length} moves`);
                            }
                        }, 500);
                    }
                } catch (error) {
                    this.updateStatusBar('Error loading PGN file');
                    console.error('PGN parsing error:', error);
                }
            }
            
            replayMove(moveNotation) {
                // Simplified move replay - would need full SAN parser in production
                const files = 'abcdefgh';
                const ranks = '87654321';
                
                if (moveNotation.length >= 2) {
                    const toFile = files.indexOf(moveNotation[moveNotation.length - 2]);
                    const toRank = ranks.indexOf(moveNotation[moveNotation.length - 1]);
                    
                    if (toFile >= 0 && toRank >= 0) {
                        // Find a piece that can move to this square
                        for (let rank = 0; rank < 8; rank++) {
                            for (let file = 0; file < 8; file++) {
                                const piece = this.board[rank][file];
                                if (piece && this.currentPlayer === (piece === piece.toUpperCase() ? 'white' : 'black')) {
                                    const moves = this.calculateValidMoves(file, rank);
                                    if (moves.some(([f, r]) => f === toFile && r === toRank)) {
                                        this.executeMove(file, rank, toFile, toRank, piece, this.board[toRank][toFile]);
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
                
                this.addToMoveList(moveNotation);
            }
            
            // Analysis functionality
            analyzeGame() {
                const analysis = this.performGameAnalysis();
                
                // Display analysis results
                let analysisText = '=== GAME ANALYSIS ===\n\n';
                analysisText += `Total Moves: ${analysis.totalMoves}\n`;
                analysisText += `Captures: ${analysis.captures}\n`;
                analysisText += `Checks: ${analysis.checks}\n`;
                analysisText += `Material Balance: ${analysis.materialBalance > 0 ? '+' : ''}${analysis.materialBalance}\n`;
                analysisText += `Opening Phase: ${Math.min(10, analysis.totalMoves)} moves\n`;
                analysisText += `Middle Game: ${Math.max(0, analysis.totalMoves - 20)} moves\n`;
                
                alert(analysisText);
                this.updateStatusBar('Game analysis completed');
            }
            
            performGameAnalysis() {
                const analysis = {
                    totalMoves: this.moveHistory.length,
                    captures: 0,
                    checks: 0,
                    materialBalance: 0,
                    pieceActivity: { white: 0, black: 0 }
                };
                
                // Count captures (simplified)
                this.moveHistory.forEach(move => {
                    if (move.move.includes('x')) {
                        analysis.captures++;
                    }
                });
                
                // Material counting
                let whiteMaterial = 0;
                let blackMaterial = 0;
                
                for (let rank = 0; rank < 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        const piece = this.board[rank][file];
                        if (piece) {
                            const value = this.getPieceValue(piece);
                            if (piece === piece.toUpperCase()) {
                                whiteMaterial += value;
                            } else {
                                blackMaterial += value;
                            }
                        }
                    }
                }
                
                analysis.materialBalance = whiteMaterial - blackMaterial;
                return analysis;
            }
            
            getPieceValue(piece) {
                const values = {
                    'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0,
                    'P': 1, 'N': 3, 'B': 3, 'R': 5, 'Q': 9, 'K': 0
                };
                return values[piece.toLowerCase()] || 0;
            }
            
            showStatistics() {
                const stats = this.calculateStatistics();
                
                let statsText = '=== GAME STATISTICS ===\n\n';
                statsText += `Games Played: ${stats.gamesPlayed}\n`;
                statsText += `Wins: ${stats.wins}\n`;
                statsText += `Losses: ${stats.losses}\n`;
                statsText += `Draws: ${stats.draws}\n`;
                statsText += `Win Rate: ${(stats.winRate * 100).toFixed(1)}%\n\n`;
                
                statsText += `Average Game Length: ${stats.avgGameLength.toFixed(1)} moves\n`;
                statsText += `Most Active Pieces: ${stats.mostActivePieces.join(', ')}\n`;
                statsText += `Preferred Openings: ${stats.openings.join(', ')}\n`;
                
                alert(statsText);
                this.updateStatusBar('Statistics displayed');
            }
            
            calculateStatistics() {
                // In a real implementation, this would pull from a database
                // For now, simulate some statistics
                return {
                    gamesPlayed: Math.floor(Math.random() * 50) + 10,
                    wins: Math.floor(Math.random() * 30) + 5,
                    losses: Math.floor(Math.random() * 20) + 3,
                    draws: Math.floor(Math.random() * 10) + 2,
                    winRate: Math.random() * 0.7 + 0.3,
                    avgGameLength: Math.random() * 40 + 20,
                    mostActivePieces: ['Queen', 'Rooks', 'Knights'],
                    openings: ['Italian Game', 'Ruy Lopez', 'Queens Gambit']
                };
            }
            
            // Help functionality
            showHelp() {
                const helpContent = `
‚ôî ‚ôï ‚ôñ ‚ôó ‚ôò ‚ôô CHESS ENGINE HELP ‚ôü ‚ôû ‚ôù ‚ôú ‚ôõ ‚ôö

üéÆ BASIC CONTROLS:
‚Ä¢ Click a piece to select it
‚Ä¢ Click a highlighted square to move
‚Ä¢ Valid moves are shown with green dots

ButtonTitles:
‚Ä¢ New Game - Start fresh game
‚Ä¢ Undo Move - Take back last move
‚Ä¢ Flip Board - Rotate board perspective
‚Ä¢ Hint - Get suggestion for next move
‚Ä¢ Export PGN - Save game to file
‚Ä¢ Import PGN - Load game from file
‚Ä¢ Analyze Game - View game statistics
‚Ä¢ Statistics - See your performance

‚ö° SPECIAL MOVES:
‚Ä¢ Castling: King moves 2 squares toward rook
‚Ä¢ En Passant: Pawn captures diagonally after double move
‚Ä¢ Promotion: Pawn becomes Queen/Rook/Bishop/Knight

‚ùì GETTING STARTED:
1. Click any white piece to start
2. Move pieces according to chess rules
3. Try to checkmate the black king
4. Use 'Hint' button if stuck

üìö LEARN MORE:
See USER_GUIDE.md for complete documentation
                `;
                
                alert(helpContent);
                this.updateStatusBar('Help information displayed');
            }
            
            startTutorial() {
                // Interactive tutorial
                const tutorialSteps = [
                    {
                        message: "‚ôî Welcome to Chess Tutorial! ‚ôõ\n\nClick any white pawn to begin.",
                        condition: (move) => move && move.piece && move.piece.toLowerCase() === 'p' && move.from[1] === 6
                    },
                    {
                        message: "‚ôô Good! Pawns move forward one square.\n\nTry moving the pawn two squares forward.",
                        condition: (move) => move && move.to[1] === 4
                    },
                    {
                        message: "‚ôô Excellent! Now try developing a piece.\n\nMove your knight to f3 (click knight, then f3).",
                        condition: (move) => move && move.piece && move.piece.toLowerCase() === 'n' && move.to[0] === 5 && move.to[1] === 5
                    },
                    {
                        message: "‚ôò Perfect! Knights are powerful pieces.\n\nContinue developing your pieces to control the center.",
                        condition: () => true
                    }
                ];
                
                let currentStep = 0;
                this.tutorialMode = true;
                this.tutorialSteps = tutorialSteps;
                
                alert(tutorialSteps[0].message);
                this.updateStatusBar('Tutorial started - follow the instructions');
            }
            
            checkTutorialProgress(lastMove) {
                if (this.tutorialMode && this.tutorialSteps) {
                    const currentStepObj = this.tutorialSteps[this.currentTutorialStep || 0];
                    if (currentStepObj && currentStepObj.condition(lastMove)) {
                        this.currentTutorialStep = (this.currentTutorialStep || 0) + 1;
                        if (this.currentTutorialStep < this.tutorialSteps.length) {
                            setTimeout(() => {
                                alert(this.tutorialSteps[this.currentTutorialStep].message);
                            }, 500);
                        } else {
                            this.tutorialMode = false;
                            this.updateStatusBar('Tutorial completed! Well done!');
                        }
                    }
                }
            }
        }

        // Initialize the game when page loads
        window.addEventListener('load', () => {
            const game = new ChessWebInterface();
            window.chessGame = game; // Make it globally accessible for debugging
        });
    </script>
</body>
</html>