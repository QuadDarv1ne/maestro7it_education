# 1️⃣3️⃣ Стандартная библиотека шаблонов (STL)

**Стандартная библиотека шаблонов (STL) в C++** — это мощный набор библиотек и алгоритмов, который предоставляет основные компоненты для работы с данными, включая контейнеры, итераторы, алгоритмы и функции.

STL позволяет разработчику быстро и эффективно решать задачи, связанные с обработкой данных.

### 1. Контейнеры

**Контейнеры** — это классы, которые хранят коллекции объектов.

STL предоставляет несколько типов контейнеров, каждый из которых имеет свои особенности и назначение.

**Основные контейнеры**
- `std::vector`: динамический массив, поддерживающий произвольный доступ к элементам.
- `std::list`: двусвязный список, позволяющий быстро вставлять и удалять элементы.
- `std::deque`: двусторонняя очередь, поддерживающая произвольный доступ и эффективное добавление/удаление элементов с обоих концов.
- `std::set`: множество уникальных элементов, упорядоченных по возрастанию.
- `std::map`: ассоциативный контейнер, хранящий пары ключ-значение и обеспечивающий доступ по ключу.
- `std::unordered_set`: неупорядоченное множество уникальных элементов, использующее хеширование.
- `std::unordered_map`: неупорядоченная ассоциативная коллекция пар ключ-значение, использующая хеширование.

**Пример использования `std::vector`:**

```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // Добавление элемента
    numbers.push_back(6);

    // Итерация через вектор
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

**Пример использования `std::map`:**

```
#include <iostream>
#include <map>

int main() {
    std::map<std::string, int> ageMap;

    // Добавление элементов
    ageMap["Alice"] = 30;
    ageMap["Bob"] = 25;

    // Итерация через map
    for (const auto& pair : ageMap) {
        std::cout << pair.first << " is " << pair.second << " years old" << std::endl;
    }

    return 0;
}
```

### 2. Итераторы

Итераторы позволяют проходить по элементам контейнеров.

Они предоставляют единый интерфейс для доступа к элементам контейнера, независимо от конкретного типа контейнера.

**Основные типы итераторов**

- `begin()` и `end()`: возвращают итераторы на начало и конец контейнера соответственно.
- `rbegin()` и `rend()`: возвращают итераторы на начало и конец контейнера в обратном порядке (реверсивные итераторы).

**Пример использования итераторов:**

```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {10, 20, 30, 40, 50};

    // Итерация через вектор с использованием итераторов
    for (std::vector<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 3. Алгоритмы

STL предоставляет большое количество стандартных алгоритмов для обработки данных в контейнерах, таких как сортировка, поиск, копирование и т.д.

**Основные алгоритмы**
- `std::sort`: сортировка элементов.
- `std::find`: поиск элемента.
- `std::count`: подсчёт количества вхождений элемента.
- `std::accumulate`: накопление значений (например, для вычисления суммы).

**Пример использования алгоритмов:**

```
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

int main() {
    std::vector<int> numbers = {5, 3, 8, 1, 2};

    // Сортировка
    std::sort(numbers.begin(), numbers.end());

    // Поиск
    auto it = std::find(numbers.begin(), numbers.end(), 3);

    if (it != numbers.end()) {
        std::cout << "Элемент найден: " << *it << std::endl;
    }

    // Накопление
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);
    std::cout << "Сумма элементов: " << sum << std::endl;

    return 0;
}
```

### 4. Функции и функторы

STL позволяет использовать функции в качестве аргументов для алгоритмов.

**Функторы (или функции-объекты)** — это объекты, которые можно вызывать как функции.

**Пример использования функций и функторов:**

```
#include <iostream>
#include <vector>
#include <algorithm>

// Функтор для сравнения
struct Compare {
    bool operator()(int a, int b) const {
        return a < b;
    }
};

int main() {
    std::vector<int> numbers = {5, 3, 8, 1, 2};

    // Использование функции в алгоритме
    std::sort(numbers.begin(), numbers.end(), Compare());

    // Вывод отсортированных элементов
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 5. Стек и очередь

STL также включает контейнеры, реализующие структуры данных стеков и очередей.

- `std::stack`: реализует структуру данных стек (LIFO - Last In, First Out).
- `std::queue`: реализует структуру данных очередь (FIFO - First In, First Out).
- `std::priority_queue`: реализует приоритетную очередь.

**Пример использования `std::stack`:**

```
#include <iostream>
#include <stack>

int main() {
    std::stack<int> s;

    // Добавление элементов в стек
    s.push(1);
    s.push(2);
    s.push(3);

    // Вывод элементов стека
    while (!s.empty()) {
        std::cout << s.top() << std::endl;
        s.pop();
    }

    return 0;
}
```

### Заключение

Стандартная библиотека шаблонов (STL) в C++ предоставляет мощные инструменты для работы с данными, включая контейнеры, итераторы, алгоритмы и функции.

Знание и умелое использование STL упрощает разработку, повышает эффективность и помогает создавать надёжный и поддерживаемый код.



**Автор:** Дуплей Максим Игоревич

**Дата:** 07.09.2024

**Версия 1.0**