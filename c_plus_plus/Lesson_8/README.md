# 8️⃣ Классы и объекты: основы объектно-ориентированного программирования

Объектно-ориентированное программирование (ООП) в C++ позволяет создавать программы, используя объекты и классы.

Это помогает лучше организовать код, улучшить его читаемость и облегчить поддержку.

Основные концепции ООП включают инкапсуляцию, наследование и полиморфизм.

### 1. Классы

**Класс** — это пользовательский тип данных, который объединяет данные (переменные) и функции (методы), работающие с этими данными.

Классы позволяют создавать объекты, которые инкапсулируют состояние и поведение.

**Определение класса**

```cpp
#include <iostream>
#include <string>

class Person {
public:
    // Конструктор
    Person(const std::string &name, int age) : name(name), age(age) {}

    // Метод для отображения информации
    void display() const {
        std::cout << "Имя: " << name << ", Возраст: " << age << std::endl;
    }

    // Метод для изменения возраста
    void setAge(int newAge) {
        age = newAge;
    }

    // Метод для получения возраста
    int getAge() const {
        return age;
    }

private:
    std::string name; // Имя
    int age;          // Возраст
};

int main() {
    Person person1("Иван", 30);
    person1.display();

    person1.setAge(31);
    std::cout << "Новый возраст: " << person1.getAge() << std::endl;

    return 0;
}
```

**Конструкторы и деструкторы**

**Конструктор** — это специальный метод, который вызывается при создании объекта.

Он инициализирует объект.

**Деструктор** — это специальный метод, который вызывается при уничтожении объекта.

Он освобождает ресурсы, если это необходимо.

```cpp
#include <iostream>

class Example {
public:
    Example() {
        std::cout << "Конструктор вызван." << std::endl;
    }

    ~Example() {
        std::cout << "Деструктор вызван." << std::endl;
    }
};

int main() {
    Example obj; // Конструктор вызывается при создании объекта
    // Деструктор вызывается при выходе из области видимости
    return 0;
}
```

### 2. Объекты

**Объект** — это экземпляр класса.

Объекты создаются на основе определения класса и имеют доступ ко всем его методам и членам.

**Создание и использование объектов**

```cpp
#include <iostream>

class Car {
public:
    // Конструктор
    Car(const std::string &model, int year) : model(model), year(year) {}

    // Метод для отображения информации
    void displayInfo() const {
        std::cout << "Модель: " << model << ", Год выпуска: " << year << std::endl;
    }

private:
    std::string model; // Модель автомобиля
    int year;          // Год выпуска
};

int main() {
    Car car1("Toyota", 2020);
    car1.displayInfo();

    return 0;
}
```

### 3. Инкапсуляция

**Инкапсуляция** — это принцип ООП, который скрывает внутренние детали реализации объекта и предоставляет доступ к ним только через методы.

**Модификаторы доступа**

- public: члены класса доступны извне.
- private: члены класса доступны только внутри класса.
- protected: члены класса доступны внутри класса и его производных классов.

```cpp
#include <iostream>

class Account {
public:
    Account(double initialBalance) : balance(initialBalance) {}

    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }

    void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
        }
    }

    double getBalance() const {
        return balance;
    }

private:
    double balance; // Баланс счета
};

int main() {
    Account acc(1000.0);
    acc.deposit(500.0);
    acc.withdraw(200.0);
    std::cout << "Баланс: " << acc.getBalance() << std::endl;

    return 0;
}
```

### 4. Наследование

Наследование позволяет создавать новые классы на основе существующих.

Это позволяет повторно использовать код и расширять функциональность.

**Определение класса-наследника**

```cpp
#include <iostream>

class Animal {
public:
    void eat() const {
        std::cout << "Животное ест." << std::endl;
    }
};

class Dog : public Animal {
public:
    void bark() const {
        std::cout << "Собака лает." << std::endl;
    }
};

int main() {
    Dog dog;
    dog.eat(); // Наследуемый метод
    dog.bark(); // Метод класса-наследника

    return 0;
}
```

### 5. Полиморфизм

Полиморфизм позволяет использовать один интерфейс для работы с объектами различных типов.

В C++ полиморфизм реализуется через виртуальные функции и наследование.

**Виртуальные функции**

```cpp
#include <iostream>

class Base {
public:
    virtual void show() const {
        std::cout << "Это базовый класс." << std::endl;
    }

    virtual ~Base() = default; // Виртуальный деструктор
};

class Derived : public Base {
public:
    void show() const override {
        std::cout << "Это производный класс." << std::endl;
    }
};

int main() {
    Base *ptr;
    Derived derived;
    ptr = &derived;

    ptr->show(); // Вызов переопределённого метода

    return 0;
}
```

### Заключение

Классы и объекты являются основными концепциями объектно-ориентированного программирования в C++.

Они позволяют создавать и управлять сложными типами данных, инкапсулировать состояние и поведение, а также расширять функциональность через наследование и полиморфизм.

Понимание этих концепций важно для разработки масштабируемых и поддерживаемых программ.



**Автор:** Дуплей Максим Игоревич

**Дата:** 07.09.2024

**Версия 1.0**