# 1️⃣ Работа с многопоточностью `std::thread`

## Оглавление

1. [Введение](#введение)
2. [Подключение библиотеки](#подключение-библиотеки)
3. [Создание потока](#создание-потока)
4. [Запуск и ожидание завершения потока](#запуск-и-ожидание-завершения-потока)
5. [Передача аргументов в поток](#передача-аргументов-в-поток)
6. [Использование лямбда-выражений](#использование-лямбда-выражений)
7. [Управление несколькими потоками](#управление-несколькими-потоками)
8. [Синхронизация потоков](#синхронизация-потоков)
9. [Обработка исключений](#обработка-исключений)
10. [Завершение работы с потоками](#завершение-работы-с-потоками)
11. [Заключение](#заключение)

---

## Введение

Многопоточность позволяет выполнять несколько задач параллельно, что может значительно улучшить производительность программ, особенно на многоядерных процессорах.

В `C++`, начиная с стандарта `C++11`, для работы с потоками используется библиотека `<thread>`

Этот мануал поможет вам понять, как создавать и управлять потоками с использованием `std::thread`

## Подключение библиотеки

**Для работы с потоками необходимо подключить заголовочный файл `<thread>`:**

```cpp
#include <thread>
```

## Создание потока

Поток можно создать, передав функцию или лямбда-выражение в конструктор `std::thread`

```cpp
void myFunction() {
    // Код, который будет выполняться в потоке
}

std::thread t1(myFunction);
```

## Запуск и ожидание завершения потока

После создания потока его нужно запустить и дождаться его завершения с помощью метода `join()`

Это гарантирует, что основной поток будет ждать завершения потока t1 перед продолжением выполнения.

```cpp
t1.join();
```

## Передача аргументов в поток

Вы можете передавать аргументы в функцию, выполняемую потоком.

Это полезно, когда функция требует дополнительных данных для выполнения.

```cpp
void myFunctionWithArgs(int x, double y) {
    // Использование аргументов
}

std::thread t2(myFunctionWithArgs, 42, 3.14);
```

## Использование лямбда-выражений

Лямбда-выражения могут быть полезны для передачи локальных переменных в поток.

Это позволяет избежать создания отдельных функций для каждой задачи.

```cpp
int localVar = 10;
std::thread t3([localVar]() {
    // Использование localVar в потоке
});
```

## Управление несколькими потоками

Для управления несколькими потоками удобно использовать контейнеры, такие как `std::vector`

Это позволяет легко запускать и ожидать завершения множества потоков.

```cpp
std::vector<std::thread> threads;

for (int i = 0; i < 5; ++i) {
    threads.push_back(std::thread(printMessage, "Hello from thread " + std::to_string(i)));
}

for (auto& t : threads) {
    t.join();
}
```

## Синхронизация потоков

При работе с общими ресурсами в нескольких потоках необходимо использовать механизмы синхронизации, такие как `std::mutex`, чтобы избежать состояния гонки.

```cpp
#include <mutex>

std::mutex mtx;

void safePrint(const std::string& message) {
    std::lock_guard<std::mutex> lock(mtx);
    std::cout << message << std::endl;
}
```

## Обработка исключений

Если функция, выполняемая в потоке, выбрасывает исключение, это приведет к вызову `std::terminate`

Поэтому важно обрабатывать исключения внутри потоков.

```cpp
void riskyFunction() {
    try {
        // Код, который может выбросить исключение
    } catch (const std::exception& e) {
        std::cerr << "Exception caught: " << e.what() << std::endl;
    }
}
```

## Завершение работы с потоками

Всегда убедитесь, что вы вызвали `join()` для всех созданных потоков перед завершением программы

Это предотвращает утечки ресурсов и гарантирует корректное завершение всех потоков.

При работе с многопоточностью в C++ важно правильно завершать работу всех потоков, чтобы избежать утечек ресурсов и обеспечить корректное завершение программы. 

**Вот более подробное объяснение, почему и как это делать:**

### Почему важно завершать потоки правильно?

#### **Предотвращение утечек ресурсов:**

Если поток не был завершен правильно, он может продолжать использовать системные ресурсы, такие как память и процессорное время, даже после завершения основной программы. Это может привести к утечкам ресурсов и нестабильной работе системы.

#### **Гарантия корректного завершения:**

Правильное завершение потоков гарантирует, что все задачи, которые они выполняли, были завершены. Это особенно важно, если потоки выполняют критически важные операции, такие как запись данных в файл или обновление базы данных.

#### **Избежание неопределенного поведения:**

Незавершенные потоки могут вызвать неопределенное поведение программы, включая зависание или аварийное завершение. Это связано с тем, что потоки могут продолжать выполнять код, который зависит от состояния основного потока или других потоков.

### Как правильно завершать потоки?

#### **Использование join():**

Метод `join()` блокирует вызывающий поток до тех пор, пока поток, для которого он был вызван, не завершится.

Это гарантирует, что основной поток дождется завершения всех созданных потоков перед своим завершением.

```cpp
std::thread t1(myFunction);
t1.join();  // Основной поток ждет завершения t1
```

#### **Использование detach():**

Метод `detach()` отсоединяет поток от объекта `std::thread`, позволяя ему выполняться независимо.

Однако это требует осторожного управления, так как отсоединенный поток нельзя будет присоединить обратно, и его завершение нужно будет контролировать другими средствами.

```cpp
std::thread t2(myFunction);
t2.detach();  // Поток t2 будет выполняться независимо
```

**Проверка завершения потоков:**

Перед завершением программы рекомендуется проверять, завершились ли все потоки.

Это можно сделать с помощью флагов или других механизмов синхронизации.

## Обработка исключений:

Если поток может выбросить исключение, важно его перехватить и обработать, чтобы избежать аварийного завершения программы.

```cpp
void threadFunction() {
    try {
        // Код, который может выбросить исключение
    } catch (const std::exception& e) {
        std::cerr << "Exception in thread: " << e.what() << std::endl;
    }
}
```

**Пример правильного завершения потоков**

```cpp
#include <iostream>
#include <thread>
#include <vector>

void printMessage(const std::string& message) {
    std::cout << message << std::endl;
}

int main() {
    std::vector<std::thread> threads;

    for (int i = 0; i < 5; ++i) {
        threads.push_back(std::thread(printMessage, "Hello from thread " + std::to_string(i)));
    }

    // Ожидание завершения всех потоков
    for (auto& t : threads) {
        if (t.joinable()) {
            t.join();
        }
    }

    std::cout << "All threads have finished execution." << std::endl;
    return 0;
}
```

В этом примере создается несколько потоков, каждый из которых выполняет функцию `printMessage`

Основной поток ожидает завершения всех созданных потоков с помощью метода `join()`, что гарантирует корректное завершение программы.

## Заключение

Использование многопоточности может значительно улучшить производительность ваших программ, но также требует тщательного управления и синхронизации.

Следуя этому руководству, вы сможете эффективно использовать `std::thread` для создания многопоточных приложений на `C++`

---

**Автор:** Дуплей Максим Игоревич

**Дата:** 18.02.2025

**Версия 1.0**
