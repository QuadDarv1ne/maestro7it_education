# 9️⃣ Наследование и полиморфизм

**Наследование и полиморфизм** — это ключевые концепции объектно-ориентированного программирования (ООП) в C++, которые позволяют создавать гибкие и расширяемые программы.

### 1. Наследование

Наследование позволяет создавать новый класс на основе существующего.

Новый класс, называемый производным, наследует члены базового класса и может добавлять новые члены или переопределять существующие.

**Типы наследования**

**Публичное наследование:** производный класс наследует все публичные и защищенные члены базового класса как публичные и защищенные соответственно. Это самый распространённый тип наследования.

```cpp
#include <iostream>

class Animal {
public:
    void eat() const {
        std::cout << "Животное ест." << std::endl;
    }

protected:
    void sleep() const {
        std::cout << "Животное спит." << std::endl;
    }
};

class Dog : public Animal {
public:
    void bark() const {
        std::cout << "Собака лает." << std::endl;
    }
};

int main() {
    Dog dog;
    dog.eat();   // Метод базового класса
    dog.bark();  // Метод производного класса
    // dog.sleep(); // Ошибка: sleep() защищён

    return 0;
}
```

**Защищённое наследование:** члены базового класса становятся защищёнными в производном классе.

```cpp
#include <iostream>

class Base {
public:
    int publicValue;
protected:
    int protectedValue;
private:
    int privateValue;
};

class Derived : protected Base {
public:
    void setValues() {
        publicValue = 1;     // Доступно
        protectedValue = 2;  // Доступно
        // privateValue = 3; // Недоступно
    }
};

int main() {
    Derived d;
    d.setValues();
    // d.publicValue = 4; // Ошибка: publicValue защищён
    // d.protectedValue = 5; // Ошибка: protectedValue защищён

    return 0;
}
```

**Приватное наследование:** члены базового класса становятся приватными в производном классе.

```cpp
#include <iostream>

class Base {
public:
    void show() const {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : private Base {
public:
    void callShow() const {
        show(); // Доступно, так как show() принадлежит Base
    }
};

int main() {
    Derived d;
    d.callShow();
    // d.show(); // Ошибка: show() приватный

    return 0;
}
```

**Конструкторы и деструкторы в наследовании**

Конструкторы базового класса не вызываются автоматически в производных классах. Для их вызова используется список инициализации конструктора производного класса.

Деструкторы базового класса должны быть виртуальными, если класс используется как базовый для других классов, чтобы предотвратить утечки памяти.

```cpp
#include <iostream>

class Base {
public:
    Base() {
        std::cout << "Конструктор Base" << std::endl;
    }
    virtual ~Base() {
        std::cout << "Деструктор Base" << std::endl;
    }
};

class Derived : public Base {
public:
    Derived() {
        std::cout << "Конструктор Derived" << std::endl;
    }
    ~Derived() {
        std::cout << "Деструктор Derived" << std::endl;
    }
};

int main() {
    Derived d; // Конструктор и деструктор вызываются в порядке от базового к производному
    return 0;
}
```

### 2. Полиморфизм

Полиморфизм позволяет использовать один интерфейс для работы с объектами различных типов.

Это достигается через виртуальные функции и позволяет вызывать переопределенные методы на основе типа объекта, а не типа указателя.

**Полиморфизм** — это концепция в объектно-ориентированном программировании (ООП), которая позволяет объектам разных классов использовать методы с одинаковыми именами, но разной реализацией. Это означает, что один и тот же интерфейс может быть использован для работы с разными типами данных или объектами.

**Виртуальные функции**

Виртуальные функции определяются в базовом классе и переопределяются в производных классах.

Для использования полиморфизма метод в базовом классе должен быть объявлен, как виртуальный с помощью ключевого слова `virtual`

```cpp
#include <iostream>

class Base {
public:
    virtual void show() const {
        std::cout << "Базовый класс" << std::endl;
    }
    virtual ~Base() {} // Виртуальный деструктор
};

class Derived : public Base {
public:
    void show() const override {
        std::cout << "Производный класс" << std::endl;
    }
};

int main() {
    Base *ptr;
    Derived derived;
    ptr = &derived;

    ptr->show(); // Вызов переопределённого метода

    return 0;
}
```

**Чисто виртуальные функции и абстрактные классы**

**Чисто виртуальная функция** — это функция, которая объявляется в базовом классе, но не имеет реализации в этом классе.

Она предназначена для того, чтобы быть переопределенной в производных классах.

Чисто виртуальная функция делает класс абстрактным, что означает, что вы не можете создать объект этого класса напрямую.

- Класс, содержащий хотя бы одну чисто виртуальную функцию, является абстрактным классом и не может быть создан напрямую.
- Чисто виртуальная функция в C++ используется для создания абстрактных классов, которые не могут быть инстанцированы напрямую. Это позволяет определить интерфейсы, которые должны быть реализованы в производных классах.

*инстанцированы* - термин `инстанцированы` происходит от английского слова `instantiated` и используется в контексте программирования и объектно-ориентированного программирования (ООП). Он означает создание конкретного экземпляра (инстанса) класса или объекта на основе его определения или шаблона.

```cpp
#include <iostream>

class AbstractShape {
public:
    virtual void draw() const = 0; // Чисто виртуальная функция
    virtual ~AbstractShape() {}
};

class Circle : public AbstractShape {
public:
    void draw() const override {
        std::cout << "Рисование круга" << std::endl;
    }
};

int main() {
    Circle circle;
    AbstractShape *shape = &circle;

    shape->draw(); // Вызов переопределённого метода

    return 0;
}
```

#### Вот несколько ключевых причин, для чего нужны чисто виртуальные функции:

1. Определение интерфейсов

Чисто виртуальные функции позволяют определить интерфейсы, которые должны быть реализованы в производных классах.

Это обеспечивает единообразие и гарантирует, что все производные классы будут иметь определенные методы.

```CPP
class Shape {
public:
    virtual void draw() = 0; // Чисто виртуальная функция
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a circle" << std::endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a rectangle" << std::endl;
    }
};
```

2. Полиморфизм

Чисто виртуальные функции позволяют использовать полиморфизм.

Вы можете создать указатель или ссылку на базовый класс и использовать их для работы с объектами производных классов.

```CPP
void renderShape(Shape* shape) {
    shape->draw();
}

int main() {
    Circle circle;
    Rectangle rectangle;

    renderShape(&circle);      // Вывод: Drawing a circle
    renderShape(&rectangle);   // Вывод: Drawing a rectangle

    return 0;
}
```

3. Проектирование программного обеспечения

Абстрактные классы с чисто виртуальными функциями помогают в проектировании программного обеспечения.

Они позволяют определить общие интерфейсы и поведение, которые должны быть реализованы в производных классах.

Это упрощает поддержку и расширение кода.

4. Предотвращение создания объектов базового класса

Чисто виртуальные функции предотвращают создание объектов базового класса, что может быть полезно, если базовый класс предназначен только для наследования и не должен использоваться напрямую.

```CPP
class Animal {
public:
    virtual void makeSound() = 0; // Чисто виртуальная функция
};

// Animal animal; // Ошибка: нельзя создать объект абстрактного класса
```

5. Документирование намерений

Чисто виртуальные функции также служат для документирования намерений разработчика.

Они ясно показывают, что данный метод должен быть реализован в производных классах, что улучшает читаемость и понимание кода.

```CPP
class Vehicle {
public:
    virtual void startEngine() = 0; // Чисто виртуальная функция
    virtual void stopEngine() = 0;  // Чисто виртуальная функция
};

class Car : public Vehicle {
public:
    void startEngine() override {
        std::cout << "Car engine started" << std::endl;
    }

    void stopEngine() override {
        std::cout << "Car engine stopped" << std::endl;
    }
};

class Motorcycle : public Vehicle {
public:
    void startEngine() override {
        std::cout << "Motorcycle engine started" << std::endl;
    }

    void stopEngine() override {
        std::cout << "Motorcycle engine stopped" << std::endl;
    }
};

int main() {
    Car car;
    Motorcycle motorcycle;

    Vehicle* vehicle1 = &car;
    Vehicle* vehicle2 = &motorcycle;

    vehicle1->startEngine(); // Вывод: Car engine started
    vehicle1->stopEngine();  // Вывод: Car engine stopped

    vehicle2->startEngine(); // Вывод: Motorcycle engine started
    vehicle2->stopEngine();  // Вывод: Motorcycle engine stopped

    return 0;
}
```

В этом примере `Vehicle` — это абстрактный класс с чисто виртуальными функциями `startEngine` и `stopEngine`

Классы `Car` и `Motorcycle` наследуются от `Vehicle` и реализуют эти функции.

Это позволяет использовать полиморфизм для работы с объектами `Car` и `Motorcycle` через указатели на базовый класс `Vehicle`

Таким образом, чисто виртуальные функции являются мощным инструментом для создания гибких и расширяемых программных архитектур.

---

### Выводы

Наследование позволяет создавать новые классы на основе существующих, повторно использовать код и расширять функциональность.

Полиморфизм позволяет использовать один интерфейс для работы с объектами разных типов, что делает код более гибким и расширяемым.

Обе концепции являются основой объектно-ориентированного программирования и помогают создавать более организованные и поддерживаемые программы.

**Наследование**

- Позволяет создавать новые классы на основе существующих.
- Способствует повторному использованию кода (`DRY — Don't Repeat Yourself`).
- Расширяет функциональность, добавляя новые свойства и методы или переопределяя существующие.
- **Пример:** класс `Dog` может наследовать от класса `Animal`, чтобы использовать общие свойства (например, `name`) и методы (например, `eat()`).

**Полиморфизм**
- Позволяет использовать один интерфейс для работы с объектами разных типов.
- Делает код гибким и расширяемым, так как один метод может работать с разными классами.
- **Пример:** метод `speak()` может быть реализован по-разному в классах `Dog` и `Cat`, но вызываться через общий интерфейс `Animal`

---

**Автор:** Дуплей Максим Игоревич

**Дата:** 07.09.2024

**Версия 1.0**
