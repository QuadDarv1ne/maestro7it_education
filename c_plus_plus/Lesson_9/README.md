# 9️⃣ Наследование и полиморфизм

**Наследование и полиморфизм** — это ключевые концепции объектно-ориентированного программирования (ООП) в C++, которые позволяют создавать гибкие и расширяемые программы.

### 1. Наследование

Наследование позволяет создавать новый класс на основе существующего.

Новый класс, называемый производным, наследует члены базового класса и может добавлять новые члены или переопределять существующие.

**Типы наследования**

**Публичное наследование:** производный класс наследует все публичные и защищенные члены базового класса как публичные и защищенные соответственно. Это самый распространённый тип наследования.

```cpp
#include <iostream>

class Animal {
public:
    void eat() const {
        std::cout << "Животное ест." << std::endl;
    }

protected:
    void sleep() const {
        std::cout << "Животное спит." << std::endl;
    }
};

class Dog : public Animal {
public:
    void bark() const {
        std::cout << "Собака лает." << std::endl;
    }
};

int main() {
    Dog dog;
    dog.eat();   // Метод базового класса
    dog.bark();  // Метод производного класса
    // dog.sleep(); // Ошибка: sleep() защищён

    return 0;
}
```

**Защищённое наследование:** члены базового класса становятся защищёнными в производном классе.

```cpp
#include <iostream>

class Base {
public:
    int publicValue;
protected:
    int protectedValue;
private:
    int privateValue;
};

class Derived : protected Base {
public:
    void setValues() {
        publicValue = 1;     // Доступно
        protectedValue = 2;  // Доступно
        // privateValue = 3; // Недоступно
    }
};

int main() {
    Derived d;
    d.setValues();
    // d.publicValue = 4; // Ошибка: publicValue защищён
    // d.protectedValue = 5; // Ошибка: protectedValue защищён

    return 0;
}
```

**Приватное наследование:** члены базового класса становятся приватными в производном классе.

```cpp
#include <iostream>

class Base {
public:
    void show() const {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : private Base {
public:
    void callShow() const {
        show(); // Доступно, так как show() принадлежит Base
    }
};

int main() {
    Derived d;
    d.callShow();
    // d.show(); // Ошибка: show() приватный

    return 0;
}
```

**Конструкторы и деструкторы в наследовании**

Конструкторы базового класса не вызываются автоматически в производных классах. Для их вызова используется список инициализации конструктора производного класса.

Деструкторы базового класса должны быть виртуальными, если класс используется как базовый для других классов, чтобы предотвратить утечки памяти.

```cpp
#include <iostream>

class Base {
public:
    Base() {
        std::cout << "Конструктор Base" << std::endl;
    }
    virtual ~Base() {
        std::cout << "Деструктор Base" << std::endl;
    }
};

class Derived : public Base {
public:
    Derived() {
        std::cout << "Конструктор Derived" << std::endl;
    }
    ~Derived() {
        std::cout << "Деструктор Derived" << std::endl;
    }
};

int main() {
    Derived d; // Конструктор и деструктор вызываются в порядке от базового к производному
    return 0;
}
```

### 2. Полиморфизм

Полиморфизм позволяет использовать один интерфейс для работы с объектами различных типов.

Это достигается через виртуальные функции и позволяет вызывать переопределенные методы на основе типа объекта, а не типа указателя.

**Полиморфизм** — это концепция в объектно-ориентированном программировании (ООП), которая позволяет объектам разных классов использовать методы с одинаковыми именами, но разной реализацией. Это означает, что один и тот же интерфейс может быть использован для работы с разными типами данных или объектами.

**Виртуальные функции**

Виртуальные функции определяются в базовом классе и переопределяются в производных классах.

Для использования полиморфизма метод в базовом классе должен быть объявлен, как виртуальный с помощью ключевого слова `virtual`

```cpp
#include <iostream>

class Base {
public:
    virtual void show() const {
        std::cout << "Базовый класс" << std::endl;
    }
    virtual ~Base() {} // Виртуальный деструктор
};

class Derived : public Base {
public:
    void show() const override {
        std::cout << "Производный класс" << std::endl;
    }
};

int main() {
    Base *ptr;
    Derived derived;
    ptr = &derived;

    ptr->show(); // Вызов переопределённого метода

    return 0;
}
```

**Чисто виртуальные функции и абстрактные классы**

**Чисто виртуальная функция** — это функция, которая объявляется в базовом классе, но не имеет реализации в этом классе.

Она предназначена для того, чтобы быть переопределенной в производных классах.

Чисто виртуальная функция делает класс абстрактным, что означает, что вы не можете создать объект этого класса напрямую.

- Класс, содержащий хотя бы одну чисто виртуальную функцию, является абстрактным классом и не может быть создан напрямую.
- Чисто виртуальная функция в C++ используется для создания абстрактных классов, которые не могут быть инстанцированы напрямую. Это позволяет определить интерфейсы, которые должны быть реализованы в производных классах.

```cpp
#include <iostream>

class AbstractShape {
public:
    virtual void draw() const = 0; // Чисто виртуальная функция
    virtual ~AbstractShape() {}
};

class Circle : public AbstractShape {
public:
    void draw() const override {
        std::cout << "Рисование круга" << std::endl;
    }
};

int main() {
    Circle circle;
    AbstractShape *shape = &circle;

    shape->draw(); // Вызов переопределённого метода

    return 0;
}
```

### Выводы

Наследование позволяет создавать новые классы на основе существующих, повторно использовать код и расширять функциональность.

Полиморфизм позволяет использовать один интерфейс для работы с объектами разных типов, что делает код более гибким и расширяемым.

Обе концепции являются основой объектно-ориентированного программирования и помогают создавать более организованные и поддерживаемые программы.

**Наследование**

- Позволяет создавать новые классы на основе существующих.
- Способствует повторному использованию кода (`DRY — Don't Repeat Yourself`).
- Расширяет функциональность, добавляя новые свойства и методы или переопределяя существующие.
- **Пример:** класс `Dog` может наследовать от класса `Animal`, чтобы использовать общие свойства (например, `name`) и методы (например, `eat()`).

**Полиморфизм**
- Позволяет использовать один интерфейс для работы с объектами разных типов.
- Делает код гибким и расширяемым, так как один метод может работать с разными классами.
- **Пример:** метод `speak()` может быть реализован по-разному в классах `Dog` и `Cat`, но вызываться через общий интерфейс `Animal`


**Автор:** Дуплей Максим Игоревич

**Дата:** 07.09.2024

**Версия 1.0**
